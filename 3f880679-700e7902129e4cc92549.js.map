{"version":3,"sources":["webpack:///./node_modules/algebrite/dist/algebrite.js"],"names":["$","ABS","ADD","ADJ","AND","APPROXRATIO","ARCCOS","ARCCOSH","ARCSIN","ARCSINH","ARCTAN","ARCTANH","ARG","ASSUME_REAL_VARIABLES","ATOMIZE","AUTOEXPAND","BAKE","BESSELJ","BESSELY","BINDING","BINOMIAL","BINOM_check_args","BUF","C1","C2","C3","C4","C5","C6","CEILING","CHECK","CHOOSE","CIRCEXP","CLEAR","CLEARALL","CLEARPATTERNS","CLOCK","COEFF","COFACTOR","CONDENSE","CONJ","CONS","CONTRACT","COS","COSH","Condense","DEBUG","DEBUG_ABS","DEBUG_ARG","DEBUG_CLOCKFORM","DEBUG_IMAG","DEBUG_IS","DEBUG_POWER","DEBUG_RECT","DECOMP","DEFINT","DEGREE","DENOMINATOR","DERIVATIVE","DET","DET_check_arg","DIM","DIRAC","DIVISORS","DO","DOT","DOUBLE","DRAW","DRAWX","DSOLVE","E","EIGEN","EIGENVAL","EIGENVEC","EIG_N","EIG_check_arg","EIG_yydd","EIG_yyqq","ERF","ERFC","EVAL","EXP","EXPAND","EXPCOS","EXPSIN","Eval","Eval_Eval","Eval_abs","Eval_add","Eval_adj","Eval_and","Eval_approxratio","Eval_arccos","Eval_arccosh","Eval_arcsin","Eval_arcsinh","Eval_arctan","Eval_arctanh","Eval_arg","Eval_besselj","Eval_bessely","Eval_binding","Eval_binomial","Eval_ceiling","Eval_check","Eval_choose","Eval_circexp","Eval_clear","Eval_clearall","Eval_clearpatterns","Eval_clock","Eval_coeff","Eval_cofactor","Eval_condense","Eval_conj","Eval_cons","Eval_contract","Eval_cos","Eval_cosh","Eval_decomp","Eval_defint","Eval_degree","Eval_denominator","Eval_derivative","Eval_det","Eval_dim","Eval_dirac","Eval_divisors","Eval_do","Eval_dsolve","Eval_eigen","Eval_eigenval","Eval_eigenvec","Eval_erf","Eval_erfc","Eval_exp","Eval_expand","Eval_expcos","Eval_expsin","Eval_factor","Eval_factorial","Eval_factorpoly","Eval_filter","Eval_float","Eval_floor","Eval_for","Eval_function_reference","Eval_gamma","Eval_gcd","Eval_hermite","Eval_hilbert","Eval_imag","Eval_index","_Eval_inner","Eval_integral","Eval_inv","Eval_invg","Eval_isinteger","Eval_isprime","Eval_laguerre","Eval_lcm","Eval_leading","Eval_legendre","Eval_log","Eval_lookup","Eval_mod","Eval_multiply","Eval_noexpand","Eval_not","Eval_nroots","Eval_number","Eval_numerator","Eval_operator","Eval_or","Eval_outer","Eval_pattern","Eval_patternsinfo","Eval_polar","Eval_power","Eval_predicate","Eval_prime","Eval_print","Eval_print2dascii","Eval_printcomputer","Eval_printhuman","Eval_printlatex","Eval_printlist","Eval_product","Eval_quote","Eval_quotient","Eval_rank","Eval_rationalize","Eval_real","Eval_rect","Eval_roots","Eval_round","Eval_setq","Eval_sgn","Eval_shape","Eval_silentpattern","Eval_simfac","Eval_simplify","Eval_sin","Eval_sinh","Eval_sqrt","Eval_stop","Eval_subst","Eval_sum","Eval_sym","Eval_symbolsinfo","Eval_tan","Eval_tanh","Eval_taylor","Eval_tensor","Eval_test","Eval_testeq","Eval_testge","Eval_testgt","Eval_testle","Eval_testlt","Eval_transpose","Eval_unit","Eval_user_function","Eval_zero","Evalpoly","FACTOR","FACTORIAL","FACTORPOLY","FILTER","FLOATF","FLOOR","FOR","FORCE_FIXED_PRINTOUT","FUNCTION","_Find","GAMMA","GCD","HERMITE","HILBERT","IMAG","INDEX","INNER","INTEGRAL","INV","INVG","INV_check_arg","INV_decomp","ISINTEGER","ISPRIME","LAGUERRE","LAST","LAST_2DASCII_PRINT","LAST_FULL_PRINT","LAST_LATEX_PRINT","LAST_LIST_PRINT","LAST_PLAIN_PRINT","LAST_PRINT","LCM","LEADING","LEGENDRE","LOG","LOOKUP","M","MAXDIM","MAXPRIMETAB","MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES","MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE","MAX_FIXED_PRINTOUT_DIGITS","MAX_PROGRAM_SIZE","MEQUAL","METAA","METAB","METAX","MLENGTH","MOD","MSIGN","MULTIPLY","MZERO","N","NIL","NOT","NROOTS","NROOTS_ABS","NROOTS_DELTA","NROOTS_EPSILON","NROOTS_RANDOM","NROOTS_YMAX","NROOTS_divpoly","NSYM","NUM","NUMBER","NUMERATOR","OPERATOR","OR","OUTER","PATTERN","PATTERNSINFO","PI","POLAR","POWER","PRIME","PRINT","PRINT2DASCII","PRINTFULL","PRINTLATEX","PRINTLIST","PRINTMODE_2DASCII","PRINTMODE_COMPUTER","PRINTMODE_HUMAN","PRINTMODE_LATEX","PRINTMODE_LIST","PRINTOUTRESULT","PRINTPLAIN","PRINT_LEAVE_E_ALONE","PRINT_LEAVE_X_ALONE","PRODUCT","QUOTE","QUOTIENT","RANK","RATIONALIZE","REAL","ROOTS","ROUND","SECRETX","SELFTEST","SETQ","SGN","SHAPE","SILENTPATTERN","SIMPLIFY","SIN","SINH","SPACE_BETWEEN_COLUMNS","SPACE_BETWEEN_ROWS","SQRT","STOP","STR","SUBST","SUM","SYM","SYMBOLSINFO","SYMBOL_A","SYMBOL_A_UNDERSCORE","SYMBOL_B","SYMBOL_B_UNDERSCORE","SYMBOL_C","SYMBOL_D","SYMBOL_I","SYMBOL_IDENTITY_MATRIX","SYMBOL_J","SYMBOL_N","SYMBOL_R","SYMBOL_S","SYMBOL_T","SYMBOL_X","SYMBOL_X_UNDERSCORE","SYMBOL_Y","SYMBOL_Z","TAN","TANH","TAYLOR","TENSOR","TEST","TESTEQ","TESTGE","TESTGT","TESTLE","TESTLT","TIMING_DEBUGS","TOS","TRACE","TRANSPOSE","T_DOUBLE","T_EQ","T_FUNCTION","T_GTEQ","T_INTEGER","T_LTEQ","T_NEQ","T_NEWLINE","T_QUOTASSIGN","T_STRING","T_SYMBOL","U","UNIT","USR_SYMBOLS","VERSION","YMAX","YYE","YYRECT","ZERO","__emit_char","__emit_str","__factor_add","__factorial","__is_negative","__is_radical_number","__lcm","__legendre","__legendre2","__legendre3","__normalize_radical_factors","__rationalize_tensor","_print","abs","absValFloat","_absval","absval_tensor","add","addSymbolLeftOfAssignment","addSymbolRightOfAssignment","add_all","add_factor_to_accumulator","add_numbers","add_terms","addf","adj","alloc_tensor","allocatedId","any_denominators","approxAll","approxLogs","approxLogsOfRationals","approxOneRatioOnly","approxRadicals","approxRadicalsOfRationals","approxRationalsOfLogs","approxRationalsOfPowersOfE","approxRationalsOfPowersOfPI","approxRationalsOfRadicals","approxSineOfRationalMultiplesOfPI","approxSineOfRationals","approxTrigonometric","approx_just_an_integer","approx_logarithmsOfRationals","approx_nothingUseful","approx_radicalOfRatio","approx_ratioOfRadical","approx_rationalOfE","approx_rationalOfPi","approx_rationalsOfLogarithms","approx_sine_of_pi_times_rational","approx_sine_of_rational","_approxratioRecursive","arccos","arccosh","arcsin","arcsinh","_arctan","arctanh","areunivarpolysfactoredorexpandedform","arg","arglist","assignmentFound","avoidCalculatingPowersIntoArctans","_bake","bake_poly","bake_poly_term","besselj","bessely","bigInt","bignum_factorial","bignum_float","bignum_power_number","bignum_scan_float","bignum_scan_integer","bignum_truncate","binding","binomial","buffer","build_tensor","caaddr","caadr","caar","cadaddr","cadadr","cadar","caddaddr","caddadr","caddar","caddddr","cadddr","caddr","cadr","called_from_Algebra_block","car","cdaddr","cdadr","cdar","cddaddr","cddar","cdddaddr","cddddr","cdddr","cddr","cdr","ceiling","chainOfUserSymbolsNotFunctionsBeingEvaluated","charTabIndex","chartab","checkFloatHasWorkedOutCompletely","check_esc_flag","check_stack","check_tensor_dimensions","choose","choose_check_args","_circexp","clearAlgebraEnvironment","clearRenamedVariablesToAvoidBindingToExternalScope","clear_symbols","clear_term","clearall","clockform","cmpGlyphs","cmp_args","_cmp_expr","cmp_terms","cmp_terms_count","codeGen","coeff","cofactor","collectLatexStringFromReturnValue","_collectUserSymbols","combine_factors","combine_gammas","combine_terms","compareState","compare_numbers","compare_rationals","compare_tensors","compatible","computeDependenciesFromAlgebra","computeResultsAndJavaScriptFromAlgebra","compute_fa","conjugate","cons","consCount","contract","convert_bignum_to_double","convert_rational_to_double","copy_tensor","cosine","cosine_of_angle","cosine_of_angle_sum","_count","_countOccurrencesOfSymbol","count_denominators","counter","countsize","d_scalar_scalar","d_scalar_scalar_1","d_scalar_tensor","d_tensor_scalar","d_tensor_tensor","dabs","darccos","darccosh","darcsin","darcsinh","darctan","darctanh","dbesselj0","dbesseljn","dbessely0","dbesselyn","dcos","dcosh","dd","_decomp","decomp_product","decomp_sum","defineSomeHandyConstants","define_user_function","defn","defn_str","degree","_denominator","derf","derfc","derivative","derivative_of_integral","det","determinant","detg","dfunction","dhermite","dirac","display","display_flag","displaychar","divide","divide_numbers","divisors","divisors_onstack","divpoly","dlog","do_clearPatterns","do_clearall","do_simplify_nested_radicals","dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication","dotprod_unicode","doubleToReasonableString","dpow","dpower","dproduct","draw_flag","draw_stop_return","dsgn","dsin","dsinh","dsum","dtan","dtanh","dupl","eigen","elelmIndex","elem","emit_denominator","emit_denominators","emit_expr","emit_factor","emit_factorial_function","emit_flat_tensor","emit_fraction","emit_function","emit_index_function","emit_multiply","emit_number","emit_numerators","emit_numerical_fraction","emit_power","emit_string","emit_subexpr","emit_symbol","emit_tensor","_emit_tensor_inner","emit_term","emit_top_expr","emit_unsigned_expr","emit_x","equal","equaln","equalq","erfc","errorMessage","esc_flag","evaluatingAsFloats","evaluatingPolar","exec","_expand","expand_get_A","expand_get_AF","expand_get_B","expand_get_C","expand_get_CF","expand_tensor","expanding","expcos","exponential","expr_level","expsin","f1","f10","f2","f3","f4","f5","f9","f_equals_a","factor","factor_a","factor_again","factor_b","factor_number","factor_small_number","factor_term","factorial","factorpoly","factors","factpoly_expo","fill_buf","filter","filter_main","filter_sum","filter_tensor","findDependenciesInScript","_findPossibleClockForm","_findPossibleExponentialForm","findroot","fixup_fraction","fixup_power","flag","floatToRatioRoutine","fmt_index","fmt_level","fmt_x","frame","freeze","functionInvokationsScanningStack","gamma","gamma_of_sum","gammaf","gcd","gcd_main","gcd_numbers","gcd_polys","gcd_powers_with_same_base","gcd_product_product","gcd_product_sum","gcd_sum","gcd_sum_product","gcd_sum_sum","_gen","getSimpleRoots","getStateHash","get_binding","get_factor_from_complex_root","get_factor_from_real_root","_get_innerprod_factors","get_next_token","get_printname","get_size","get_token","getdisplaystr","glyph","gp","guess","hasImaginaryCoeff","hasNegativeRationalExponent","hash_addition","hash_function","hash_multiplication","hash_power","hashcode_values","hashed_itab","hermite","hilbert","i1","imag","imaginaryunit","index_function","init","initNRoots","inited","_inner","inner_f","input_str","integral","integral_of_form","integral_of_product","integral_of_sum","_inv","inverse","invert_number","invg","isNumberOneOverSomething","isNumericAtom","_isNumericAtomOrTensor","isSimpleRoot","isSmall","isSymbolLeftOfAssignment","isSymbolReclaimable","isZeroAtom","isZeroAtomOrTensor","isZeroLikeOrNonZeroLikeOrUndetermined","isZeroTensor","is_denominator","is_factor","is_small_integer","is_square_matrix","is_usr_symbol","isadd","isalnumorunderscore","isalpha","isalphaOrUnderscore","iscomplexnumber","iscomplexnumberdouble","iscons","isdenominator","isdigit","isdouble","iseveninteger","isfactor","isfactorial","_isfloating","isfraction","isidentitymatrix","isimaginarynumber","isimaginarynumberdouble","isimaginaryunit","isinnerordot","isinteger","isintegerfactor","isintegerorintegerfloat","isinv","iskeyword","isminusone","isminusoneoversqrttwo","isminusoneovertwo","ismultiply","isnegative","isnegativenumber","isnegativeterm","isnonnegativeinteger","isnpi","isone","isoneover","isoneoversqrttwo","isoneovertwo","isplusone","isplustwo","ispolyexpandedform","ispolyexpandedform_expr","ispolyexpandedform_factor","ispolyexpandedform_term","ispolyfactoredorexpandedform","ispolyfactoredorexpandedform_factor","ispolyfactoredorexpandedform_power","isposint","ispositivenumber","ispower","isquarterturn","isrational","isspace","isstr","issymbol","_issymbolic","istensor","istranspose","isunderscore","isunivarpolyfactoredorexpandedform","itab","italu_hashcode","j1","laguerre","laguerre2","lastFoundSymbol","latexErrorSign","lcm","leading","legendre","length","lessp","level","list","listLength","logarithm","logbuf","lookupsTotal","lu_decomp","madd","makePositive","makeSignSameAs","make_hashed_itab","mask","mcmp","mcmpint","mdiv","mdivrem","meta_mode","mgcd","mini_solve","mint","mmod","mmul","mod","monic","move","moveTos","mp_clr_bit","mp_denominator","mp_numerator","mp_set_bit","mpow","mprime","mroot","mshiftright","msub","mtotal","_multinomial_sum","multiply","multiply_all","multiply_all_noexpand","multiply_consecutive_constants","multiply_denominators","multiply_denominators_factor","multiply_denominators_term","multiply_noexpand","multiply_numbers","n_factor_number","negate","negate_expand","negate_noexpand","negate_number","new_string","newline_flag","nil_symbols","normaliseDots","normalisedCoeff","normalize_angle","nroots_a","nroots_b","nroots_c","nroots_df","nroots_dx","nroots_fa","nroots_fb","nroots_x","nroots_y","nterms","nthCadr","_numerator","numericRootOfPolynomial","o","one","oneElement","one_as_double","out_buf","out_count","out_of_memory","outer","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","parse","parse_internal","parse_p1","parse_p2","parse_time_simplifications","partition","patternHasBeenFound","patternsinfo","peek","performing_roots","polar","_polarRectAMinusOneBase","polycoeff","_polyform","pop","pop_double","pop_frame","pop_integer","power","power_str","power_sum","power_tensor","predefinedSymbolsInGlobalScope_doNotTrackInDependencies","prime","primetab","print2dascii","printMode","print_ABS_latex","print_ARCCOS_codegen","print_ARCSIN_codegen","print_ARCTAN_codegen","print_BINOMIAL_latex","print_COS_codegen","print_DEFINT_latex","print_DOT_codegen","print_DOT_latex","print_DO_codegen","print_FOR_codegen","print_INV_codegen","print_INV_latex","print_PRODUCT_codegen","print_PRODUCT_latex","print_SETQ_codegen","print_SIN_codegen","print_SQRT_latex","print_SUM_codegen","print_SUM_latex","print_TAN_codegen","print_TESTEQ_latex","print_TESTGE_latex","print_TESTGT_latex","print_TESTLE_latex","print_TESTLT_latex","print_TEST_codegen","print_TEST_latex","print_TRANSPOSE_codegen","print_TRANSPOSE_latex","print_UNIT_codegen","print_a_over_b","print_base","print_base_of_denom","print_char","print_denom","print_double","print_expo_of_denom","print_exponent","print_expr","_print_factor","print_factorial_function","print_glyphs","print_index_function","_print_list","print_multiply_sign","print_number","_print_power","print_str","print_subexpr","print_tensor","_print_tensor_inner","_print_tensor_inner_latex","print_tensor_latex","print_term","printchar","printchar_nowrap","printline","program_buf","promote_tensor","push","pushTryNotToDuplicate","push_cars","push_double","push_factor","push_frame","push_identity_matrix","push_integer","push_rational","push_symbol","push_term_factors","push_terms","push_zero_matrix","qadd","qdiv","qmul","qpow","qpowf","quickfactor","quickpower","rational","rationalize","rationalize_coefficients","real","reciprocate","_rect","recursionLevelNestedRadicalsRemoval","_recursiveDependencies","ref","ref1","rememberPrint","remove_negative_exponents","reset_after_error","restore","restoreMetaBindings","_rewrite_args","rewrite_args_tensor","roots","roots2","roots3","run","runUserDefinedSimplifications","save","saveMetaBindings","scalar_times_tensor","scan","scan_error","scan_expression","scan_factor","scan_function_call_with_function_name","scan_function_call_without_function_name","scan_index","scan_meta","scan_power","scan_relation","scan_stmt","scan_str","scan_string","scan_subexpr","scan_symbol","scan_tensor","scan_term","scanned","scanningParameters","setM","setSignTo","set_binding","set_component","setq_indexed","sfac_product","sfac_product_f","sgn","shape","show_power_debug","sign","sign_of_term","simfac","simfac_term","simpleComplexityMeasure","simplify","simplifyForCodeGeneration","simplify_1_in_products","simplify_main","simplify_nested_radicals","simplify_polar","simplify_polarRect","simplify_rational_expressions","simplify_rectToClock","simplify_tensor","simplify_trig","_simplifyfactorials","sine","sine_of_angle","sine_of_angle_sum","skipRootVariableToBeSolved","sort_stack","square","ssqrt","stack","stackAddsCount","std_symbol","step","step2","stop","strcmp","stringsEmittedByUserPrintouts","subf","_subst","subtract","subtract_numbers","swap","symbol","symbolsDependencies","symbolsHavingReassignments","symbolsInExpressionsWithoutAssignments","symbolsLeftOfAssignment","symbolsRightOfAssignment","symbolsinfo","symnum","symtab","_take_care_of_nested_radicals","tangent","taylor","tensor","tensor_plus_tensor","tensor_times_scalar","testApprox","test_flag","text_metric","theRandom","token","token_buf","token_str","top","top_level_eval","tos","_transform","_transpose","transpose_unicode","trigmode","trivial_divide","try_kth_prime","turnErrorMessageToLatex","ucmp","unfreeze","unique","_unique_f","update_token_buf","userSimplificationsInListForm","userSimplificationsInStringForm","usr_symbol","verbosing","version","will_be_displayed_as_fraction","ybinomial","ycosh","ydirac","yerf","yerfc","yfloor","yindex","yround","ysinh","yyarg","yybesselj","yybessely","yyceiling","yycondense","yycontract","yycosh","_yydegree","yydetg","yydivpoly","yyerf","yyerfc","yyexpand","yyfactorpoly","_yyfloat","yyfloor","yyhermite","yyhermite2","yyinvg","yylcm","yylog","yymultiply","yyouter","yypower","yyrationalize","yyround","yysgn","yysimfac","yysinh","yytangent","zero","zzfloat","hasProp","hasOwnProperty","slice","prototype","a","b","this","q","printname","str","d","k","tag","toString","toLatexString","dim","results","ndim","nelem","h","w","n","ascent","descent","width","ceil","i","j","primes","Math","sqrt","x","p","startCount","isPositive","isZero","equals","exports","theArgument","console","trace","log","anyFactorsYet","input","subsetOfStack","sort","concat","t","s","l1","m1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","numberOfDigitsAfterTheDot","precision","splitBeforeAndAfterDot","supposedlyTheFloat","theFloat","theRatio","split","pow","decimal","AccuracyFactor","DecimalSign","FractionDenominator","FractionNumerator","PreviousDenominator","ScratchValue","Z","ret","isNaN","floor","bestResultSoFar","complexity","error","hypothesis","len","likelyMultiplier","minimumComplexity","ratio","Number","MAX_VALUE","round","len1","approxRadicalsOfRationalsResult","approxRationalsOfRadicalsResult","approxLogsOfRationalsResult","approxRationalsOfLogsResult","approxSineOfRationalMultiplesOfPIResult","approxSineOfRationalsResult","fraction","sin","approxLogsResult","approxRadicalsResult","approxRationalsOfPowersOfEResult","approxRationalsOfPowersOfPIResult","approxTrigonometricResult","bestApproxSoFar","constantsSum","constantsSumMin","aResult","c","theSum","Array","i2","i3","j2","j3","k3","l2","l3","len2","len3","len4","len5","len6","len7","m2","m3","n1","n2","o1","o2","originalValue","q1","q2","r1","r2","returned","returnedFraction","returnedValue","s1","s2","t1","t2","u1","u2","v1","v2","value","x1","x2","z1","z2","toFixed","acos","asin","atan","y","z","jn","yn","geq","MIN_SAFE_INTEGER","leq","MAX_SAFE_INTEGER","isNegative","qsub","ab","ba","minusOne","expo","toJSNumber","quotientAndRemainder","divmod","quotient","remainder","accumulator","buf","scounter","sign_","substring","parseFloat","signed","aAsString","denominatorString","shiftRight","indexOf","indexFound","variableToBeCleared","prev_expanding","row","col","ai","an","l","m","cos","cosh","toBePushed","generalTransform","breakFromOutherWhile","base","result","theta","op","ref10","printstr","ref11","results1","count","cc","ss","ans","exp","willEvaluateAsFloats","cycleString","positionIfSymbolAlreadyBeingEvaluated","cons_head","Eval_atomize","Eval_draw","checkResult","dsolve","orig","theTensor","checkingTheDivision","dividend","foundComplexRoot","foundRealRoot","previousFactorisation","remainingPoly","whichRootsAreWeFinding","a0","na0","nan","rootsTries_i","rootsTries_j","nodeToCheck","numberOfEs","numberOfMults","numberOfPIs","numberOfPowers","numberOfSums","loopingVariable","polyVar","difference","moretheArguments","operands","refinedOperands","shift","theArguments","arg1","arg2","arg3","subtractionResult","ak","bk","tree","factors_accumulator","hc","tab","u","half","constant","arg_hash","name","Error","terms","sum","term","term_set","call","product","base_hash","exp_hash","constexp","f","key","JSON","stringify","eachEntry","results2","valueOrPredicate","evalledArgument","isEven","minussign","issymbolic","isfloating","compareAbs","v","toReturn","isProbablePrime","index","and","shiftLeft","not","or","append","_gamma","r","random","nrabs","firstArgument","patternPosition","secondArgument","stringKey","thirdArgument","patternsinfoToBePrinted","compare","bigint_one","g","xprime","b_isEven_and_c_isItsInverse","hopefullySimplified","inputBase","inputExp","isThisOne","is_a_moreThanZero","original_test_flag","beenPrinted","passedPrintMode","origPrintMode","theString","theTypeOfPrint","parsedString","originalCodeGen","returnedString","replace","denom","numberOneOverSomething","origAccumulator","previousFactorWasANumber","functionBody","numberOfIntegrals","originalIntegral","theIntegral","theVariable","firstLevel","body","lowerlimit","upperlimit","variable","howManyIfs","exponent","denomExponent","newExponent","numExponent","omitParens","fbody","parameters","character","k1","k2","pPrintName","pString","dx","h1","w1","w2","y1","y2","dy","h2","max_x","max_y","min_x","min_y","emit_sign","tmpString","sIndex","tmpBuffer","eh","ew","ncol","nrow","indexVariable","oldIndexVariableValue","gcdBetweenNumeratorAndDenominator","qadd_ab","qadd_ba","qadd_denominator","qadd_frac1","qadd_frac2","qadd_numerator","resultSum","aa","bb","isOdd","stackIndex","divisor","commonDenominator","eachTerm","printf","imaginaryCoefficients","isSimpleRootPolynomial","divideBy","miniStack","lastCoeff","leadingCoeff","aSol","commonPart","rootsOfOne","C_CHECKED_AS_NOT_ZERO","R_18_a_b_c_d","R_27_a2_d","R_2_b3","R_3_a","R_3_a_C","R_3_a_c","R_4_DELTA03","R_6_a_C","R_C","R_C_over_3a","R_C_simplified_toCheckIfZero","R_DELTA0","R_DELTA0_toBeCheckedIfZero","R_DELTA1","R_Q","R_a2","R_a2_d","R_a2_d2","R_a3","R_a_b_c","R_a_b_c_d","R_a_c","R_b2","R_b2_c2","R_b3","R_b3_d","R_c2","R_c3","R_d2","R_determinant","R_e2","R_e3","R_m","R_m27_a2_d2","R_m4_a_c3","R_m4_b3_d","R_m9_a_b_c","R_m_b_over_3a","R_p","R_q","R_r","ThreePPlus2M","TwoQOversqrtPPlus2M","coeff2","coeff3","coeff4","depressedSolutions","eachSolution","flipSignOFQSoCIsNotZero","i_sqrt3","one_minus_i_sqrt3","one_plus_i_sqrt3","resolventCubicSolutions","root_solution","sqrtPPlus2M","toBeCheckedIFZero","assignmentIsOfQuotedType","existingDependencies","indexOfSymbolLeftOfAssignment","symbolLeftOfAssignment","splice","charCodeAt","firstFactorIsNumber","theSymbol","prefixVar","functionName","RegExp","test","errmsg","atLeastOneSuccessInRouldOfRulesApplications","eachConsecutiveRuleApplication","eachSimplification","numberOfRulesApplications","originalexpanding","success","args","eval","carp1","oldp1","oldp2","num","theGCD","simplificationWithCondense","simplificationWithoutCondense","somethingSimplified","A","B","C","SOLUTION","anyRadicalSimplificationWorked","checkSize","commonBases","commonInnerExponent","countingTerms","firstTerm","innerbase","innerexponent","lowercase_a","lowercase_b","numberOfTerms","possibleNewExpression","possibleNewExpressionValue","possibleRationalSolutions","possibleSolutions","potentialPower","realOfpossibleRationalSolutions","secondTerm","secondTermFactor","termsThatAreNotPowers","max","apply","sinh","tan","tanh","comparison","wholeAndExpression","andPredicates","somePredicateUnknown","orPredicates","wholeOrExpression","bookmarkTosToPrintDecomps","eachTransformEntry","numberOfDecomps","restTerm","theTransform","transform_h","transformationSuccessful","transformedTerms","fea_i","fea_j","innerTranspSwitch1","innerTranspSwitch2","bodyAndFormalArguments","Find","definitionOfInterest","defn_i","str1","str2","maxFixedPrintoutDigits","stringRepresentation","search","needle","message","stringToBeParsed","dontGenerateCode","bodyForReadableSummaryOfGeneratedCode","cyclesDescriptions","deQuotedDep","dependencyInfo","eachDependency","generatedBody","generatedCode","indexOfEachReplacement","indexOfPartRemainingToBeParsed","newUserSymbol","originalUserSymbol","readableSummaryOfGeneratedCode","recursedDependencies","replacementsFrom","replacementsTo","scriptEvaluation","stringToBeRun","testableString","timeStartFromAlgebra","toBePrinted","userVariablesMentioned","variablesWithCycles","Date","getTime","affectsVariables","affectedBy","error1","variableToBeChecked","arrayWhereDependenciesWillBeAdded","variablesAlreadyFleshedOut","chainBeingChecked","cyclesDescription","theErrorMessage","String","fromCharCode","stringToNormalise","generateLatex","allReturnedLatexStrings","allReturnedPlainStrings","collectedLatexResult","collectedPlainResult","stringToBeReturned","timeStart","timingDebugWrite","selftest","originalArgument","shouldAutoexpand","codeFromAlgebraBlock","code","latexResult","readableSummaryOfCode","stackPos","elementToBeReturned","symbolsinfoToBePrinted","bindingi","symtabi","latexPrint","theSymnum","collectUserSymbols","argu","warn","data","argus","fn","arguments","builtin_fns","bind","frozenContents","frozenSymbols","frozen","frozenPatterns","previousHash","frozenHash"],"mappings":"4GACA,WACE,IAAIA,EACAC,IACAC,IACAC,IACAC,IACAC,YACAC,OACAC,QACAC,OACAC,QACAC,OACAC,QACAC,IACAC,sBACAC,QACAC,WACAC,KACAC,QACAC,QACAC,QACAC,SACAC,iBACAC,IACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,QACAC,MACAC,OACAC,QACAC,MACAC,SACAC,cACAC,MACAC,MACAC,SACAC,SACAC,KACAC,KACAC,SACAC,IACAC,KACAC,SACAC,MACAC,UACAC,UACAC,gBACAC,WACAC,SACAC,YACAC,WACAC,OACAC,OACAC,OACAC,YACAC,WACAC,IACAC,cACAC,IACAC,MACAC,SACAC,GACAC,IACAC,OACAC,KACAC,MACAC,OACAC,EACAC,MACAC,SACAC,SACAC,MACAC,cACAC,SACAC,SACAC,IACAC,KACAC,KACAC,IACAC,OACAC,OACAC,OACAC,KACAC,UACAC,SACAC,SACAC,SACAC,SACAC,iBACAC,YACAC,aACAC,YACAC,aACAC,YACAC,aACAC,SACAC,aACAC,aACAC,aACAC,cACAC,aACAC,WACAC,YACAC,aACAC,WACAC,cACAC,mBACAC,WACAC,WACAC,cACAC,cACAC,UACAC,UACAC,cACAC,SACAC,UACAC,YACAC,YACAC,YACAC,iBACAC,gBACAC,SACAC,SACAC,WACAC,cACAC,QACAC,YACAC,WACAC,cACAC,cACAC,SACAC,UACAC,SACAC,YACAC,YACAC,YACAC,YACAC,eACAC,gBACAC,YACAC,WACAC,WACAC,SACAC,wBACAC,WACAC,SACAC,aACAC,aACAC,UACAC,WACAC,YACAC,cACAC,SACAC,UACAC,eACAC,aACAC,cACAC,SACAC,aACAC,cACAC,SACAC,YACAC,SACAC,cACAC,cACAC,SACAC,YACAC,YACAC,eACAC,cACAC,QACAC,WACAC,aACAC,kBACAC,WACAC,WACAC,eACAC,WACAC,WACAC,kBACAC,mBACAC,gBACAC,gBACAC,eACAC,aACAC,WACAC,cACAC,UACAC,iBACAC,UACAC,UACAC,WACAC,WACAC,UACAC,SACAC,WACAC,mBACAC,YACAC,cACAC,SACAC,UACAC,UACAC,UACAC,WACAC,SACAC,SACAC,iBACAC,SACAC,UACAC,YACAC,YACAC,UACAC,YACAC,YACAC,YACAC,YACAC,YACAC,eACAC,UACAC,mBACAC,UACAC,SACAC,OACAC,UACAC,WACAC,OACAC,OACAC,MACAC,IACAC,qBACAC,SACAC,MACAC,MACAC,IACAC,QACAC,QACAC,KACAC,MACAC,MACAC,SACAC,IACAC,KACAC,cACAC,WACAC,UACAC,QACAC,SACAC,KACAC,mBACAC,gBACAC,iBACAC,gBACAC,iBACAC,WACAC,IACAC,QACAC,SACAC,IACAC,OACAC,EACAC,OACAC,YACAC,0CACAC,4CACAC,0BACAC,iBACAC,OACAC,MACAC,MACAC,MACAC,QACAC,IACAC,MACAC,SACAC,MACAC,EACAC,IACAC,IACAC,OACAC,WACAC,aACAC,eACAC,cACAC,YACAC,eACAC,KACAC,IACAC,OACAC,UACAC,SACAC,GACAC,MACAC,QACAC,aACAC,GACAC,MACAC,MACAC,MACAC,MACAC,aACAC,UACAC,WACAC,UACAC,kBACAC,mBACAC,gBACAC,gBACAC,eACAC,eACAC,WACAC,oBACAC,oBACAC,QACAC,MACAC,SACAC,KACAC,YACAC,KACAC,MACAC,MACAC,QACAC,SACAC,KACAC,IACAC,MACAC,cACAC,SACAC,IACAC,KACAC,sBACAC,mBACAC,KACAC,KACAC,IACAC,MACAC,IACAC,IACAC,YACAC,SACAC,oBACAC,SACAC,oBACAC,SACAC,SACAC,SACAC,uBACAC,SACAC,SACAC,SACAC,SACAC,SACAC,SACAC,oBACAC,SACAC,SACAC,IACAC,KACAC,OACAC,OACAC,KACAC,OACAC,OACAC,OACAC,OACAC,OACAC,cACAC,IACAC,MACAC,UACAC,SACAC,KACAC,WACAC,OACAC,UACAC,OACAC,MACAC,UACAC,aACAC,SACAC,SACAC,EACAC,KACAC,YACAC,QACAC,KACAC,IACAC,OACAC,KACAC,YACAC,WACAC,aACAC,YACAC,cACAC,oBACAC,MACAC,WACAC,YACAC,YACAC,4BACAC,qBACAC,OACAC,IACAC,YACAC,QACAC,cACAC,IACAC,0BACAC,2BACAC,QACAC,0BACAC,YACAC,UACAC,KACAC,IACAC,aACAC,YACAC,iBACAC,UACAC,WACAC,sBACAC,mBACAC,eACAC,0BACAC,sBACAC,2BACAC,4BACAC,0BACAC,kCACAC,sBACAC,oBACAC,uBACAC,6BACAC,qBACAC,sBACAC,sBACAC,mBACAC,oBACAC,6BACAC,iCACAC,wBACAC,sBACAC,OACAC,QACAC,OACAC,QACAC,QACAC,QACAC,qCACAC,IACAC,QACAC,gBACAC,kCACAC,MACAC,UACAC,eACAC,QACAC,QACAC,OACAC,iBACAC,aACAC,oBACAC,kBACAC,oBACAC,gBACAC,QACAC,SACAC,OACAC,aACAC,OACAC,MACAC,KACAC,QACAC,OACAC,MACAC,SACAC,QACAC,OACAC,QACAC,OACAC,MACAC,KACAC,0BACAC,IACAC,OACAC,MACAC,KACAC,QACAC,MACAC,SACAC,OACAC,MACAC,KACAC,IACAC,QACAC,6CACAC,aACAC,QACAC,iCACAC,eACAC,YACAC,wBACAC,OACAC,kBACAC,SACAC,wBACAC,mDACAC,cACAC,WACAC,SACAC,UACAC,UACAC,SACAC,UACAC,UACAC,gBACAC,QACAC,MACAC,SACAC,kCACAC,oBACAC,gBACAC,eACAC,cACAC,aACAC,gBACAC,kBACAC,gBACAC,WACAC,+BACAC,uCACAC,WACAC,UACAC,KACAC,UACAC,SACAC,yBACAC,2BACAC,YACAC,OACAC,gBACAC,oBACAC,OACAC,0BACAC,mBACAC,QACAC,UACAC,gBACAC,kBACAC,gBACAC,gBACAC,gBACAC,KACAC,QACAC,SACAC,QACAC,SACAC,QACAC,SACAC,UACAC,UACAC,UACAC,UACAC,KACAC,MACAC,GACAC,QACAC,eACAC,WACAC,yBACAC,qBACAC,KACAC,SACAC,OACAC,aACAC,KACAC,MACAC,WACAC,uBACAC,IACAC,YACAC,KACAC,UACAC,SACAC,MACAC,QACAC,aACAC,YACAC,OACAC,eACAC,SACAC,iBACAC,QACAC,KACAC,iBACAC,YACAC,4BACAC,4DACAC,gBACAC,yBACAC,KACAC,OACAC,SACAC,UACAC,iBACAC,KACAC,KACAC,MACAC,KACAC,KACAC,MACAC,KACAC,MACAC,WACAC,KACAC,iBACAC,kBACAC,UACAC,YACAC,wBACAC,iBACAC,cACAC,cACAC,oBACAC,cACAC,YACAC,gBACAC,wBACAC,WACAC,YACAC,aACAC,YACAC,YACAC,mBACAC,UACAC,cACAC,mBACAC,OACAC,MACAC,OACAC,OACAC,KACAC,aACAC,SACAC,mBACAC,gBACAC,KACAC,QACAC,aACAC,cACAC,aACAC,aACAC,cACAC,cACAC,UACAC,OACAC,YACAC,WACAC,OACAC,GACAC,IACAC,GACAC,GACAC,GACAC,GACAC,GACAC,WACAC,OACAC,SACAC,aACAC,SACAC,cACAC,oBACAC,YACAC,UACAC,WACAC,QACAC,cACAC,SACAC,OACAC,YACAC,WACAC,cACAC,yBACAC,uBACAC,6BACAC,SACAC,eACAC,YACAC,KACAC,oBACAC,UACAC,UACAC,MACAC,MACAC,OACAC,iCACAC,MACAC,aACAC,OACAC,IACAC,SACAC,YACAC,UACAC,0BACAC,oBACAC,gBACAC,QACAC,gBACAC,YACAC,KACAC,eACAC,aACAC,YACAC,6BACAC,0BACAC,uBACAC,eACAC,cACAC,SACAC,UACAC,cACAC,MACAC,GACAC,MACAC,kBACAC,4BACAC,cACAC,cACAC,oBACAC,WACAC,gBACAC,YACAC,QACAC,QACAC,GACAC,KACAC,cACAC,eACAC,KACAC,WACAC,OACAC,OACAC,QACAC,UACAC,SACAC,iBACAC,oBACAC,gBACAC,KACAC,QACAC,cACAC,KACAC,yBACAC,cACAC,uBACAC,aACAC,QACAC,yBACAC,oBACAC,WACAC,mBACAC,sCACAC,aACAC,eACAC,UACAC,iBACAC,iBACAC,cACAC,MACAC,oBACAC,QACAC,oBACAC,gBACAC,sBACAC,OACAC,cACAC,QACAC,SACAC,cACAC,SACAC,YACAC,YACAC,WACAC,iBACAC,kBACAC,wBACAC,gBACAC,aACAC,UACAC,gBACAC,wBACAC,MACAC,UACAC,WACAC,sBACAC,kBACAC,WACAC,WACAC,iBACAC,eACAC,qBACAC,MACAC,MACAC,UACAC,iBACAC,aACAC,UACAC,UACAC,mBACAC,wBACAC,0BACAC,wBACAC,6BACAC,oCACAC,mCACAC,SACAC,iBACAC,QACAC,cACAC,WACAC,QACAC,MACAC,SACAC,YACAC,SACAC,YACAC,aACAC,mCACAC,KACAC,eACAC,GACAC,SACAC,UACAC,gBACAC,eACAC,IACAC,QACAC,SACAC,OACAC,MACAC,MACAC,KACAC,WACAC,UACAC,OACAC,aACAC,UACAC,KACAC,aACAC,eACAC,iBACAC,KACAC,KACAC,QACAC,KACAC,QACAC,UACAC,KACAC,WACAC,KACAC,KACAC,KACAC,IACAC,MACAC,KACAC,QACAC,WACAC,eACAC,aACAC,WACAC,KACAC,OACAC,MACAC,YACAC,KACAC,OACAC,iBACAC,SACAC,aACAC,sBACAC,+BACAC,sBACAC,6BACAC,2BACAC,kBACAC,iBACAC,gBACAC,OACAC,cACAC,gBACAC,cACAC,WACAC,aACAC,YACAC,cACAC,gBACAC,gBACAC,SACAC,SACAC,SACAC,UACAC,UACAC,UACAC,UACAC,SACAC,SACAC,OACAC,QACAC,WACAC,wBACAC,EACAC,IACAC,WACAC,cACAC,QACAC,UACAC,cACAC,MACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,MACAC,eACAC,SACAC,SACAC,2BACAC,UACAC,oBACAC,aACAC,KACAC,iBACAC,MACAC,wBACAC,UACAC,UACAC,IACAC,WACAC,UACAC,YACAC,MACAC,UACAC,UACAC,aACAC,wDACAC,MACAC,SACAC,aACAC,UACAC,gBACAC,qBACAC,qBACAC,qBACAC,qBACAC,kBACAC,mBACAC,kBACAC,gBACAC,iBACAC,kBACAC,kBACAC,gBACAC,sBACAC,oBACAC,mBACAC,kBACAC,iBACAC,kBACAC,gBACAC,kBACAC,mBACAC,mBACAC,mBACAC,mBACAC,mBACAC,mBACAC,iBACAC,wBACAC,sBACAC,mBACAC,eACAC,WACAC,oBACAC,WACAC,YACAC,aACAC,oBACAC,eACAC,WACAC,cACAC,yBACAC,aACAC,qBACAC,YACAC,oBACAC,aACAC,aACAC,UACAC,cACAC,aACAC,oBACAC,0BACAC,mBACAC,WACAC,UACAC,iBACAC,UACAC,YACAC,eACAC,KACAC,sBACAC,UACAC,YACAC,YACAC,WACAC,qBACAC,aACAC,cACAC,YACAC,kBACAC,WACAC,iBACAC,KACAC,KACAC,KACAC,KACAC,MACAC,YACAC,WACAC,SACAC,YACAC,yBACAC,KACAC,YACAC,MACAC,oCACAC,uBACAC,IACAC,KACAC,cACAC,0BACAC,kBACAC,QACAC,oBACAC,cACAC,oBACAC,MACAC,OACAC,OACAC,IACAC,8BACAC,KACAC,iBACAC,oBACAC,KACAC,WACAC,gBACAC,YACAC,sCACAC,yCACAC,WACAC,UACAC,WACAC,cACAC,UACAC,SACAC,YACAC,aACAC,YACAC,YACAC,UACAC,QACAC,mBACAC,KACAC,UACAC,YACAC,cACAC,aACAC,aACAC,eACAC,IACAC,MACAC,iBACAC,KACAC,aACAC,OACAC,YACAC,wBACAC,SACAC,0BACAC,uBACAC,cACAC,yBACAC,eACAC,mBACAC,8BACAC,qBACAC,gBACAC,cACAC,oBACAC,KACAC,cACAC,kBACAC,2BACAC,WACAC,OACAC,MACAC,MACAC,eACAC,WACAC,KACAC,MACAC,KACAC,OACAC,8BACAC,KACAC,OACAC,SACAC,iBACAC,KACAC,OACAC,oBACAC,2BACAC,uCACAC,wBACAC,yBACAC,YACAC,OACAC,OACAC,8BACAC,QACAC,OACAC,OACAC,mBACAC,oBACAC,WACAC,UACAC,YACAC,UACAC,MACAC,UACAC,UACAC,I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","file":"3f880679-700e7902129e4cc92549.js","sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function () {\n  var $,\n      ABS,\n      ADD,\n      ADJ,\n      AND,\n      APPROXRATIO,\n      ARCCOS,\n      ARCCOSH,\n      ARCSIN,\n      ARCSINH,\n      ARCTAN,\n      ARCTANH,\n      ARG,\n      ASSUME_REAL_VARIABLES,\n      ATOMIZE,\n      AUTOEXPAND,\n      BAKE,\n      BESSELJ,\n      BESSELY,\n      BINDING,\n      BINOMIAL,\n      BINOM_check_args,\n      BUF,\n      C1,\n      C2,\n      C3,\n      C4,\n      C5,\n      C6,\n      CEILING,\n      CHECK,\n      CHOOSE,\n      CIRCEXP,\n      CLEAR,\n      CLEARALL,\n      CLEARPATTERNS,\n      CLOCK,\n      COEFF,\n      COFACTOR,\n      CONDENSE,\n      CONJ,\n      CONS,\n      CONTRACT,\n      COS,\n      COSH,\n      Condense,\n      DEBUG,\n      DEBUG_ABS,\n      DEBUG_ARG,\n      DEBUG_CLOCKFORM,\n      DEBUG_IMAG,\n      DEBUG_IS,\n      DEBUG_POWER,\n      DEBUG_RECT,\n      DECOMP,\n      DEFINT,\n      DEGREE,\n      DENOMINATOR,\n      DERIVATIVE,\n      DET,\n      DET_check_arg,\n      DIM,\n      DIRAC,\n      DIVISORS,\n      DO,\n      DOT,\n      DOUBLE,\n      DRAW,\n      DRAWX,\n      DSOLVE,\n      E,\n      EIGEN,\n      EIGENVAL,\n      EIGENVEC,\n      EIG_N,\n      EIG_check_arg,\n      EIG_yydd,\n      EIG_yyqq,\n      ERF,\n      ERFC,\n      EVAL,\n      EXP,\n      EXPAND,\n      EXPCOS,\n      EXPSIN,\n      Eval,\n      Eval_Eval,\n      Eval_abs,\n      Eval_add,\n      Eval_adj,\n      Eval_and,\n      Eval_approxratio,\n      Eval_arccos,\n      Eval_arccosh,\n      Eval_arcsin,\n      Eval_arcsinh,\n      Eval_arctan,\n      Eval_arctanh,\n      Eval_arg,\n      Eval_besselj,\n      Eval_bessely,\n      Eval_binding,\n      Eval_binomial,\n      Eval_ceiling,\n      Eval_check,\n      Eval_choose,\n      Eval_circexp,\n      Eval_clear,\n      Eval_clearall,\n      Eval_clearpatterns,\n      Eval_clock,\n      Eval_coeff,\n      Eval_cofactor,\n      Eval_condense,\n      Eval_conj,\n      Eval_cons,\n      Eval_contract,\n      Eval_cos,\n      Eval_cosh,\n      Eval_decomp,\n      Eval_defint,\n      Eval_degree,\n      Eval_denominator,\n      Eval_derivative,\n      Eval_det,\n      Eval_dim,\n      Eval_dirac,\n      Eval_divisors,\n      Eval_do,\n      Eval_dsolve,\n      Eval_eigen,\n      Eval_eigenval,\n      Eval_eigenvec,\n      Eval_erf,\n      Eval_erfc,\n      Eval_exp,\n      Eval_expand,\n      Eval_expcos,\n      Eval_expsin,\n      Eval_factor,\n      Eval_factorial,\n      Eval_factorpoly,\n      Eval_filter,\n      Eval_float,\n      Eval_floor,\n      Eval_for,\n      Eval_function_reference,\n      Eval_gamma,\n      Eval_gcd,\n      Eval_hermite,\n      Eval_hilbert,\n      Eval_imag,\n      Eval_index,\n      _Eval_inner,\n      Eval_integral,\n      Eval_inv,\n      Eval_invg,\n      Eval_isinteger,\n      Eval_isprime,\n      Eval_laguerre,\n      Eval_lcm,\n      Eval_leading,\n      Eval_legendre,\n      Eval_log,\n      Eval_lookup,\n      Eval_mod,\n      Eval_multiply,\n      Eval_noexpand,\n      Eval_not,\n      Eval_nroots,\n      Eval_number,\n      Eval_numerator,\n      Eval_operator,\n      Eval_or,\n      Eval_outer,\n      Eval_pattern,\n      Eval_patternsinfo,\n      Eval_polar,\n      Eval_power,\n      Eval_predicate,\n      Eval_prime,\n      Eval_print,\n      Eval_print2dascii,\n      Eval_printcomputer,\n      Eval_printhuman,\n      Eval_printlatex,\n      Eval_printlist,\n      Eval_product,\n      Eval_quote,\n      Eval_quotient,\n      Eval_rank,\n      Eval_rationalize,\n      Eval_real,\n      Eval_rect,\n      Eval_roots,\n      Eval_round,\n      Eval_setq,\n      Eval_sgn,\n      Eval_shape,\n      Eval_silentpattern,\n      Eval_simfac,\n      Eval_simplify,\n      Eval_sin,\n      Eval_sinh,\n      Eval_sqrt,\n      Eval_stop,\n      Eval_subst,\n      Eval_sum,\n      Eval_sym,\n      Eval_symbolsinfo,\n      Eval_tan,\n      Eval_tanh,\n      Eval_taylor,\n      Eval_tensor,\n      Eval_test,\n      Eval_testeq,\n      Eval_testge,\n      Eval_testgt,\n      Eval_testle,\n      Eval_testlt,\n      Eval_transpose,\n      Eval_unit,\n      Eval_user_function,\n      Eval_zero,\n      Evalpoly,\n      FACTOR,\n      FACTORIAL,\n      FACTORPOLY,\n      FILTER,\n      FLOATF,\n      FLOOR,\n      FOR,\n      FORCE_FIXED_PRINTOUT,\n      FUNCTION,\n      _Find,\n      GAMMA,\n      GCD,\n      HERMITE,\n      HILBERT,\n      IMAG,\n      INDEX,\n      INNER,\n      INTEGRAL,\n      INV,\n      INVG,\n      INV_check_arg,\n      INV_decomp,\n      ISINTEGER,\n      ISPRIME,\n      LAGUERRE,\n      LAST,\n      LAST_2DASCII_PRINT,\n      LAST_FULL_PRINT,\n      LAST_LATEX_PRINT,\n      LAST_LIST_PRINT,\n      LAST_PLAIN_PRINT,\n      LAST_PRINT,\n      LCM,\n      LEADING,\n      LEGENDRE,\n      LOG,\n      LOOKUP,\n      M,\n      MAXDIM,\n      MAXPRIMETAB,\n      MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES,\n      MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE,\n      MAX_FIXED_PRINTOUT_DIGITS,\n      MAX_PROGRAM_SIZE,\n      MEQUAL,\n      METAA,\n      METAB,\n      METAX,\n      MLENGTH,\n      MOD,\n      MSIGN,\n      MULTIPLY,\n      MZERO,\n      N,\n      NIL,\n      NOT,\n      NROOTS,\n      NROOTS_ABS,\n      NROOTS_DELTA,\n      NROOTS_EPSILON,\n      NROOTS_RANDOM,\n      NROOTS_YMAX,\n      NROOTS_divpoly,\n      NSYM,\n      NUM,\n      NUMBER,\n      NUMERATOR,\n      OPERATOR,\n      OR,\n      OUTER,\n      PATTERN,\n      PATTERNSINFO,\n      PI,\n      POLAR,\n      POWER,\n      PRIME,\n      PRINT,\n      PRINT2DASCII,\n      PRINTFULL,\n      PRINTLATEX,\n      PRINTLIST,\n      PRINTMODE_2DASCII,\n      PRINTMODE_COMPUTER,\n      PRINTMODE_HUMAN,\n      PRINTMODE_LATEX,\n      PRINTMODE_LIST,\n      PRINTOUTRESULT,\n      PRINTPLAIN,\n      PRINT_LEAVE_E_ALONE,\n      PRINT_LEAVE_X_ALONE,\n      PRODUCT,\n      QUOTE,\n      QUOTIENT,\n      RANK,\n      RATIONALIZE,\n      REAL,\n      ROOTS,\n      ROUND,\n      SECRETX,\n      SELFTEST,\n      SETQ,\n      SGN,\n      SHAPE,\n      SILENTPATTERN,\n      SIMPLIFY,\n      SIN,\n      SINH,\n      SPACE_BETWEEN_COLUMNS,\n      SPACE_BETWEEN_ROWS,\n      SQRT,\n      STOP,\n      STR,\n      SUBST,\n      SUM,\n      SYM,\n      SYMBOLSINFO,\n      SYMBOL_A,\n      SYMBOL_A_UNDERSCORE,\n      SYMBOL_B,\n      SYMBOL_B_UNDERSCORE,\n      SYMBOL_C,\n      SYMBOL_D,\n      SYMBOL_I,\n      SYMBOL_IDENTITY_MATRIX,\n      SYMBOL_J,\n      SYMBOL_N,\n      SYMBOL_R,\n      SYMBOL_S,\n      SYMBOL_T,\n      SYMBOL_X,\n      SYMBOL_X_UNDERSCORE,\n      SYMBOL_Y,\n      SYMBOL_Z,\n      TAN,\n      TANH,\n      TAYLOR,\n      TENSOR,\n      TEST,\n      TESTEQ,\n      TESTGE,\n      TESTGT,\n      TESTLE,\n      TESTLT,\n      TIMING_DEBUGS,\n      TOS,\n      TRACE,\n      TRANSPOSE,\n      T_DOUBLE,\n      T_EQ,\n      T_FUNCTION,\n      T_GTEQ,\n      T_INTEGER,\n      T_LTEQ,\n      T_NEQ,\n      T_NEWLINE,\n      T_QUOTASSIGN,\n      T_STRING,\n      T_SYMBOL,\n      U,\n      UNIT,\n      USR_SYMBOLS,\n      VERSION,\n      YMAX,\n      YYE,\n      YYRECT,\n      ZERO,\n      __emit_char,\n      __emit_str,\n      __factor_add,\n      __factorial,\n      __is_negative,\n      __is_radical_number,\n      __lcm,\n      __legendre,\n      __legendre2,\n      __legendre3,\n      __normalize_radical_factors,\n      __rationalize_tensor,\n      _print,\n      abs,\n      absValFloat,\n      _absval,\n      absval_tensor,\n      add,\n      addSymbolLeftOfAssignment,\n      addSymbolRightOfAssignment,\n      add_all,\n      add_factor_to_accumulator,\n      add_numbers,\n      add_terms,\n      addf,\n      adj,\n      alloc_tensor,\n      allocatedId,\n      any_denominators,\n      approxAll,\n      approxLogs,\n      approxLogsOfRationals,\n      approxOneRatioOnly,\n      approxRadicals,\n      approxRadicalsOfRationals,\n      approxRationalsOfLogs,\n      approxRationalsOfPowersOfE,\n      approxRationalsOfPowersOfPI,\n      approxRationalsOfRadicals,\n      approxSineOfRationalMultiplesOfPI,\n      approxSineOfRationals,\n      approxTrigonometric,\n      approx_just_an_integer,\n      approx_logarithmsOfRationals,\n      approx_nothingUseful,\n      approx_radicalOfRatio,\n      approx_ratioOfRadical,\n      approx_rationalOfE,\n      approx_rationalOfPi,\n      approx_rationalsOfLogarithms,\n      approx_sine_of_pi_times_rational,\n      approx_sine_of_rational,\n      _approxratioRecursive,\n      arccos,\n      arccosh,\n      arcsin,\n      arcsinh,\n      _arctan,\n      arctanh,\n      areunivarpolysfactoredorexpandedform,\n      arg,\n      arglist,\n      assignmentFound,\n      avoidCalculatingPowersIntoArctans,\n      _bake,\n      bake_poly,\n      bake_poly_term,\n      besselj,\n      bessely,\n      bigInt,\n      bignum_factorial,\n      bignum_float,\n      bignum_power_number,\n      bignum_scan_float,\n      bignum_scan_integer,\n      bignum_truncate,\n      binding,\n      binomial,\n      buffer,\n      build_tensor,\n      caaddr,\n      caadr,\n      caar,\n      cadaddr,\n      cadadr,\n      cadar,\n      caddaddr,\n      caddadr,\n      caddar,\n      caddddr,\n      cadddr,\n      caddr,\n      cadr,\n      called_from_Algebra_block,\n      car,\n      cdaddr,\n      cdadr,\n      cdar,\n      cddaddr,\n      cddar,\n      cdddaddr,\n      cddddr,\n      cdddr,\n      cddr,\n      cdr,\n      ceiling,\n      chainOfUserSymbolsNotFunctionsBeingEvaluated,\n      charTabIndex,\n      chartab,\n      checkFloatHasWorkedOutCompletely,\n      check_esc_flag,\n      check_stack,\n      check_tensor_dimensions,\n      choose,\n      choose_check_args,\n      _circexp,\n      clearAlgebraEnvironment,\n      clearRenamedVariablesToAvoidBindingToExternalScope,\n      clear_symbols,\n      clear_term,\n      clearall,\n      clockform,\n      cmpGlyphs,\n      cmp_args,\n      _cmp_expr,\n      cmp_terms,\n      cmp_terms_count,\n      codeGen,\n      coeff,\n      cofactor,\n      collectLatexStringFromReturnValue,\n      _collectUserSymbols,\n      combine_factors,\n      combine_gammas,\n      combine_terms,\n      compareState,\n      compare_numbers,\n      compare_rationals,\n      compare_tensors,\n      compatible,\n      computeDependenciesFromAlgebra,\n      computeResultsAndJavaScriptFromAlgebra,\n      compute_fa,\n      conjugate,\n      cons,\n      consCount,\n      contract,\n      convert_bignum_to_double,\n      convert_rational_to_double,\n      copy_tensor,\n      cosine,\n      cosine_of_angle,\n      cosine_of_angle_sum,\n      _count,\n      _countOccurrencesOfSymbol,\n      count_denominators,\n      counter,\n      countsize,\n      d_scalar_scalar,\n      d_scalar_scalar_1,\n      d_scalar_tensor,\n      d_tensor_scalar,\n      d_tensor_tensor,\n      dabs,\n      darccos,\n      darccosh,\n      darcsin,\n      darcsinh,\n      darctan,\n      darctanh,\n      dbesselj0,\n      dbesseljn,\n      dbessely0,\n      dbesselyn,\n      dcos,\n      dcosh,\n      dd,\n      _decomp,\n      decomp_product,\n      decomp_sum,\n      defineSomeHandyConstants,\n      define_user_function,\n      defn,\n      defn_str,\n      degree,\n      _denominator,\n      derf,\n      derfc,\n      derivative,\n      derivative_of_integral,\n      det,\n      determinant,\n      detg,\n      dfunction,\n      dhermite,\n      dirac,\n      display,\n      display_flag,\n      displaychar,\n      divide,\n      divide_numbers,\n      divisors,\n      divisors_onstack,\n      divpoly,\n      dlog,\n      do_clearPatterns,\n      do_clearall,\n      do_simplify_nested_radicals,\n      dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication,\n      dotprod_unicode,\n      doubleToReasonableString,\n      dpow,\n      dpower,\n      dproduct,\n      draw_flag,\n      draw_stop_return,\n      dsgn,\n      dsin,\n      dsinh,\n      dsum,\n      dtan,\n      dtanh,\n      dupl,\n      eigen,\n      elelmIndex,\n      elem,\n      emit_denominator,\n      emit_denominators,\n      emit_expr,\n      emit_factor,\n      emit_factorial_function,\n      emit_flat_tensor,\n      emit_fraction,\n      emit_function,\n      emit_index_function,\n      emit_multiply,\n      emit_number,\n      emit_numerators,\n      emit_numerical_fraction,\n      emit_power,\n      emit_string,\n      emit_subexpr,\n      emit_symbol,\n      emit_tensor,\n      _emit_tensor_inner,\n      emit_term,\n      emit_top_expr,\n      emit_unsigned_expr,\n      emit_x,\n      equal,\n      equaln,\n      equalq,\n      erfc,\n      errorMessage,\n      esc_flag,\n      evaluatingAsFloats,\n      evaluatingPolar,\n      exec,\n      _expand,\n      expand_get_A,\n      expand_get_AF,\n      expand_get_B,\n      expand_get_C,\n      expand_get_CF,\n      expand_tensor,\n      expanding,\n      expcos,\n      exponential,\n      expr_level,\n      expsin,\n      f1,\n      f10,\n      f2,\n      f3,\n      f4,\n      f5,\n      f9,\n      f_equals_a,\n      factor,\n      factor_a,\n      factor_again,\n      factor_b,\n      factor_number,\n      factor_small_number,\n      factor_term,\n      factorial,\n      factorpoly,\n      factors,\n      factpoly_expo,\n      fill_buf,\n      filter,\n      filter_main,\n      filter_sum,\n      filter_tensor,\n      findDependenciesInScript,\n      _findPossibleClockForm,\n      _findPossibleExponentialForm,\n      findroot,\n      fixup_fraction,\n      fixup_power,\n      flag,\n      floatToRatioRoutine,\n      fmt_index,\n      fmt_level,\n      fmt_x,\n      frame,\n      freeze,\n      functionInvokationsScanningStack,\n      gamma,\n      gamma_of_sum,\n      gammaf,\n      gcd,\n      gcd_main,\n      gcd_numbers,\n      gcd_polys,\n      gcd_powers_with_same_base,\n      gcd_product_product,\n      gcd_product_sum,\n      gcd_sum,\n      gcd_sum_product,\n      gcd_sum_sum,\n      _gen,\n      getSimpleRoots,\n      getStateHash,\n      get_binding,\n      get_factor_from_complex_root,\n      get_factor_from_real_root,\n      _get_innerprod_factors,\n      get_next_token,\n      get_printname,\n      get_size,\n      get_token,\n      getdisplaystr,\n      glyph,\n      gp,\n      guess,\n      hasImaginaryCoeff,\n      hasNegativeRationalExponent,\n      hash_addition,\n      hash_function,\n      hash_multiplication,\n      hash_power,\n      hashcode_values,\n      hashed_itab,\n      hermite,\n      hilbert,\n      i1,\n      imag,\n      imaginaryunit,\n      index_function,\n      init,\n      initNRoots,\n      inited,\n      _inner,\n      inner_f,\n      input_str,\n      integral,\n      integral_of_form,\n      integral_of_product,\n      integral_of_sum,\n      _inv,\n      inverse,\n      invert_number,\n      invg,\n      isNumberOneOverSomething,\n      isNumericAtom,\n      _isNumericAtomOrTensor,\n      isSimpleRoot,\n      isSmall,\n      isSymbolLeftOfAssignment,\n      isSymbolReclaimable,\n      isZeroAtom,\n      isZeroAtomOrTensor,\n      isZeroLikeOrNonZeroLikeOrUndetermined,\n      isZeroTensor,\n      is_denominator,\n      is_factor,\n      is_small_integer,\n      is_square_matrix,\n      is_usr_symbol,\n      isadd,\n      isalnumorunderscore,\n      isalpha,\n      isalphaOrUnderscore,\n      iscomplexnumber,\n      iscomplexnumberdouble,\n      iscons,\n      isdenominator,\n      isdigit,\n      isdouble,\n      iseveninteger,\n      isfactor,\n      isfactorial,\n      _isfloating,\n      isfraction,\n      isidentitymatrix,\n      isimaginarynumber,\n      isimaginarynumberdouble,\n      isimaginaryunit,\n      isinnerordot,\n      isinteger,\n      isintegerfactor,\n      isintegerorintegerfloat,\n      isinv,\n      iskeyword,\n      isminusone,\n      isminusoneoversqrttwo,\n      isminusoneovertwo,\n      ismultiply,\n      isnegative,\n      isnegativenumber,\n      isnegativeterm,\n      isnonnegativeinteger,\n      isnpi,\n      isone,\n      isoneover,\n      isoneoversqrttwo,\n      isoneovertwo,\n      isplusone,\n      isplustwo,\n      ispolyexpandedform,\n      ispolyexpandedform_expr,\n      ispolyexpandedform_factor,\n      ispolyexpandedform_term,\n      ispolyfactoredorexpandedform,\n      ispolyfactoredorexpandedform_factor,\n      ispolyfactoredorexpandedform_power,\n      isposint,\n      ispositivenumber,\n      ispower,\n      isquarterturn,\n      isrational,\n      isspace,\n      isstr,\n      issymbol,\n      _issymbolic,\n      istensor,\n      istranspose,\n      isunderscore,\n      isunivarpolyfactoredorexpandedform,\n      itab,\n      italu_hashcode,\n      j1,\n      laguerre,\n      laguerre2,\n      lastFoundSymbol,\n      latexErrorSign,\n      lcm,\n      leading,\n      legendre,\n      length,\n      lessp,\n      level,\n      list,\n      listLength,\n      logarithm,\n      logbuf,\n      lookupsTotal,\n      lu_decomp,\n      madd,\n      makePositive,\n      makeSignSameAs,\n      make_hashed_itab,\n      mask,\n      mcmp,\n      mcmpint,\n      mdiv,\n      mdivrem,\n      meta_mode,\n      mgcd,\n      mini_solve,\n      mint,\n      mmod,\n      mmul,\n      mod,\n      monic,\n      move,\n      moveTos,\n      mp_clr_bit,\n      mp_denominator,\n      mp_numerator,\n      mp_set_bit,\n      mpow,\n      mprime,\n      mroot,\n      mshiftright,\n      msub,\n      mtotal,\n      _multinomial_sum,\n      multiply,\n      multiply_all,\n      multiply_all_noexpand,\n      multiply_consecutive_constants,\n      multiply_denominators,\n      multiply_denominators_factor,\n      multiply_denominators_term,\n      multiply_noexpand,\n      multiply_numbers,\n      n_factor_number,\n      negate,\n      negate_expand,\n      negate_noexpand,\n      negate_number,\n      new_string,\n      newline_flag,\n      nil_symbols,\n      normaliseDots,\n      normalisedCoeff,\n      normalize_angle,\n      nroots_a,\n      nroots_b,\n      nroots_c,\n      nroots_df,\n      nroots_dx,\n      nroots_fa,\n      nroots_fb,\n      nroots_x,\n      nroots_y,\n      nterms,\n      nthCadr,\n      _numerator,\n      numericRootOfPolynomial,\n      o,\n      one,\n      oneElement,\n      one_as_double,\n      out_buf,\n      out_count,\n      out_of_memory,\n      outer,\n      p0,\n      p1,\n      p2,\n      p3,\n      p4,\n      p5,\n      p6,\n      p7,\n      p8,\n      p9,\n      parse,\n      parse_internal,\n      parse_p1,\n      parse_p2,\n      parse_time_simplifications,\n      partition,\n      patternHasBeenFound,\n      patternsinfo,\n      peek,\n      performing_roots,\n      polar,\n      _polarRectAMinusOneBase,\n      polycoeff,\n      _polyform,\n      pop,\n      pop_double,\n      pop_frame,\n      pop_integer,\n      power,\n      power_str,\n      power_sum,\n      power_tensor,\n      predefinedSymbolsInGlobalScope_doNotTrackInDependencies,\n      prime,\n      primetab,\n      print2dascii,\n      printMode,\n      print_ABS_latex,\n      print_ARCCOS_codegen,\n      print_ARCSIN_codegen,\n      print_ARCTAN_codegen,\n      print_BINOMIAL_latex,\n      print_COS_codegen,\n      print_DEFINT_latex,\n      print_DOT_codegen,\n      print_DOT_latex,\n      print_DO_codegen,\n      print_FOR_codegen,\n      print_INV_codegen,\n      print_INV_latex,\n      print_PRODUCT_codegen,\n      print_PRODUCT_latex,\n      print_SETQ_codegen,\n      print_SIN_codegen,\n      print_SQRT_latex,\n      print_SUM_codegen,\n      print_SUM_latex,\n      print_TAN_codegen,\n      print_TESTEQ_latex,\n      print_TESTGE_latex,\n      print_TESTGT_latex,\n      print_TESTLE_latex,\n      print_TESTLT_latex,\n      print_TEST_codegen,\n      print_TEST_latex,\n      print_TRANSPOSE_codegen,\n      print_TRANSPOSE_latex,\n      print_UNIT_codegen,\n      print_a_over_b,\n      print_base,\n      print_base_of_denom,\n      print_char,\n      print_denom,\n      print_double,\n      print_expo_of_denom,\n      print_exponent,\n      print_expr,\n      _print_factor,\n      print_factorial_function,\n      print_glyphs,\n      print_index_function,\n      _print_list,\n      print_multiply_sign,\n      print_number,\n      _print_power,\n      print_str,\n      print_subexpr,\n      print_tensor,\n      _print_tensor_inner,\n      _print_tensor_inner_latex,\n      print_tensor_latex,\n      print_term,\n      printchar,\n      printchar_nowrap,\n      printline,\n      program_buf,\n      promote_tensor,\n      push,\n      pushTryNotToDuplicate,\n      push_cars,\n      push_double,\n      push_factor,\n      push_frame,\n      push_identity_matrix,\n      push_integer,\n      push_rational,\n      push_symbol,\n      push_term_factors,\n      push_terms,\n      push_zero_matrix,\n      qadd,\n      qdiv,\n      qmul,\n      qpow,\n      qpowf,\n      quickfactor,\n      quickpower,\n      rational,\n      rationalize,\n      rationalize_coefficients,\n      real,\n      reciprocate,\n      _rect,\n      recursionLevelNestedRadicalsRemoval,\n      _recursiveDependencies,\n      ref,\n      ref1,\n      rememberPrint,\n      remove_negative_exponents,\n      reset_after_error,\n      restore,\n      restoreMetaBindings,\n      _rewrite_args,\n      rewrite_args_tensor,\n      roots,\n      roots2,\n      roots3,\n      run,\n      runUserDefinedSimplifications,\n      save,\n      saveMetaBindings,\n      scalar_times_tensor,\n      scan,\n      scan_error,\n      scan_expression,\n      scan_factor,\n      scan_function_call_with_function_name,\n      scan_function_call_without_function_name,\n      scan_index,\n      scan_meta,\n      scan_power,\n      scan_relation,\n      scan_stmt,\n      scan_str,\n      scan_string,\n      scan_subexpr,\n      scan_symbol,\n      scan_tensor,\n      scan_term,\n      scanned,\n      scanningParameters,\n      setM,\n      setSignTo,\n      set_binding,\n      set_component,\n      setq_indexed,\n      sfac_product,\n      sfac_product_f,\n      sgn,\n      shape,\n      show_power_debug,\n      sign,\n      sign_of_term,\n      simfac,\n      simfac_term,\n      simpleComplexityMeasure,\n      simplify,\n      simplifyForCodeGeneration,\n      simplify_1_in_products,\n      simplify_main,\n      simplify_nested_radicals,\n      simplify_polar,\n      simplify_polarRect,\n      simplify_rational_expressions,\n      simplify_rectToClock,\n      simplify_tensor,\n      simplify_trig,\n      _simplifyfactorials,\n      sine,\n      sine_of_angle,\n      sine_of_angle_sum,\n      skipRootVariableToBeSolved,\n      sort_stack,\n      square,\n      ssqrt,\n      stack,\n      stackAddsCount,\n      std_symbol,\n      step,\n      step2,\n      stop,\n      strcmp,\n      stringsEmittedByUserPrintouts,\n      subf,\n      _subst,\n      subtract,\n      subtract_numbers,\n      swap,\n      symbol,\n      symbolsDependencies,\n      symbolsHavingReassignments,\n      symbolsInExpressionsWithoutAssignments,\n      symbolsLeftOfAssignment,\n      symbolsRightOfAssignment,\n      symbolsinfo,\n      symnum,\n      symtab,\n      _take_care_of_nested_radicals,\n      tangent,\n      taylor,\n      tensor,\n      tensor_plus_tensor,\n      tensor_times_scalar,\n      testApprox,\n      test_flag,\n      text_metric,\n      theRandom,\n      token,\n      token_buf,\n      token_str,\n      top,\n      top_level_eval,\n      tos,\n      _transform,\n      _transpose,\n      transpose_unicode,\n      trigmode,\n      trivial_divide,\n      try_kth_prime,\n      turnErrorMessageToLatex,\n      ucmp,\n      unfreeze,\n      unique,\n      _unique_f,\n      update_token_buf,\n      userSimplificationsInListForm,\n      userSimplificationsInStringForm,\n      usr_symbol,\n      verbosing,\n      version,\n      will_be_displayed_as_fraction,\n      ybinomial,\n      ycosh,\n      ydirac,\n      yerf,\n      yerfc,\n      yfloor,\n      yindex,\n      yround,\n      ysinh,\n      yyarg,\n      yybesselj,\n      yybessely,\n      yyceiling,\n      yycondense,\n      yycontract,\n      yycosh,\n      _yydegree,\n      yydetg,\n      yydivpoly,\n      yyerf,\n      yyerfc,\n      yyexpand,\n      yyfactorpoly,\n      _yyfloat,\n      yyfloor,\n      yyhermite,\n      yyhermite2,\n      yyinvg,\n      yylcm,\n      yylog,\n      yymultiply,\n      yyouter,\n      yypower,\n      yyrationalize,\n      yyround,\n      yysgn,\n      yysimfac,\n      yysinh,\n      yytangent,\n      zero,\n      zzfloat,\n      hasProp = {}.hasOwnProperty,\n      slice = [].slice;\n\n  bigInt = require('big-integer');\n  version = \"1.3.1\";\n  SELFTEST = 1;\n  NSYM = 1000;\n  DEBUG = false;\n  PRINTOUTRESULT = false;\n  PRINTMODE_LATEX = \"PRINTMODE_LATEX\";\n  PRINTMODE_2DASCII = \"PRINTMODE_2DASCII\";\n  PRINTMODE_COMPUTER = \"PRINTMODE_COMPUTER\";\n  PRINTMODE_HUMAN = \"PRINTMODE_HUMAN\";\n  PRINTMODE_LIST = \"PRINTMODE_LIST\";\n  printMode = PRINTMODE_COMPUTER;\n  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;\n  recursionLevelNestedRadicalsRemoval = 0;\n  do_simplify_nested_radicals = true;\n  avoidCalculatingPowersIntoArctans = true;\n\n  rational = function () {\n    function rational() {}\n\n    rational.prototype.a = null;\n    rational.prototype.b = null;\n    return rational;\n  }();\n\n  U = function () {\n    U.prototype.cons = null;\n    U.prototype.printname = \"\";\n    U.prototype.str = \"\";\n    U.prototype.tensor = null;\n    U.prototype.q = null;\n    U.prototype.d = 0.0;\n    U.prototype.k = 0;\n    U.prototype.tag = 0;\n\n    U.prototype.toString = function () {\n      return print_expr(this);\n    };\n\n    U.prototype.toLatexString = function () {\n      return collectLatexStringFromReturnValue(this);\n    };\n\n    function U() {\n      this.cons = {};\n      this.cons.car = null;\n      this.cons.cdr = null;\n      this.q = new rational();\n    }\n\n    return U;\n  }();\n\n  errorMessage = \"\";\n  CONS = 0;\n  NUM = 1;\n  DOUBLE = 2;\n  STR = 3;\n  TENSOR = 4;\n  SYM = 5;\n  counter = 0;\n  ABS = counter++;\n  ADD = counter++;\n  ADJ = counter++;\n  AND = counter++;\n  APPROXRATIO = counter++;\n  ARCCOS = counter++;\n  ARCCOSH = counter++;\n  ARCSIN = counter++;\n  ARCSINH = counter++;\n  ARCTAN = counter++;\n  ARCTANH = counter++;\n  ARG = counter++;\n  ATOMIZE = counter++;\n  BESSELJ = counter++;\n  BESSELY = counter++;\n  BINDING = counter++;\n  BINOMIAL = counter++;\n  CEILING = counter++;\n  CHECK = counter++;\n  CHOOSE = counter++;\n  CIRCEXP = counter++;\n  CLEAR = counter++;\n  CLEARALL = counter++;\n  CLEARPATTERNS = counter++;\n  CLOCK = counter++;\n  COEFF = counter++;\n  COFACTOR = counter++;\n  CONDENSE = counter++;\n  CONJ = counter++;\n  CONTRACT = counter++;\n  COS = counter++;\n  COSH = counter++;\n  DECOMP = counter++;\n  DEFINT = counter++;\n  DEGREE = counter++;\n  DENOMINATOR = counter++;\n  DERIVATIVE = counter++;\n  DET = counter++;\n  DIM = counter++;\n  DIRAC = counter++;\n  DIVISORS = counter++;\n  DO = counter++;\n  DOT = counter++;\n  DRAW = counter++;\n  DSOLVE = counter++;\n  EIGEN = counter++;\n  EIGENVAL = counter++;\n  EIGENVEC = counter++;\n  ERF = counter++;\n  ERFC = counter++;\n  EVAL = counter++;\n  EXP = counter++;\n  EXPAND = counter++;\n  EXPCOS = counter++;\n  EXPSIN = counter++;\n  FACTOR = counter++;\n  FACTORIAL = counter++;\n  FACTORPOLY = counter++;\n  FILTER = counter++;\n  FLOATF = counter++;\n  FLOOR = counter++;\n  FOR = counter++;\n  FUNCTION = counter++;\n  GAMMA = counter++;\n  GCD = counter++;\n  HERMITE = counter++;\n  HILBERT = counter++;\n  IMAG = counter++;\n  INDEX = counter++;\n  INNER = counter++;\n  INTEGRAL = counter++;\n  INV = counter++;\n  INVG = counter++;\n  ISINTEGER = counter++;\n  ISPRIME = counter++;\n  LAGUERRE = counter++;\n  LCM = counter++;\n  LEADING = counter++;\n  LEGENDRE = counter++;\n  LOG = counter++;\n  LOOKUP = counter++;\n  MOD = counter++;\n  MULTIPLY = counter++;\n  NOT = counter++;\n  NROOTS = counter++;\n  NUMBER = counter++;\n  NUMERATOR = counter++;\n  OPERATOR = counter++;\n  OR = counter++;\n  OUTER = counter++;\n  PATTERN = counter++;\n  PATTERNSINFO = counter++;\n  POLAR = counter++;\n  POWER = counter++;\n  PRIME = counter++;\n  PRINT_LEAVE_E_ALONE = counter++;\n  PRINT_LEAVE_X_ALONE = counter++;\n  PRINT = counter++;\n  PRINT2DASCII = counter++;\n  PRINTFULL = counter++;\n  PRINTLATEX = counter++;\n  PRINTLIST = counter++;\n  PRINTPLAIN = counter++;\n  PRODUCT = counter++;\n  QUOTE = counter++;\n  QUOTIENT = counter++;\n  RANK = counter++;\n  RATIONALIZE = counter++;\n  REAL = counter++;\n  ROUND = counter++;\n  YYRECT = counter++;\n  ROOTS = counter++;\n  SETQ = counter++;\n  SGN = counter++;\n  SILENTPATTERN = counter++;\n  SIMPLIFY = counter++;\n  SIN = counter++;\n  SINH = counter++;\n  SHAPE = counter++;\n  SQRT = counter++;\n  STOP = counter++;\n  SUBST = counter++;\n  SUM = counter++;\n  SYMBOLSINFO = counter++;\n  TAN = counter++;\n  TANH = counter++;\n  TAYLOR = counter++;\n  TEST = counter++;\n  TESTEQ = counter++;\n  TESTGE = counter++;\n  TESTGT = counter++;\n  TESTLE = counter++;\n  TESTLT = counter++;\n  TRANSPOSE = counter++;\n  UNIT = counter++;\n  ZERO = counter++;\n  NIL = counter++;\n  LAST = counter++;\n  LAST_PRINT = counter++;\n  LAST_2DASCII_PRINT = counter++;\n  LAST_FULL_PRINT = counter++;\n  LAST_LATEX_PRINT = counter++;\n  LAST_LIST_PRINT = counter++;\n  LAST_PLAIN_PRINT = counter++;\n  AUTOEXPAND = counter++;\n  BAKE = counter++;\n  ASSUME_REAL_VARIABLES = counter++;\n  TRACE = counter++;\n  FORCE_FIXED_PRINTOUT = counter++;\n  MAX_FIXED_PRINTOUT_DIGITS = counter++;\n  YYE = counter++;\n  DRAWX = counter++;\n  METAA = counter++;\n  METAB = counter++;\n  METAX = counter++;\n  SECRETX = counter++;\n  VERSION = counter++;\n  PI = counter++;\n  SYMBOL_A = counter++;\n  SYMBOL_B = counter++;\n  SYMBOL_C = counter++;\n  SYMBOL_D = counter++;\n  SYMBOL_I = counter++;\n  SYMBOL_J = counter++;\n  SYMBOL_N = counter++;\n  SYMBOL_R = counter++;\n  SYMBOL_S = counter++;\n  SYMBOL_T = counter++;\n  SYMBOL_X = counter++;\n  SYMBOL_Y = counter++;\n  SYMBOL_Z = counter++;\n  SYMBOL_IDENTITY_MATRIX = counter++;\n  SYMBOL_A_UNDERSCORE = counter++;\n  SYMBOL_B_UNDERSCORE = counter++;\n  SYMBOL_X_UNDERSCORE = counter++;\n  C1 = counter++;\n  C2 = counter++;\n  C3 = counter++;\n  C4 = counter++;\n  C5 = counter++;\n  C6 = counter++;\n  USR_SYMBOLS = counter++;\n  E = YYE;\n  TOS = 100000;\n  BUF = 10000;\n  MAX_PROGRAM_SIZE = 100001;\n  MAXPRIMETAB = 10000;\n  MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;\n  MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;\n  MAXDIM = 24;\n  symbolsDependencies = {};\n  symbolsHavingReassignments = [];\n  symbolsInExpressionsWithoutAssignments = [];\n  patternHasBeenFound = false;\n  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [\"rationalize\", \"abs\", \"e\", \"i\", \"pi\", \"sin\", \"ceiling\", \"cos\", \"roots\", \"integral\", \"derivative\", \"defint\", \"sqrt\", \"eig\", \"cov\", \"deig\", \"dcov\", \"float\", \"floor\", \"product\", \"root\", \"round\", \"sum\", \"test\", \"unit\"];\n  parse_time_simplifications = true;\n  chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n  stringsEmittedByUserPrintouts = \"\";\n  called_from_Algebra_block = false;\n\n  tensor = function () {\n    tensor.prototype.ndim = 0;\n    tensor.prototype.dim = null;\n    tensor.prototype.nelem = 0;\n    tensor.prototype.elem = null;\n\n    function tensor() {\n      this.dim = function () {\n        var o, ref, results;\n        results = [];\n\n        for (o = 0, ref = MAXDIM; 0 <= ref ? o <= ref : o >= ref; 0 <= ref ? o++ : o--) {\n          results.push(0);\n        }\n\n        return results;\n      }();\n\n      this.elem = [];\n    }\n\n    return tensor;\n  }();\n\n  display = function () {\n    function display() {}\n\n    display.prototype.h = 0;\n    display.prototype.w = 0;\n    display.prototype.n = 0;\n    display.prototype.a = [];\n    return display;\n  }();\n\n  text_metric = function () {\n    function text_metric() {}\n\n    text_metric.prototype.ascent = 0;\n    text_metric.prototype.descent = 0;\n    text_metric.prototype.width = 0;\n    return text_metric;\n  }();\n\n  tos = 0;\n  expanding = 0;\n  evaluatingAsFloats = 0;\n  evaluatingPolar = 0;\n  fmt_x = 0;\n  fmt_index = 0;\n  fmt_level = 0;\n  verbosing = 0;\n\n  primetab = function () {\n    var ceil, i, j, primes;\n    primes = [2];\n    i = 3;\n\n    while (primes.length < MAXPRIMETAB) {\n      j = 0;\n      ceil = Math.sqrt(i);\n\n      while (j < primes.length && primes[j] <= ceil) {\n        if (i % primes[j] === 0) {\n          j = -1;\n          break;\n        }\n\n        j++;\n      }\n\n      if (j !== -1) {\n        primes.push(i);\n      }\n\n      i += 2;\n    }\n\n    primes[MAXPRIMETAB] = 0;\n    return primes;\n  }();\n\n  esc_flag = 0;\n  draw_flag = 0;\n  mtotal = 0;\n  trigmode = 0;\n  logbuf = \"\";\n  program_buf = \"\";\n  symtab = [];\n  binding = [];\n  isSymbolReclaimable = [];\n  arglist = [];\n  stack = [];\n  frame = 0;\n  p0 = null;\n  p1 = null;\n  p2 = null;\n  p3 = null;\n  p4 = null;\n  p5 = null;\n  p6 = null;\n  p7 = null;\n  p8 = null;\n  p9 = null;\n  zero = null;\n  one = null;\n  one_as_double = null;\n  imaginaryunit = null;\n  out_buf = \"\";\n  out_count = 0;\n  test_flag = 0;\n  codeGen = false;\n  draw_stop_return = null;\n  userSimplificationsInListForm = [];\n  userSimplificationsInStringForm = [];\n  transpose_unicode = 7488;\n  dotprod_unicode = 183;\n\n  symbol = function symbol(x) {\n    return symtab[x];\n  };\n\n  iscons = function iscons(p) {\n    return p.k === CONS;\n  };\n\n  isrational = function isrational(p) {\n    return p.k === NUM;\n  };\n\n  isdouble = function isdouble(p) {\n    return p.k === DOUBLE;\n  };\n\n  isNumericAtom = function isNumericAtom(p) {\n    return isrational(p) || isdouble(p);\n  };\n\n  isstr = function isstr(p) {\n    return p.k === STR;\n  };\n\n  istensor = function istensor(p) {\n    if (p == null) {\n      debugger;\n    } else {\n      return p.k === TENSOR;\n    }\n  };\n\n  _isNumericAtomOrTensor = function isNumericAtomOrTensor(p) {\n    var a, i, n, o, ref;\n\n    if (isNumericAtom(p) || p === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      return 1;\n    }\n\n    if (!istensor(p) && !isNumericAtom(p)) {\n      return 0;\n    }\n\n    n = p.tensor.nelem;\n    a = p.tensor.elem;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (!_isNumericAtomOrTensor(a[i])) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  issymbol = function issymbol(p) {\n    return p.k === SYM;\n  };\n\n  iskeyword = function iskeyword(p) {\n    return issymbol(p) && symnum(p) < NIL;\n  };\n\n  car = function car(p) {\n    if (iscons(p)) {\n      return p.cons.car;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  cdr = function cdr(p) {\n    if (iscons(p)) {\n      return p.cons.cdr;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  caar = function caar(p) {\n    return car(car(p));\n  };\n\n  cadr = function cadr(p) {\n    return car(cdr(p));\n  };\n\n  cdar = function cdar(p) {\n    return cdr(car(p));\n  };\n\n  cddr = function cddr(p) {\n    return cdr(cdr(p));\n  };\n\n  caadr = function caadr(p) {\n    return car(car(cdr(p)));\n  };\n\n  caddr = function caddr(p) {\n    return car(cdr(cdr(p)));\n  };\n\n  cadar = function cadar(p) {\n    return car(cdr(car(p)));\n  };\n\n  cdadr = function cdadr(p) {\n    return cdr(car(cdr(p)));\n  };\n\n  cddar = function cddar(p) {\n    return cdr(cdr(car(p)));\n  };\n\n  cdddr = function cdddr(p) {\n    return cdr(cdr(cdr(p)));\n  };\n\n  caaddr = function caaddr(p) {\n    return car(car(cdr(cdr(p))));\n  };\n\n  cadadr = function cadadr(p) {\n    return car(cdr(car(cdr(p))));\n  };\n\n  caddar = function caddar(p) {\n    return car(cdr(cdr(car(p))));\n  };\n\n  cdaddr = function cdaddr(p) {\n    return cdr(car(cdr(cdr(p))));\n  };\n\n  cadddr = function cadddr(p) {\n    return car(cdr(cdr(cdr(p))));\n  };\n\n  cddddr = function cddddr(p) {\n    return cdr(cdr(cdr(cdr(p))));\n  };\n\n  caddddr = function caddddr(p) {\n    return car(cdr(cdr(cdr(cdr(p)))));\n  };\n\n  cadaddr = function cadaddr(p) {\n    return car(cdr(car(cdr(cdr(p)))));\n  };\n\n  cddaddr = function cddaddr(p) {\n    return cdr(cdr(car(cdr(cdr(p)))));\n  };\n\n  caddadr = function caddadr(p) {\n    return car(cdr(cdr(car(cdr(p)))));\n  };\n\n  cdddaddr = function cdddaddr(p) {\n    return cdr(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  caddaddr = function caddaddr(p) {\n    return car(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  listLength = function listLength(p) {\n    var startCount;\n    startCount = -1;\n\n    while (iscons(p)) {\n      p = cdr(p);\n      startCount++;\n    }\n\n    return startCount;\n  };\n\n  nthCadr = function nthCadr(p, n) {\n    var startCount;\n    startCount = 0;\n\n    while (startCount <= n) {\n      p = cdr(p);\n      startCount++;\n    }\n\n    return car(p);\n  };\n\n  isadd = function isadd(p) {\n    return car(p) === symbol(ADD);\n  };\n\n  ismultiply = function ismultiply(p) {\n    return car(p) === symbol(MULTIPLY);\n  };\n\n  ispower = function ispower(p) {\n    return car(p) === symbol(POWER);\n  };\n\n  isfactorial = function isfactorial(p) {\n    return car(p) === symbol(FACTORIAL);\n  };\n\n  isinnerordot = function isinnerordot(p) {\n    return car(p) === symbol(INNER) || car(p) === symbol(DOT);\n  };\n\n  istranspose = function istranspose(p) {\n    return car(p) === symbol(TRANSPOSE);\n  };\n\n  isinv = function isinv(p) {\n    return car(p) === symbol(INV);\n  };\n\n  isidentitymatrix = function isidentitymatrix(p) {\n    return p === symbol(SYMBOL_IDENTITY_MATRIX);\n  };\n\n  MSIGN = function MSIGN(p) {\n    if (p.isPositive()) {\n      return 1;\n    } else if (p.isZero()) {\n      return 0;\n    } else {\n      return -1;\n    }\n  };\n\n  MLENGTH = function MLENGTH(p) {\n    return p.toString().length;\n  };\n\n  MZERO = function MZERO(p) {\n    return p.isZero();\n  };\n\n  MEQUAL = function MEQUAL(p, n) {\n    if (p == null) {\n      debugger;\n    }\n\n    return p.equals(n);\n  };\n\n  reset_after_error = function reset_after_error() {\n    moveTos(0);\n    esc_flag = 0;\n    draw_flag = 0;\n    frame = TOS;\n    evaluatingAsFloats = 0;\n    return evaluatingPolar = 0;\n  };\n\n  $ = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n  $.version = version;\n  $.isadd = isadd;\n  $.ismultiply = ismultiply;\n  $.ispower = ispower;\n  $.isfactorial = isfactorial;\n  $.car = car;\n  $.cdr = cdr;\n  $.caar = caar;\n  $.cadr = cadr;\n  $.cdar = cdar;\n  $.cddr = cddr;\n  $.caadr = caadr;\n  $.caddr = caddr;\n  $.cadar = cadar;\n  $.cdadr = cdadr;\n  $.cddar = cddar;\n  $.cdddr = cdddr;\n  $.caaddr = caaddr;\n  $.cadadr = cadadr;\n  $.caddar = caddar;\n  $.cdaddr = cdaddr;\n  $.cadddr = cadddr;\n  $.cddddr = cddddr;\n  $.caddddr = caddddr;\n  $.cadaddr = cadaddr;\n  $.cddaddr = cddaddr;\n  $.caddadr = caddadr;\n  $.cdddaddr = cdddaddr;\n  $.caddaddr = caddaddr;\n  $.symbol = symbol;\n  $.iscons = iscons;\n  $.isrational = isrational;\n  $.isdouble = isdouble;\n  $.isNumericAtom = isNumericAtom;\n  $.isstr = isstr;\n  $.istensor = istensor;\n  $.issymbol = issymbol;\n  $.iskeyword = iskeyword;\n  $.CONS = CONS;\n  $.NUM = NUM;\n  $.DOUBLE = DOUBLE;\n  $.STR = STR;\n  $.TENSOR = TENSOR;\n  $.SYM = SYM;\n  /* abs =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.\n   */\n\n  /*\n   Absolute value of a number,or magnitude of complex z, or norm of a vector\n  \n    z    abs(z)\n    -    ------\n  \n    a    a\n  \n    -a    a\n  \n    (-1)^a    1\n  \n    exp(a + i b)  exp(a)\n  \n    a b    abs(a) abs(b)\n  \n    a + i b    sqrt(a^2 + b^2)\n  \n  Notes\n  \n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n  \n    2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n  \n      abs(numerator(z)) / abs(denominator(z))\n  \n       must be used to get the correct answer. Now the operation is\n       automatic.\n   */\n\n  DEBUG_ABS = false;\n\n  Eval_abs = function Eval_abs() {\n    push(cadr(p1));\n    Eval();\n    return abs();\n  };\n\n  absValFloat = function absValFloat() {\n    Eval();\n\n    _absval();\n\n    Eval();\n    return zzfloat();\n  };\n\n  abs = function abs() {\n    var theArgument;\n    theArgument = top();\n\n    if (DEBUG_ABS) {\n      console.trace(\">>>>  ABS of \" + theArgument);\n    }\n\n    _numerator();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABS numerator \" + stack[tos - 1]);\n    }\n\n    _absval();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL numerator: \" + stack[tos - 1]);\n    }\n\n    push(theArgument);\n\n    _denominator();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABS denominator: \" + stack[tos - 1]);\n    }\n\n    _absval();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL denominator: \" + stack[tos - 1]);\n    }\n\n    divide();\n\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL divided: \" + stack[tos - 1]);\n    }\n\n    if (DEBUG_ABS) {\n      return console.log(\"<<<<<<<  ABS\");\n    }\n  };\n\n  _absval = function absval() {\n    var anyFactorsYet, input;\n    save();\n    p1 = pop();\n    input = p1;\n\n    if (DEBUG_ABS) {\n      console.log(\"ABS of \" + p1);\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just zero\");\n      }\n\n      push(zero);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (isnegativenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a negative\");\n      }\n\n      push(p1);\n      negate();\n      restore();\n      return;\n    }\n\n    if (ispositivenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a positive\");\n      }\n\n      push(p1);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (p1 === symbol(PI)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" of PI\");\n      }\n\n      push(p1);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(ADD) && (_findPossibleClockForm(p1) || _findPossibleExponentialForm(p1) || _Find(p1, imaginaryunit))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a sum\");\n      }\n\n      if (DEBUG_ABS) {\n        console.log(\"abs of a sum\");\n      }\n\n      push(p1);\n\n      _rect();\n\n      p1 = pop();\n      push(p1);\n      real();\n      push_integer(2);\n      power();\n      push(p1);\n      imag();\n      push_integer(2);\n      power();\n      add();\n      push_rational(1, 2);\n      power();\n      simplify_trig();\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is -1 to any power\");\n      }\n\n      if (evaluatingAsFloats) {\n        if (DEBUG_ABS) {\n          console.log(\" abs: numeric, so result is 1.0\");\n        }\n\n        push_double(1.0);\n      } else {\n        if (DEBUG_ABS) {\n          console.log(\" abs: symbolic, so result is 1\");\n        }\n\n        push_integer(1);\n      }\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is something to the power of a positive number\");\n      }\n\n      push(cadr(p1));\n      abs();\n      push(caddr(p1));\n      power();\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is an exponential\");\n      }\n\n      push(caddr(p1));\n      real();\n      exponential();\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a product\");\n      }\n\n      anyFactorsYet = false;\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _absval();\n\n        if (anyFactorsYet) {\n          multiply();\n        }\n\n        anyFactorsYet = true;\n        p1 = cdr(p1);\n      }\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(ABS)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is abs of a abs\");\n      }\n\n      push_symbol(ABS);\n      push(cadr(p1));\n      list(2);\n\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n\n      restore();\n      return;\n    }\n    /*\n     * Evaluation via zzfloat()\n     * ...while this is in theory a powerful mechanism, I've commented it\n     * out because I've refined this method enough to not need this.\n     * Evaling via zzfloat() is in principle more problematic because it could\n     * require further evaluations which could end up in further \"abs\" which\n     * would end up in infinite loops. Better not use it if not necessary.\n    \n     * we look directly at the float evaluation of the argument\n     * to see if we end up with a number, which would mean that there\n     * is no imaginary component and we can just return the input\n     * (or its negation) as the result.\n    push p1\n    zzfloat()\n    floatEvaluation = pop()\n    \n    if (isnegativenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a negative\"\n      push(p1)\n      negate()\n      restore()\n      return\n    \n    if (ispositivenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a positive\"\n      push(p1)\n      if DEBUG_ABS then console.log \" --> ABS of \" + input + \" : \" + stack[tos-1]\n      restore()\n      return\n     */\n\n\n    if (istensor(p1)) {\n      absval_tensor();\n      restore();\n      return;\n    }\n\n    if (isnegativeterm(p1) || car(p1) === symbol(ADD) && isnegativeterm(cadr(p1))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    if (DEBUG_ABS) {\n      console.log(\" abs: \" + p1 + \" is nothing decomposable\");\n    }\n\n    push_symbol(ABS);\n    push(p1);\n    list(2);\n\n    if (DEBUG_ABS) {\n      console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n    }\n\n    return restore();\n  };\n\n  absval_tensor = function absval_tensor() {\n    if (p1.tensor.ndim !== 1) {\n      stop(\"abs(tensor) with tensor rank > 1\");\n    }\n\n    push(p1);\n    push(p1);\n    conjugate();\n\n    _inner();\n\n    push_rational(1, 2);\n    power();\n    simplify();\n    return Eval();\n  };\n  /*\n   Symbolic addition\n  \n    Terms in a sum are combined if they are identical modulo rational\n    coefficients.\n  \n    For example, A + 2A becomes 3A.\n  \n    However, the sum A + sqrt(2) A is not modified.\n  \n    Combining terms can lead to second-order effects.\n  \n    For example, consider the case of\n  \n      1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A\n  \n    The first two terms are combined to yield 2 sqrt(2) A.\n  \n    This result can now be combined with the third term to yield\n  \n      3 sqrt(2) A\n   */\n\n\n  flag = 0;\n\n  Eval_add = function Eval_add() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p2 = pop();\n      push_terms(p2);\n      p1 = cdr(p1);\n    }\n\n    return add_terms(tos - h);\n  };\n\n  stackAddsCount = 0;\n\n  add_terms = function add_terms(n) {\n    var h, i, i1, j1, o, ref, ref1, results, s, subsetOfStack;\n    stackAddsCount++;\n    i = 0;\n    h = tos - n;\n    s = h;\n\n    if (DEBUG) {\n      console.log(\"stack before adding terms #\" + stackAddsCount);\n    }\n\n    if (DEBUG) {\n      for (i = o = 0, ref = tos; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        console.log(_print_list(stack[i]));\n      }\n    }\n\n    for (i = i1 = 0; i1 < 10; i = ++i1) {\n      if (n < 2) {\n        break;\n      }\n\n      flag = 0;\n      subsetOfStack = stack.slice(h, h + n);\n      subsetOfStack.sort(cmp_terms);\n      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n\n      if (flag === 0) {\n        break;\n      }\n\n      n = combine_terms(h, n);\n    }\n\n    moveTos(h + n);\n\n    switch (n) {\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n\n        break;\n\n      case 1:\n        break;\n\n      default:\n        list(n);\n        p1 = pop();\n        push_symbol(ADD);\n        push(p1);\n        cons();\n    }\n\n    if (DEBUG) {\n      console.log(\"stack after adding terms #\" + stackAddsCount);\n    }\n\n    if (DEBUG) {\n      results = [];\n\n      for (i = j1 = 0, ref1 = tos; 0 <= ref1 ? j1 < ref1 : j1 > ref1; i = 0 <= ref1 ? ++j1 : --j1) {\n        results.push(console.log(_print_list(stack[i])));\n      }\n\n      return results;\n    }\n  };\n\n  cmp_terms_count = 0;\n\n  cmp_terms = function cmp_terms(p1, p2) {\n    var i, o, ref, t;\n    cmp_terms_count++;\n    i = 0;\n\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      flag = 1;\n      return 0;\n    }\n\n    if (istensor(p1) && istensor(p2)) {\n      if (p1.tensor.ndim < p2.tensor.ndim) {\n        return -1;\n      }\n\n      if (p1.tensor.ndim > p2.tensor.ndim) {\n        return 1;\n      }\n\n      for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n          return -1;\n        }\n\n        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n          return 1;\n        }\n      }\n\n      flag = 1;\n      return 0;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      if (isNumericAtom(car(p1))) {\n        p1 = cdr(p1);\n\n        if (cdr(p1) === symbol(NIL)) {\n          p1 = car(p1);\n        }\n      }\n    }\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n\n      if (isNumericAtom(car(p2))) {\n        p2 = cdr(p2);\n\n        if (cdr(p2) === symbol(NIL)) {\n          p2 = car(p2);\n        }\n      }\n    }\n\n    t = _cmp_expr(p1, p2);\n\n    if (t === 0) {\n      flag = 1;\n    }\n\n    return t;\n  };\n  /*\n   Compare adjacent terms in s[] and combine if possible.\n  \n    Returns the number of terms remaining in s[].\n  \n    n  number of terms in s[] initially\n   */\n\n\n  combine_terms = function combine_terms(s, n) {\n    var i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;\n    i = 0;\n\n    while (i < n - 1) {\n      check_esc_flag();\n      p3 = stack[s + i];\n      p4 = stack[s + i + 1];\n\n      if (istensor(p3) && istensor(p4)) {\n        push(p3);\n        push(p4);\n        tensor_plus_tensor();\n        p1 = pop();\n\n        if (p1 !== symbol(NIL)) {\n          stack[s + i] = p1;\n\n          for (j = o = ref = i + 1, ref1 = n - 1; ref <= ref1 ? o < ref1 : o > ref1; j = ref <= ref1 ? ++o : --o) {\n            stack[s + j] = stack[s + j + 1];\n          }\n\n          n--;\n          i--;\n        }\n\n        i++;\n        continue;\n      }\n\n      if (istensor(p3) || istensor(p4)) {\n        i++;\n        continue;\n      }\n\n      if (isNumericAtom(p3) && isNumericAtom(p4)) {\n        push(p3);\n        push(p4);\n        add_numbers();\n        p1 = pop();\n\n        if (isZeroAtomOrTensor(p1)) {\n          for (j = i1 = ref2 = i, ref3 = n - 2; ref2 <= ref3 ? i1 < ref3 : i1 > ref3; j = ref2 <= ref3 ? ++i1 : --i1) {\n            stack[s + j] = stack[s + j + 2];\n          }\n\n          n -= 2;\n        } else {\n          stack[s + i] = p1;\n\n          for (j = j1 = ref4 = i + 1, ref5 = n - 1; ref4 <= ref5 ? j1 < ref5 : j1 > ref5; j = ref4 <= ref5 ? ++j1 : --j1) {\n            stack[s + j] = stack[s + j + 1];\n          }\n\n          n--;\n        }\n\n        i--;\n        i++;\n        continue;\n      }\n\n      if (isNumericAtom(p3) || isNumericAtom(p4)) {\n        i++;\n        continue;\n      }\n\n      if (evaluatingAsFloats) {\n        p1 = one_as_double;\n        p2 = one_as_double;\n      } else {\n        p1 = one;\n        p2 = one;\n      }\n\n      t = 0;\n\n      if (car(p3) === symbol(MULTIPLY)) {\n        p3 = cdr(p3);\n        t = 1;\n\n        if (isNumericAtom(car(p3))) {\n          p1 = car(p3);\n          p3 = cdr(p3);\n\n          if (cdr(p3) === symbol(NIL)) {\n            p3 = car(p3);\n            t = 0;\n          }\n        }\n      }\n\n      if (car(p4) === symbol(MULTIPLY)) {\n        p4 = cdr(p4);\n\n        if (isNumericAtom(car(p4))) {\n          p2 = car(p4);\n          p4 = cdr(p4);\n\n          if (cdr(p4) === symbol(NIL)) {\n            p4 = car(p4);\n          }\n        }\n      }\n\n      if (!equal(p3, p4)) {\n        i++;\n        continue;\n      }\n\n      push(p1);\n      push(p2);\n      add_numbers();\n      p1 = pop();\n\n      if (isZeroAtomOrTensor(p1)) {\n        for (j = l1 = ref6 = i, ref7 = n - 2; ref6 <= ref7 ? l1 < ref7 : l1 > ref7; j = ref6 <= ref7 ? ++l1 : --l1) {\n          stack[s + j] = stack[s + j + 2];\n        }\n\n        n -= 2;\n        i--;\n        i++;\n        continue;\n      }\n\n      push(p1);\n\n      if (t) {\n        push(symbol(MULTIPLY));\n        push(p3);\n        cons();\n      } else {\n        push(p3);\n      }\n\n      multiply();\n      stack[s + i] = pop();\n\n      for (j = m1 = ref8 = i + 1, ref9 = n - 1; ref8 <= ref9 ? m1 < ref9 : m1 > ref9; j = ref8 <= ref9 ? ++m1 : --m1) {\n        stack[s + j] = stack[s + j + 1];\n      }\n\n      n--;\n      i--;\n      i++;\n    }\n\n    return n;\n  };\n\n  push_terms = function push_terms(p) {\n    var results;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else if (!isZeroAtom(p)) {\n      return push(p);\n    }\n  };\n\n  add = function add() {\n    var h;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push_terms(p1);\n    push_terms(p2);\n    add_terms(tos - h);\n    return restore();\n  };\n\n  add_all = function add_all(k) {\n    var h, i, o, ref, s;\n    i = 0;\n    save();\n    s = tos - k;\n    h = tos;\n\n    for (i = o = 0, ref = k; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push_terms(stack[s + i]);\n    }\n\n    add_terms(tos - h);\n    p1 = pop();\n    moveTos(tos - k);\n    push(p1);\n    return restore();\n  };\n\n  subtract = function subtract() {\n    negate();\n    return add();\n  };\n  /* adj =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).\n   */\n\n\n  Eval_adj = function Eval_adj() {\n    push(cadr(p1));\n    Eval();\n    return adj();\n  };\n\n  adj = function adj() {\n    var doNothing, i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p1 = pop();\n\n    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"adj: square matrix expected\");\n    }\n\n    n = p1.tensor.dim[0];\n    p2 = alloc_tensor(n * n);\n    p2.tensor.ndim = 2;\n    p2.tensor.dim[0] = n;\n    p2.tensor.dim[1] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        cofactor(p1, n, i, j);\n        p2.tensor.elem[n * j + i] = pop();\n      }\n    }\n\n    push(p2);\n    return restore();\n  };\n  /*\n   Guesses a rational for each float in the passed expression\n   */\n\n\n  Eval_approxratio = function Eval_approxratio() {\n    var theArgument;\n    theArgument = cadr(p1);\n    push(theArgument);\n    return _approxratioRecursive();\n  };\n\n  _approxratioRecursive = function approxratioRecursive() {\n    var i, i1, o, ref, ref1;\n    i = 0;\n    save();\n    p1 = pop();\n\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n\n      for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n\n        _approxratioRecursive();\n\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n\n      push(p4);\n    } else if (p1.k === DOUBLE) {\n      push(p1);\n      approxOneRatioOnly();\n    } else if (iscons(p1)) {\n      push(car(p1));\n\n      _approxratioRecursive();\n\n      push(cdr(p1));\n\n      _approxratioRecursive();\n\n      cons();\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  approxOneRatioOnly = function approxOneRatioOnly() {\n    var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;\n    zzfloat();\n    supposedlyTheFloat = pop();\n\n    if (supposedlyTheFloat.k === DOUBLE) {\n      theFloat = supposedlyTheFloat.d;\n      splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n      if (splitBeforeAndAfterDot.length === 2) {\n        numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n        precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n        theRatio = floatToRatioRoutine(theFloat, precision);\n        push_rational(theRatio[0], theRatio[1]);\n      } else {\n        push_integer(theFloat);\n      }\n\n      return;\n    }\n\n    push_symbol(APPROXRATIO);\n    push(theArgument);\n    return list(2);\n  };\n\n  floatToRatioRoutine = function floatToRatioRoutine(decimal, AccuracyFactor) {\n    var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z, ret;\n    FractionNumerator = void 0;\n    FractionDenominator = void 0;\n    DecimalSign = void 0;\n    Z = void 0;\n    PreviousDenominator = void 0;\n    ScratchValue = void 0;\n    ret = [0, 0];\n\n    if (isNaN(decimal)) {\n      return ret;\n    }\n\n    if (decimal === 2e308) {\n      ret[0] = 1;\n      ret[1] = 0;\n      return ret;\n    }\n\n    if (decimal === -2e308) {\n      ret[0] = -1;\n      ret[1] = 0;\n      return ret;\n    }\n\n    if (decimal < 0.0) {\n      DecimalSign = -1.0;\n    } else {\n      DecimalSign = 1.0;\n    }\n\n    decimal = Math.abs(decimal);\n\n    if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {\n      FractionNumerator = decimal * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n\n    if (decimal < 1.0e-19) {\n      FractionNumerator = DecimalSign;\n      FractionDenominator = 9999999999999999999.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n\n    if (decimal > 1.0e19) {\n      FractionNumerator = 9999999999999999999.0 * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n\n    Z = decimal;\n    PreviousDenominator = 0.0;\n    FractionDenominator = 1.0;\n\n    while (true) {\n      Z = 1.0 / (Z - Math.floor(Z));\n      ScratchValue = FractionDenominator;\n      FractionDenominator = FractionDenominator * Math.floor(Z) + PreviousDenominator;\n      PreviousDenominator = ScratchValue;\n      FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);\n\n      if (!(Math.abs(decimal - FractionNumerator / FractionDenominator) > AccuracyFactor && Z !== Math.floor(Z))) {\n        break;\n      }\n    }\n\n    FractionNumerator = DecimalSign * FractionNumerator;\n    ret[0] = FractionNumerator;\n    ret[1] = FractionDenominator;\n    return ret;\n  };\n\n  approx_just_an_integer = 0;\n  approx_sine_of_rational = 1;\n  approx_sine_of_pi_times_rational = 2;\n  approx_rationalOfPi = 3;\n  approx_radicalOfRatio = 4;\n  approx_nothingUseful = 5;\n  approx_ratioOfRadical = 6;\n  approx_rationalOfE = 7;\n  approx_logarithmsOfRationals = 8;\n  approx_rationalsOfLogarithms = 9;\n\n  approxRationalsOfRadicals = function approxRationalsOfRadicals(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n\n      for (j = i1 = 1; i1 <= 10; j = ++i1) {\n        hypothesis = Math.sqrt(i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sqrt( \" + i + \" ) / \" + j;\n            bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRadicalsOfRationals = function approxRadicalsOfRationals(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, ref1, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [1, 2, 3, 5, 6, 7, 8, 10];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [1, 2, 3, 5, 6, 7, 8, 10];\n\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        hypothesis = Math.sqrt(i / j);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (sqrt( \" + i + \" / \" + j + \" )\";\n            bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRadicals = function approxRadicals(theFloat) {\n    var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);\n\n    if (approxRationalsOfRadicalsResult != null) {\n      return approxRationalsOfRadicalsResult;\n    }\n\n    approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);\n\n    if (approxRadicalsOfRationalsResult != null) {\n      return approxRadicalsOfRationalsResult;\n    }\n\n    return null;\n  };\n\n  approxLogs = function approxLogs(theFloat) {\n    var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);\n\n    if (approxRationalsOfLogsResult != null) {\n      return approxRationalsOfLogsResult;\n    }\n\n    approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);\n\n    if (approxLogsOfRationalsResult != null) {\n      return approxLogsOfRationalsResult;\n    }\n\n    return null;\n  };\n\n  approxRationalsOfLogs = function approxRationalsOfLogs(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 2; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        hypothesis = Math.log(i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j)) === Math.abs(likelyMultiplier / j)) {\n          continue;\n        }\n\n        if (error < 2.2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" ) / \" + j;\n            bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxLogsOfRationals = function approxLogsOfRationals(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        hypothesis = Math.log(i / j);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 1.96 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" / \" + j + \" )\";\n            bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfE = function approxRationalsOfPowersOfE(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 2; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        hypothesis = Math.pow(Math.E, i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (e ^ \" + i + \" ) / \" + j;\n            bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfPI = function approxRationalsOfPowersOfPI(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        hypothesis = Math.pow(Math.PI, i) / j;\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (pi ^ \" + i + \" ) / \" + j + \" )\";\n            bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxTrigonometric = function approxTrigonometric(theFloat) {\n    var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    approxSineOfRationalsResult = approxSineOfRationals(theFloat);\n\n    if (approxSineOfRationalsResult != null) {\n      return approxSineOfRationalsResult;\n    }\n\n    approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);\n\n    if (approxSineOfRationalMultiplesOfPIResult != null) {\n      return approxSineOfRationalMultiplesOfPIResult;\n    }\n\n    return null;\n  };\n\n  approxSineOfRationals = function approxSineOfRationals(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 4; i = ++o) {\n      for (j = i1 = 1; i1 <= 4; j = ++i1) {\n        fraction = i / j;\n        hypothesis = Math.sin(fraction);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" )\";\n            bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxSineOfRationalMultiplesOfPI = function approxSineOfRationalMultiplesOfPI(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n\n    for (i = o = 1; o <= 13; i = ++o) {\n      for (j = i1 = 1; i1 <= 13; j = ++i1) {\n        fraction = i / j;\n        hypothesis = Math.sin(Math.PI * fraction);\n\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n\n        if (error < 23 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n\n          if (complexity < minimumComplexity) {\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" * pi )\";\n            bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n\n    return bestResultSoFar;\n  };\n\n  approxAll = function approxAll(theFloat) {\n    var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n\n    console.log(\"precision: \" + precision);\n    constantsSumMin = Number.MAX_VALUE;\n    constantsSum = 0;\n    bestApproxSoFar = null;\n    LOG_EXPLANATIONS = true;\n    approxRadicalsResult = approxRadicals(theFloat);\n\n    if (approxRadicalsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRadicalsResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRadicalsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxLogsResult = approxLogs(theFloat);\n\n    if (approxLogsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxLogsResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxLogsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);\n\n    if (approxRationalsOfPowersOfEResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfEResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);\n\n    if (approxRationalsOfPowersOfPIResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfPIResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    approxTrigonometricResult = approxTrigonometric(theFloat);\n\n    if (approxTrigonometricResult != null) {\n      constantsSum = simpleComplexityMeasure(approxTrigonometricResult);\n\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxTrigonometricResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n\n    return bestApproxSoFar;\n  };\n\n  simpleComplexityMeasure = function simpleComplexityMeasure(aResult, b, c) {\n    var theSum;\n    theSum = null;\n\n    if (aResult instanceof Array) {\n      switch (aResult[1]) {\n        case approx_sine_of_pi_times_rational:\n          theSum = 4;\n          break;\n\n        case approx_rationalOfPi:\n          theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n\n        case approx_rationalOfE:\n          theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n\n        default:\n          theSum = 0;\n      }\n\n      theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));\n    } else {\n      theSum += Math.abs(aResult) * (Math.abs(b) + Math.abs(c));\n    }\n\n    if (aResult[2] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n\n    if (aResult[3] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n\n    if (aResult[4] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n\n    if (theSum < 0) {\n      theSum = 0;\n    }\n\n    return theSum;\n  };\n\n  testApprox = function testApprox() {\n    var error, fraction, i, i1, i2, i3, j, j1, j2, j3, k3, l1, l2, l3, len, len1, len2, len3, len4, len5, len6, len7, m1, m2, m3, n1, n2, o, o1, o2, originalValue, q1, q2, r1, r2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s2, t1, t2, u1, u2, v1, v2, value, x1, x2, z1, z2;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [2, 3, 5, 6, 7, 8, 10];\n\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n\n        if (i === j) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.sqrt(i) / j;\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    ref2 = [2, 3, 5, 6, 7, 8, 10];\n\n    for (j1 = 0, len2 = ref2.length; j1 < len2; j1++) {\n      i = ref2[j1];\n      ref3 = [2, 3, 5, 6, 7, 8, 10];\n\n      for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {\n        j = ref3[l1];\n\n        if (i === j) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.sqrt(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    ref4 = [2, 3, 5, 6, 7, 8, 10];\n\n    for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {\n      i = ref4[m1];\n      ref5 = [2, 3, 5, 6, 7, 8, 10];\n\n      for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {\n        j = ref5[n1];\n\n        if (i === j) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.sqrt(i / j);\n        returned = approxRadicals(value);\n\n        if (returned != null) {\n          returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n\n          if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {\n            console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n          }\n        }\n      }\n    }\n\n    ref6 = [1, 2, 3, 5, 6, 7, 8, 10];\n\n    for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {\n      i = ref6[o1];\n      ref7 = [1, 2, 3, 5, 6, 7, 8, 10];\n\n      for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {\n        j = ref7[q1];\n\n        if (i === 1 && j === 1) {\n          continue;\n        }\n\n        console.log(\"testapproxRadicals testing with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sqrt(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n\n        if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = r1 = 1; r1 <= 5; i = ++r1) {\n      for (j = s1 = 1; s1 <= 5; j = ++s1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.log(i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = t1 = 1; t1 <= 5; i = ++t1) {\n      for (j = u1 = 1; u1 <= 5; j = ++u1) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.log(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = v1 = 1; v1 <= 5; i = ++v1) {\n      for (j = x1 = 1; x1 <= 5; j = ++x1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.log(i / j);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = z1 = 1; z1 <= 5; i = ++z1) {\n      for (j = i2 = 1; i2 <= 5; j = ++i2) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.log(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = j2 = 1; j2 <= 2; i = ++j2) {\n      for (j = l2 = 1; l2 <= 12; j = ++l2) {\n        console.log(\"testApproxAll testing: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.E, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = m2 = 1; m2 <= 2; i = ++m2) {\n      for (j = n2 = 1; n2 <= 12; j = ++n2) {\n        console.log(\"approxRationalsOfPowersOfE testing with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.E, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfE(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfE with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = o2 = 1; o2 <= 2; i = ++o2) {\n      for (j = q2 = 1; q2 <= 12; j = ++q2) {\n        console.log(\"testApproxAll testing: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.PI, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = r2 = 1; r2 <= 2; i = ++r2) {\n      for (j = s2 = 1; s2 <= 12; j = ++s2) {\n        console.log(\"approxRationalsOfPowersOfPI testing with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.PI, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfPI(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfPI with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = t2 = 1; t2 <= 4; i = ++t2) {\n      for (j = u2 = 1; u2 <= 4; j = ++u2) {\n        console.log(\"testApproxAll testing: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        value = Math.sin(fraction);\n        returned = approxAll(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = v2 = 1; v2 <= 4; i = ++v2) {\n      for (j = x2 = 1; x2 <= 4; j = ++x2) {\n        console.log(\"testApproxAll testing with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(5);\n        returned = approxAll(value);\n\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n\n    for (i = z2 = 1; z2 <= 4; i = ++z2) {\n      for (j = i3 = 1; i3 <= 4; j = ++i3) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n\n    value = 0;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0\");\n    }\n\n    value = 0.0;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0\");\n    }\n\n    value = 0.00;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.00\");\n    }\n\n    value = 0.000;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.000\");\n    }\n\n    value = 0.0000;\n\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0000\");\n    }\n\n    value = 1;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1\");\n    }\n\n    value = 1.0;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0\");\n    }\n\n    value = 1.00;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00\");\n    }\n\n    value = 1.000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.000\");\n    }\n\n    value = 1.0000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n\n    value = 1.00000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00000\");\n    }\n\n    value = Math.sqrt(2);\n\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2)\");\n    }\n\n    value = 1.41;\n\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: 1.41\");\n    }\n\n    value = 1.4;\n\n    if (approxRadicals(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail approxRadicals: 1.4\");\n    }\n\n    value = 0.6;\n\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.6\");\n    }\n\n    value = 0.69;\n\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.69\");\n    }\n\n    value = 0.7;\n\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.7\");\n    }\n\n    value = 1.09;\n\n    if (approxLogs(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxLogs: 1.09\");\n    }\n\n    value = 1.09;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.09\");\n    }\n\n    value = 1.098;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.098\");\n    }\n\n    value = 1.1;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.1\");\n    }\n\n    value = 1.11;\n\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.11\");\n    }\n\n    value = Math.sqrt(3);\n\n    if (approxAll(value)[0] !== \"1 * sqrt( 3 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(3)\");\n    }\n\n    value = 1.0000;\n\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n\n    value = 3.141592;\n\n    if (approxAll(value)[0] !== \"1 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 3.141592\");\n    }\n\n    value = 31.41592;\n\n    if (approxAll(value)[0] !== \"10 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31.41592\");\n    }\n\n    value = 314.1592;\n\n    if (approxAll(value)[0] !== \"100 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 314.1592\");\n    }\n\n    value = 31415926.53589793;\n\n    if (approxAll(value)[0] !== \"10000000 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31415926.53589793\");\n    }\n\n    value = Math.sqrt(2);\n\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/4 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(2)\");\n    }\n\n    value = Math.sqrt(3);\n\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/3 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(3)\");\n    }\n\n    value = (Math.sqrt(6) - Math.sqrt(2)) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4\");\n    }\n\n    value = Math.sqrt(2 - Math.sqrt(2)) / 2;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/8 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2\");\n    }\n\n    value = (Math.sqrt(6) + Math.sqrt(2)) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4\");\n    }\n\n    value = Math.sqrt(2 + Math.sqrt(3)) / 2;\n\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2\");\n    }\n\n    value = (Math.sqrt(5) - 1) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/10 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(5) - 1)/4\");\n    }\n\n    value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/5 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4\");\n    }\n\n    value = Math.sin(Math.PI / 7);\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/7 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/7)\");\n    }\n\n    value = Math.sin(Math.PI / 9);\n\n    if (approxAll(value)[0] !== \"1 * sin( 1/9 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/9)\");\n    }\n\n    value = 1836.15267;\n\n    if (approxRationalsOfPowersOfPI(value)[0] !== \"6 * (pi ^ 5 ) / 1 )\") {\n      console.log(\"fail approxRationalsOfPowersOfPI: 1836.15267\");\n    }\n\n    for (i = j3 = 1; j3 <= 13; i = ++j3) {\n      for (j = k3 = 1; k3 <= 13; j = ++k3) {\n        console.log(\"approxTrigonometric testing: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        value = Math.sin(Math.PI * fraction);\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail approxTrigonometric: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned);\n        }\n      }\n    }\n\n    for (i = l3 = 1; l3 <= 13; i = ++l3) {\n      for (j = m3 = 1; m3 <= 13; j = ++m3) {\n        if (i === 5 && j === 11 || i === 6 && j === 11) {\n          continue;\n        }\n\n        console.log(\"approxTrigonometric testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        originalValue = Math.sin(Math.PI * fraction);\n        value = originalValue.toFixed(4);\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n\n        if (error > 1e-14) {\n          console.log(\"fail approxTrigonometric with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n\n    return console.log(\"testApprox done\");\n  };\n\n  $.approxRadicals = approxRadicals;\n  $.approxRationalsOfLogs = approxRationalsOfLogs;\n  $.approxAll = approxAll;\n  $.testApprox = testApprox;\n  /* arccos =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse cosine of x.\n   */\n\n  Eval_arccos = function Eval_arccos() {\n    push(cadr(p1));\n    Eval();\n    return arccos();\n  };\n\n  arccos = function arccos() {\n    var d, errno, n;\n    n = 0;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.acos(p1.d);\n\n      if (errno) {\n        stop(\"arccos function argument is not in the interval [-1,1]\");\n      }\n\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 4.0);\n      } else {\n        push_rational(1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n\n      restore();\n      return;\n    }\n\n    if (isminusoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI * 3.0 / 4.0);\n      } else {\n        push_rational(3, 4);\n        push_symbol(PI);\n        multiply();\n      }\n\n      restore();\n      return;\n    }\n\n    if (!isrational(p1)) {\n      push_symbol(ARCCOS);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push_symbol(PI);\n        }\n\n        break;\n\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI * 2.0 / 3.0);\n        } else {\n          push_rational(2, 3);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 3.0);\n        } else {\n          push_rational(1, 3);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n\n        break;\n\n      default:\n        push_symbol(ARCCOS);\n        push(p1);\n        list(2);\n    }\n\n    return restore();\n  };\n  /* arccosh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse hyperbolic cosine of x.\n   */\n\n\n  Eval_arccosh = function Eval_arccosh() {\n    push(cadr(p1));\n    Eval();\n    return arccosh();\n  };\n\n  arccosh = function arccosh() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(COSH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = p1.d;\n\n      if (d < 1.0) {\n        stop(\"arccosh function argument is less than 1.0\");\n      }\n\n      d = Math.log(d + Math.sqrt(d * d - 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isplusone(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    push_symbol(ARCCOSH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arcsin =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse sine of x.\n   */\n\n\n  Eval_arcsin = function Eval_arcsin() {\n    push(cadr(p1));\n    Eval();\n    return arcsin();\n  };\n\n  arcsin = function arcsin() {\n    var d, errno, n;\n    n = 0;\n    d = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.asin(p1.d);\n\n      if (errno) {\n        stop(\"arcsin function argument is not in the interval [-1,1]\");\n      }\n\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      push_rational(1, 4);\n      push_symbol(PI);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (isminusoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 4.0);\n      } else {\n        push_rational(-1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n\n      restore();\n      return;\n    }\n\n    if (!isrational(p1)) {\n      push_symbol(ARCSIN);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 2.0);\n        } else {\n          push_rational(-1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 6.0);\n        } else {\n          push_rational(-1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n\n        break;\n\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 6.0);\n        } else {\n          push_rational(1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n\n        break;\n\n      default:\n        push_symbol(ARCSIN);\n        push(p1);\n        list(2);\n    }\n\n    return restore();\n  };\n  /* arcsinh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse hyperbolic sine of x.\n   */\n\n\n  Eval_arcsinh = function Eval_arcsinh() {\n    push(cadr(p1));\n    Eval();\n    return arcsinh();\n  };\n\n  arcsinh = function arcsinh() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(SINH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = p1.d;\n      d = Math.log(d + Math.sqrt(d * d + 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    push_symbol(ARCSINH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arctan =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse tangent of x.\n   */\n\n\n  Eval_arctan = function Eval_arctan() {\n    push(cadr(p1));\n    Eval();\n    return _arctan();\n  };\n\n  _arctan = function arctan() {\n    var d, errno;\n    d = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(TAN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.atan(p1.d);\n\n      if (errno) {\n        stop(\"arctan function error\");\n      }\n\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n\n      _arctan();\n\n      negate();\n      restore();\n      return;\n    }\n\n    if (_Find(p1, symbol(SIN)) && _Find(p1, symbol(COS))) {\n      push(p1);\n\n      _numerator();\n\n      p2 = pop();\n      push(p1);\n\n      _denominator();\n\n      p3 = pop();\n\n      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {\n        push(cadr(p2));\n        restore();\n        return;\n      }\n    }\n\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {\n      push_rational(1, 6);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      multiply();\n      restore();\n      return;\n    }\n\n    if (equaln(p1, 1)) {\n      push_rational(1, 4);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      multiply();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {\n      push_rational(1, 3);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      multiply();\n      restore();\n      return;\n    }\n\n    push_symbol(ARCTAN);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arctanh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the inverse hyperbolic tangent of x.\n   */\n\n\n  Eval_arctanh = function Eval_arctanh() {\n    push(cadr(p1));\n    Eval();\n    return arctanh();\n  };\n\n  arctanh = function arctanh() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(TANH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = p1.d;\n\n      if (d < -1.0 || d > 1.0) {\n        stop(\"arctanh function argument is not in the interval [-1,1]\");\n      }\n\n      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;\n      push_double(d);\n      restore();\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    push_symbol(ARCTANH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n  /* arg =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  z\n  \n  General description\n  -------------------\n  Returns the angle of complex z.\n   */\n\n  /*\n   Argument (angle) of complex z\n  \n    z    arg(z)\n    -    ------\n  \n    a    0\n  \n    -a    -pi      See note 3 below\n  \n    (-1)^a    a pi\n  \n    exp(a + i b)  b\n  \n    a b    arg(a) + arg(b)\n  \n    a + i b    arctan(b/a)\n  \n  Result by quadrant\n  \n    z    arg(z)\n    -    ------\n  \n    1 + i    1/4 pi\n  \n    1 - i    -1/4 pi\n  \n    -1 + i    3/4 pi\n  \n    -1 - i    -3/4 pi\n  \n  Notes\n  \n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n  \n    2. Symbols in z are assumed to be positive and real.\n  \n    3. Negative direction adds -pi to angle.\n  \n       Example: z = (-1)^(1/3), abs(z) = 1/3 pi, abs(-z) = -2/3 pi\n  \n    4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n  \n      arg(numerator(z)) - arg(denominator(z))\n  \n       must be used to get the correct answer. Now the operation is\n       automatic.\n   */\n\n\n  DEBUG_ARG = false;\n\n  Eval_arg = function Eval_arg() {\n    push(cadr(p1));\n    Eval();\n    return arg();\n  };\n\n  arg = function arg() {\n    save();\n    p1 = pop();\n    push(p1);\n\n    _numerator();\n\n    yyarg();\n    push(p1);\n\n    _denominator();\n\n    yyarg();\n    subtract();\n    return restore();\n  };\n\n  yyarg = function yyarg() {\n    save();\n    p1 = pop();\n\n    if (ispositivenumber(p1) || p1 === symbol(PI)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(0);\n      } else {\n        push_integer(0);\n      }\n    } else if (isnegativenumber(p1)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      negate();\n    } else if (issymbol(p1)) {\n      push_symbol(ARG);\n      push(p1);\n      list(2);\n    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      push(caddr(p1));\n      imag();\n    } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {\n      if (DEBUG_ARG) {\n        console.log(\"arg of a sqrt: \" + p1);\n      }\n\n      if (DEBUG_ARG) {\n        debugger;\n      }\n\n      push(cadr(p1));\n      arg();\n\n      if (DEBUG_ARG) {\n        console.log(\" = 1/2 * \" + stack[tos - 1]);\n      }\n\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        arg();\n        add();\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n\n      _rect();\n\n      p1 = pop();\n      push(p1);\n      real();\n      p2 = pop();\n      push(p1);\n      imag();\n      p3 = pop();\n\n      if (isZeroAtomOrTensor(p2)) {\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n\n        if (isnegative(p3)) {\n          negate();\n        }\n      } else {\n        push(p3);\n        push(p2);\n        divide();\n\n        _arctan();\n\n        if (isnegative(p2)) {\n          if (evaluatingAsFloats) {\n            push_double(Math.PI);\n          } else {\n            push_symbol(PI);\n          }\n\n          if (isnegative(p3)) {\n            subtract();\n          } else {\n            add();\n          }\n        }\n      }\n    } else {\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push_integer(0);\n      } else {\n        push_symbol(ARG);\n        push(p1);\n        list(2);\n      }\n    }\n\n    return restore();\n  };\n\n  _bake = function bake() {\n    var h, s, t, x, y, z;\n    h = 0;\n    s = 0;\n    t = 0;\n    x = 0;\n    y = 0;\n    z = 0;\n    expanding++;\n    save();\n    p1 = pop();\n    s = ispolyexpandedform(p1, symbol(SYMBOL_S));\n    t = ispolyexpandedform(p1, symbol(SYMBOL_T));\n    x = ispolyexpandedform(p1, symbol(SYMBOL_X));\n    y = ispolyexpandedform(p1, symbol(SYMBOL_Y));\n    z = ispolyexpandedform(p1, symbol(SYMBOL_Z));\n\n    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_S);\n      bake_poly();\n    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_T);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_X);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {\n      p2 = symbol(SYMBOL_Y);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {\n      p2 = symbol(SYMBOL_Z);\n      bake_poly();\n    } else if (iscons(p1) && car(p1) !== symbol(FOR)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _bake();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n\n    restore();\n    return expanding--;\n  };\n\n  _polyform = function polyform() {\n    var h;\n    h = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (ispolyexpandedform(p1, p2)) {\n      bake_poly();\n    } else if (iscons(p1)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n\n        _polyform();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  bake_poly = function bake_poly() {\n    var a, h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    a = tos;\n    push(p1);\n    push(p2);\n    k = coeff();\n    h = tos;\n\n    for (i = o = ref = k - 1; o >= 0; i = o += -1) {\n      p1 = stack[a + i];\n      bake_poly_term(i);\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      list(n);\n      push(symbol(ADD));\n      swap();\n      cons();\n    }\n\n    p1 = pop();\n    moveTos(tos - k);\n    return push(p1);\n  };\n\n  bake_poly_term = function bake_poly_term(k) {\n    var h, n;\n    h = 0;\n    n = 0;\n\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n\n    if (k === 0) {\n      if (car(p1) === symbol(ADD)) {\n        p1 = cdr(p1);\n\n        while (iscons(p1)) {\n          push(car(p1));\n          p1 = cdr(p1);\n        }\n      } else {\n        push(p1);\n      }\n\n      return;\n    }\n\n    h = tos;\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else if (!equaln(p1, 1)) {\n      push(p1);\n    }\n\n    if (k === 1) {\n      push(p2);\n    } else {\n      push(symbol(POWER));\n      push(p2);\n      push_integer(k);\n      list(3);\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      list(n);\n      push(symbol(MULTIPLY));\n      swap();\n      return cons();\n    }\n  };\n  /* besselj =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x,n\n  \n  General description\n  -------------------\n  \n  Returns a solution to the Bessel differential equation (Bessel function of first kind).\n  \n  Recurrence relation:\n  \n    besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)\n  \n    besselj(x,1/2) = sqrt(2/pi/x) sin(x)\n  \n    besselj(x,-1/2) = sqrt(2/pi/x) cos(x)\n  \n  For negative n, reorder the recurrence relation as:\n  \n    besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)\n  \n  Substitute n+2 for n to obtain\n  \n    besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)\n  \n  Examples:\n  \n    besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)\n  \n    besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)\n   */\n\n\n  Eval_besselj = function Eval_besselj() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return besselj();\n  };\n\n  besselj = function besselj() {\n    save();\n    yybesselj();\n    return restore();\n  };\n\n  yybesselj = function yybesselj() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (isdouble(p1) && !isNaN(n)) {\n      d = jn(n, p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1) && !isNaN(n)) {\n      push_integer(0);\n      return;\n    }\n\n    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {\n      if (MEQUAL(p2.q.a, 1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        sine();\n        multiply();\n        return;\n      }\n\n      if (MEQUAL(p2.q.a, -1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        cosine();\n        multiply();\n        return;\n      }\n\n      push_integer(MSIGN(p2.q.a));\n      p3 = pop();\n      push_integer(2);\n      push(p1);\n      divide();\n      push(p2);\n      push(p3);\n      subtract();\n      multiply();\n      push(p1);\n      push(p2);\n      push(p3);\n      subtract();\n      besselj();\n      multiply();\n      push(p1);\n      push(p2);\n      push_integer(2);\n      push(p3);\n      multiply();\n      subtract();\n      besselj();\n      subtract();\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      power();\n      push(p1);\n      push(p2);\n      negate();\n      power();\n      multiply();\n      push_symbol(BESSELJ);\n      push(p1);\n      negate();\n      push(p2);\n      list(3);\n      multiply();\n      return;\n    }\n\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELJ);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n\n    push(symbol(BESSELJ));\n    push(p1);\n    push(p2);\n    return list(3);\n  };\n  /* bessely =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x,n\n  \n  General description\n  -------------------\n  \n  Bessel function of second kind.\n   */\n\n\n  Eval_bessely = function Eval_bessely() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return bessely();\n  };\n\n  bessely = function bessely() {\n    save();\n    yybessely();\n    return restore();\n  };\n\n  yybessely = function yybessely() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (isdouble(p1) && !isNaN(n)) {\n      d = yn(n, p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELY);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n\n    push_symbol(BESSELY);\n    push(p1);\n    push(p2);\n    list(3);\n  };\n\n  mint = function mint(a) {\n    return bigInt(a);\n  };\n\n  isSmall = function isSmall(a) {\n    return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);\n  };\n\n  setSignTo = function setSignTo(a, b) {\n    if (a.isPositive()) {\n      if (b < 0) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      if (b > 0) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n\n    return a;\n  };\n\n  makeSignSameAs = function makeSignSameAs(a, b) {\n    if (a.isPositive()) {\n      if (b.isNegative()) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      if (b.isPositive()) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n\n    return a;\n  };\n\n  makePositive = function makePositive(a) {\n    if (a.isNegative()) {\n      return a.multiply(bigInt(-1));\n    }\n\n    return a;\n  };\n  /*\n  mtotal = 0\n  MP_MIN_SIZE = 2\n  MP_MAX_FREE  = 1000\n  \n  mnew = (n) ->\n    if (n < MP_MIN_SIZE)\n      n = MP_MIN_SIZE\n    if (n == MP_MIN_SIZE && mfreecount)\n      p = free_stack[--mfreecount]\n    else\n      p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))\n      #if (p == 0)\n       *  stop(\"malloc failure\")\n    p[0] = n\n    mtotal += n\n    return p[3]\n   */\n\n  /*\n  free_stack = []\n  \n  mfree = (array, p) ->\n    p -= 3\n    mtotal -= array[p]\n    if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)\n      free_stack[mfreecount++] = p\n    else\n      free(p)\n   */\n\n  /*\n  mint = (n) ->\n    p = mnew(1)\n    if (n < 0)\n       * !!! this is FU\n       * MSIGN(p) = -1\n      fu = true\n    else\n       * !!! this is FU\n      #MSIGN(p) = 1\n      fu = true\n     * !!! this is FU\n    #MLENGTH(p) = 1\n    p[0] = Math.abs(n)\n    return p\n   */\n\n  /*\n  mcopy = (a) ->\n    #unsigned int *b\n  \n    b = mnew(MLENGTH(a))\n  \n     * !!! fu\n    #MSIGN(b) = MSIGN(a)\n    #MLENGTH(b) = MLENGTH(a)\n  \n    for i in [0...MLENGTH(a)]\n      b[i] = a[i]\n  \n    return b\n   */\n\n  /*\n   * \n   * ge not invoked from anywhere - is you need ge\n   * just use the bigNum's ge implementation\n   * leaving it here just in case I decide to backport to C\n   *\n   * a >= b ?\n   * and and b arrays of ints, len is an int\n  ge = (a, b, len) ->\n    i = 0\n    for i in [0...len]\n      if (a[i] == b[i])\n        continue\n      else\n        break\n    if (a[i] >= b[i])\n      return 1\n    else\n      return 0\n   */\n\n\n  add_numbers = function add_numbers() {\n    var a, b, theResult;\n    a = 1.0;\n    b = 1.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qadd();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    theResult = a + b;\n    push_double(theResult);\n    return restore();\n  };\n\n  subtract_numbers = function subtract_numbers() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qsub();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    push_double(a - b);\n    return restore();\n  };\n\n  multiply_numbers = function multiply_numbers() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qmul();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    push_double(a * b);\n    return restore();\n  };\n\n  divide_numbers = function divide_numbers() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qdiv();\n      return;\n    }\n\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"divide by zero\");\n    }\n\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n\n    push_double(a / b);\n    return restore();\n  };\n\n  invert_number = function invert_number() {\n    var a, b;\n    save();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p1)) {\n      stop(\"divide by zero\");\n    }\n\n    if (isdouble(p1)) {\n      push_double(1 / p1.d);\n      restore();\n      return;\n    }\n\n    a = bigInt(p1.q.a);\n    b = bigInt(p1.q.b);\n    b = makeSignSameAs(b, a);\n    a = setSignTo(a, 1);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = b;\n    p1.q.b = a;\n    push(p1);\n    return restore();\n  };\n\n  compare_rationals = function compare_rationals(a, b) {\n    var ab, ba, t;\n    t = 0;\n    ab = mmul(a.q.a, b.q.b);\n    ba = mmul(a.q.b, b.q.a);\n    t = mcmp(ab, ba);\n    return t;\n  };\n\n  compare_numbers = function compare_numbers(a, b) {\n    var x, y;\n    x = 0.0;\n    y = 0.0;\n\n    if (isrational(a) && isrational(b)) {\n      return compare_rationals(a, b);\n    }\n\n    if (isdouble(a)) {\n      x = a.d;\n    } else {\n      x = convert_rational_to_double(a);\n    }\n\n    if (isdouble(b)) {\n      y = b.d;\n    } else {\n      y = convert_rational_to_double(b);\n    }\n\n    if (x < y) {\n      return -1;\n    }\n\n    if (x > y) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  negate_number = function negate_number() {\n    save();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    switch (p1.k) {\n      case NUM:\n        p2 = new U();\n        p2.k = NUM;\n        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));\n        p2.q.b = bigInt(p1.q.b);\n        push(p2);\n        break;\n\n      case DOUBLE:\n        push_double(-p1.d);\n        break;\n\n      default:\n        stop(\"bug caught in mp_negate_number\");\n    }\n\n    return restore();\n  };\n\n  bignum_truncate = function bignum_truncate() {\n    var a;\n    save();\n    p1 = pop();\n    a = mdiv(p1.q.a, p1.q.b);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  mp_numerator = function mp_numerator() {\n    save();\n    p1 = pop();\n\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.a);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  mp_denominator = function mp_denominator() {\n    save();\n    p1 = pop();\n\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.b);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  bignum_power_number = function bignum_power_number(expo) {\n    var a, b, t;\n    save();\n    p1 = pop();\n    a = mpow(p1.q.a, Math.abs(expo));\n    b = mpow(p1.q.b, Math.abs(expo));\n\n    if (expo < 0) {\n      t = a;\n      a = b;\n      b = t;\n      a = makeSignSameAs(a, b);\n      b = setSignTo(b, 1);\n    }\n\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = b;\n    push(p1);\n    return restore();\n  };\n\n  convert_bignum_to_double = function convert_bignum_to_double(p) {\n    return p.toJSNumber();\n  };\n\n  convert_rational_to_double = function convert_rational_to_double(p) {\n    var quotientAndRemainder, result;\n\n    if (p.q == null) {\n      debugger;\n    }\n\n    quotientAndRemainder = p.q.a.divmod(p.q.b);\n    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();\n    return result;\n  };\n\n  push_integer = function push_integer(n) {\n    if (DEBUG) {\n      console.log(\"pushing integer \" + n);\n    }\n\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = bigInt(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  push_double = function push_double(d) {\n    save();\n    p1 = new U();\n    p1.k = DOUBLE;\n    p1.d = d;\n    push(p1);\n    return restore();\n  };\n\n  push_rational = function push_rational(a, b) {\n    /*\n    save()\n    p1 = new U()\n    p1.k = NUM\n    p1.q.a = bigInt(a)\n    p1.q.b = bigInt(b)\n    ## FIXME -- normalize ##\n    push(p1)\n    restore()\n     */\n    var p;\n    p = new U();\n    p.k = NUM;\n    p.q.a = bigInt(a);\n    p.q.b = bigInt(b);\n    return push(p);\n  };\n\n  pop_integer = function pop_integer() {\n    var n;\n    n = 0 / 0;\n    save();\n    p1 = pop();\n\n    switch (p1.k) {\n      case NUM:\n        if (isinteger(p1) && isSmall(p1.q.a)) {\n          n = p1.q.a.toJSNumber();\n        }\n\n        break;\n\n      case DOUBLE:\n        if (DEBUG) {\n          console.log(\"popping integer but double is found\");\n        }\n\n        if (Math.floor(p1.d) === p1.d) {\n          if (DEBUG) {\n            console.log(\"...altough it's an integer\");\n          }\n\n          n = p1.d;\n        }\n\n    }\n\n    restore();\n    return n;\n  };\n\n  print_double = function print_double(p, flag) {\n    var accumulator, buf;\n    accumulator = \"\";\n    buf = doubleToReasonableString(p.d);\n\n    if (flag === 1 && buf === '-') {\n      accumulator += print_str(buf + 1);\n    } else {\n      accumulator += print_str(buf);\n    }\n\n    return accumulator;\n  };\n\n  bignum_scan_integer = function bignum_scan_integer(s) {\n    var a, scounter, sign_;\n    save();\n    scounter = 0;\n    sign_ = s[scounter];\n\n    if (sign_ === '+' || sign_ === '-') {\n      scounter++;\n    }\n\n    a = bigInt(s.substring(scounter));\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n\n    if (sign_ === '-') {\n      negate();\n    }\n\n    return restore();\n  };\n\n  bignum_scan_float = function bignum_scan_float(s) {\n    return push_double(parseFloat(s));\n  };\n\n  print_number = function print_number(p, signed) {\n    var aAsString, accumulator, buf, denominatorString;\n    accumulator = \"\";\n    denominatorString = \"\";\n    buf = \"\";\n\n    switch (p.k) {\n      case NUM:\n        aAsString = p.q.a.toString();\n\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n\n        if (printMode === PRINTMODE_LATEX && isfraction(p)) {\n          aAsString = \"\\\\frac{\" + aAsString + \"}{\";\n        }\n\n        accumulator += aAsString;\n\n        if (isfraction(p)) {\n          if (printMode !== PRINTMODE_LATEX) {\n            accumulator += \"/\";\n          }\n\n          denominatorString = p.q.b.toString();\n\n          if (printMode === PRINTMODE_LATEX) {\n            denominatorString += \"}\";\n          }\n\n          accumulator += denominatorString;\n        }\n\n        break;\n\n      case DOUBLE:\n        aAsString = doubleToReasonableString(p.d);\n\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n\n        accumulator += aAsString;\n    }\n\n    return accumulator;\n  };\n\n  gcd_numbers = function gcd_numbers() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mgcd(p1.q.a, p2.q.a);\n    p3.q.b = mgcd(p1.q.b, p2.q.b);\n    p3.q.a = setSignTo(p3.q.a, 1);\n    push(p3);\n    return restore();\n  };\n\n  pop_double = function pop_double() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n\n    switch (p1.k) {\n      case NUM:\n        d = convert_rational_to_double(p1);\n        break;\n\n      case DOUBLE:\n        d = p1.d;\n        break;\n\n      default:\n        d = 0.0;\n    }\n\n    restore();\n    return d;\n  };\n\n  bignum_float = function bignum_float() {\n    var d;\n    d = 0.0;\n    d = convert_rational_to_double(pop());\n    return push_double(d);\n  };\n\n  bignum_factorial = function bignum_factorial(n) {\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = __factorial(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  __factorial = function __factorial(n) {\n    var a, b, i, o, ref, t;\n    i = 0;\n\n    if (n === 0 || n === 1) {\n      a = bigInt(1);\n      return a;\n    }\n\n    a = bigInt(2);\n    b = bigInt(0);\n\n    if (3 <= n) {\n      for (i = o = 3, ref = n; 3 <= ref ? o <= ref : o >= ref; i = 3 <= ref ? ++o : --o) {\n        b = bigInt(i);\n        t = mmul(a, b);\n        a = t;\n      }\n    }\n\n    return a;\n  };\n\n  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];\n\n  mp_set_bit = function mp_set_bit(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] |= mask[k % 32];\n  };\n\n  mp_clr_bit = function mp_clr_bit(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] &= ~mask[k % 32];\n  };\n\n  mshiftright = function mshiftright(a) {\n    return a = a.shiftRight();\n  };\n\n  Eval_binomial = function Eval_binomial() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return binomial();\n  };\n\n  binomial = function binomial() {\n    save();\n    ybinomial();\n    return restore();\n  };\n\n  ybinomial = function ybinomial() {\n    p2 = pop();\n    p1 = pop();\n\n    if (BINOM_check_args() === 0) {\n      push(zero);\n      return;\n    }\n\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    return divide();\n  };\n\n  BINOM_check_args = function BINOM_check_args() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n  /* ceiling =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  \n  Returns the smallest integer not less than x.\n   */\n\n\n  Eval_ceiling = function Eval_ceiling() {\n    push(cadr(p1));\n    Eval();\n    return ceiling();\n  };\n\n  ceiling = function ceiling() {\n    save();\n    yyceiling();\n    return restore();\n  };\n\n  yyceiling = function yyceiling() {\n    var d, doNothing;\n    d = 0.0;\n    p1 = pop();\n\n    if (!isNumericAtom(p1)) {\n      push_symbol(CEILING);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.ceil(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n\n    if (isnegativenumber(p1)) {\n      return doNothing = 1;\n    } else {\n      push_integer(1);\n      return add();\n    }\n  };\n  /* choose =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  n,k\n  \n  General description\n  -------------------\n  \n  Returns the number of combinations of n items taken k at a time.\n  \n  For example, the number of five card hands is choose(52,5)\n  \n  ```\n                            n!\n        choose(n,k) = -------------\n                       k! (n - k)!\n  ```\n   */\n\n\n  Eval_choose = function Eval_choose() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return choose();\n  };\n\n  choose = function choose() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (choose_check_args() === 0) {\n      push_integer(0);\n      restore();\n      return;\n    }\n\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    divide();\n    return restore();\n  };\n\n  choose_check_args = function choose_check_args() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n  /* circexp =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  \n  Returns expression x with circular and hyperbolic functions converted to exponential forms. Sometimes this will simplify an expression.\n   */\n\n\n  Eval_circexp = function Eval_circexp() {\n    push(cadr(p1));\n    Eval();\n\n    _circexp();\n\n    return Eval();\n  };\n\n  _circexp = function circexp() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      expcos();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      expsin();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(TAN)) {\n      p1 = cadr(p1);\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      exponential();\n      p2 = pop();\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      negate();\n      exponential();\n      p3 = pop();\n      push(p3);\n      push(p2);\n      subtract();\n      push(imaginaryunit);\n      multiply();\n      push(p2);\n      push(p3);\n      add();\n      divide();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(COSH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      add();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(SINH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      subtract();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(TANH)) {\n      p1 = cadr(p1);\n      push(p1);\n      push_integer(2);\n      multiply();\n      exponential();\n      p1 = pop();\n      push(p1);\n      push_integer(1);\n      subtract();\n      push(p1);\n      push_integer(1);\n      add();\n      divide();\n      restore();\n      return;\n    }\n\n    if (iscons(p1)) {\n      h = tos;\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _circexp();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      restore();\n      return;\n    }\n\n    if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n\n      for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n\n        _circexp();\n\n        p1.tensor.elem[i] = pop();\n      }\n\n      push(p1);\n      restore();\n      return;\n    }\n\n    push(p1);\n    return restore();\n  };\n  /* clearall =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  \n  General description\n  -------------------\n  \n  Completely wipes all variables from the environment.\n   */\n\n\n  Eval_clearall = function Eval_clearall() {\n    do_clearall();\n    return push(symbol(NIL));\n  };\n\n  do_clearall = function do_clearall() {\n    if (test_flag === 0) {\n      clear_term();\n    }\n\n    do_clearPatterns();\n    clear_symbols();\n    defn();\n    return codeGen = false;\n  };\n\n  clearall = function clearall() {\n    return run(\"clearall\");\n  };\n\n  clearRenamedVariablesToAvoidBindingToExternalScope = function clearRenamedVariablesToAvoidBindingToExternalScope() {\n    var i, o, ref, results;\n    results = [];\n\n    for (i = o = 0, ref = symtab.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (symtab[i].printname.indexOf(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\") !== -1) {\n        symtab[i].k = SYM;\n        symtab[i].printname = \"\";\n        binding[i] = symtab[i];\n        results.push(isSymbolReclaimable[i] = true);\n      } else {\n        results.push(void 0);\n      }\n    }\n\n    return results;\n  };\n  /* clear =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  \n  Completely wipes a variable from the environment (while doing x = quote(x) just unassigns it).\n   */\n\n\n  Eval_clear = function Eval_clear() {\n    var indexFound, variableToBeCleared;\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      variableToBeCleared = car(p2);\n\n      if (variableToBeCleared.k !== SYM) {\n        stop(\"symbol error\");\n      }\n\n      indexFound = symtab.indexOf(variableToBeCleared);\n      symtab[indexFound].k = SYM;\n      symtab[indexFound].printname = \"\";\n      binding[indexFound] = symtab[indexFound];\n      isSymbolReclaimable[indexFound] = true;\n      p2 = cdr(p2);\n    }\n\n    return push(symbol(NIL));\n  };\n  /*\n   Convert complex z to clock form\n  \n    Input:    push  z\n  \n    Output:    Result on stack\n  \n    clock(z) = abs(z) * (-1) ^ (arg(z) / pi)\n  \n    For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)\n   */\n\n\n  DEBUG_CLOCKFORM = false;\n\n  Eval_clock = function Eval_clock() {\n    push(cadr(p1));\n    Eval();\n    return clockform();\n  };\n\n  clockform = function clockform() {\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: abs of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p1);\n    arg();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: arg of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push(symbol(PI));\n    }\n\n    divide();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: divide : \" + stack[tos - 1]);\n    }\n\n    list(3);\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: power : \" + stack[tos - 1]);\n    }\n\n    multiply();\n\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: multiply : \" + stack[tos - 1]);\n    }\n    /*\n    p1 = pop()\n    push(p1)\n    abs()\n    push(symbol(E))\n    push(p1)\n    arg()\n    push(imaginaryunit)\n    multiply()\n    power()\n    multiply()\n     */\n\n\n    return restore();\n  };\n  /* coeff =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  p,x,n\n  \n  General description\n  -------------------\n  Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.\n   */\n\n\n  Eval_coeff = function Eval_coeff() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n\n    if (p3 === symbol(NIL)) {\n      p3 = p2;\n      p2 = symbol(SYMBOL_X);\n    }\n\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    return filter();\n  };\n\n  coeff = function coeff() {\n    var h, n, prev_expanding;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    while (1) {\n      push(p1);\n      push(p2);\n      push(zero);\n\n      _subst();\n\n      Eval();\n      p3 = pop();\n      push(p3);\n      push(p1);\n      push(p3);\n      subtract();\n      p1 = pop();\n\n      if (equal(p1, zero)) {\n        n = tos - h;\n        restore();\n        return n;\n      }\n\n      push(p1);\n      push(p2);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      p1 = pop();\n    }\n  };\n  /* cofactor =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m,i,j\n  \n  General description\n  -------------------\n  Cofactor of a matrix component.\n  Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).\n  This function returns c[i,j].\n   */\n\n\n  Eval_cofactor = function Eval_cofactor() {\n    var doNothing, i, j, n;\n    i = 0;\n    j = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n\n    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"cofactor: 1st arg: square matrix expected\");\n    }\n\n    n = p2.tensor.dim[0];\n    push(caddr(p1));\n    Eval();\n    i = pop_integer();\n\n    if (i < 1 || i > n) {\n      stop(\"cofactor: 2nd arg: row index expected\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (j < 1 || j > n) {\n      stop(\"cofactor: 3rd arg: column index expected\");\n    }\n\n    return cofactor(p2, n, i - 1, j - 1);\n  };\n\n  cofactor = function cofactor(p, n, row, col) {\n    var i, i1, j, o, ref, ref1;\n    i = 0;\n    j = 0;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i !== row && j !== col) {\n          push(p.tensor.elem[n * i + j]);\n        }\n      }\n    }\n\n    determinant(n - 1);\n\n    if ((row + col) % 2) {\n      return negate();\n    }\n  };\n\n  Eval_condense = function Eval_condense() {\n    push(cadr(p1));\n    Eval();\n    return Condense();\n  };\n\n  Condense = function Condense() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    save();\n    yycondense();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yycondense = function yycondense() {\n    p1 = pop();\n\n    if (car(p1) !== symbol(ADD)) {\n      push(p1);\n      return;\n    }\n\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply_noexpand();\n      add();\n      p3 = cdr(p3);\n    }\n\n    yyexpand();\n    push(p2);\n    return divide();\n  };\n  /* conj =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  z\n  \n  General description\n  -------------------\n  Returns the complex conjugate of z.\n   */\n\n\n  Eval_conj = function Eval_conj() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    push(p1);\n\n    if (!_Find(p1, imaginaryunit)) {\n      polar();\n      conjugate();\n      return clockform();\n    } else {\n      return conjugate();\n    }\n  };\n\n  conjugate = function conjugate() {\n    push(imaginaryunit);\n    push(imaginaryunit);\n    negate();\n\n    _subst();\n\n    return Eval();\n  };\n\n  consCount = 0;\n\n  cons = function cons() {\n    var p;\n    consCount++;\n\n    if (DEBUG) {\n      console.log(\"cons tos: \" + tos + \" # \" + consCount);\n    }\n\n    p = new U();\n    p.k = CONS;\n    p.cons.cdr = pop();\n\n    if (p === p.cons.cdr) {\n      debugger;\n      console.log(\"something wrong p == its cdr\");\n    }\n\n    p.cons.car = pop();\n    /*\n    console.log \"cons new cdr.k = \" + p.cons.cdr.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.cdr\n    console.log \"cons new car.k = \" + p.cons.car.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.car\n     */\n\n    return push(p);\n  };\n  /* contract =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,i,j\n  \n  General description\n  -------------------\n  Contract across tensor indices i.e. returns \"a\" summed over indices i and j.\n  If i and j are omitted then 1 and 2 are used.\n  contract(m) is equivalent to the trace of matrix m.\n   */\n\n\n  Eval_contract = function Eval_contract() {\n    push(cadr(p1));\n    Eval();\n\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n\n    return contract();\n  };\n\n  contract = function contract() {\n    save();\n    yycontract();\n    return restore();\n  };\n\n  yycontract = function yycontract() {\n    var a, ai, an, b, h, i, i1, j, j1, k, l, l1, m, m1, n, n1, ndim, nelem, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    n = 0;\n    ndim = 0;\n    nelem = 0;\n    ai = [];\n    an = [];\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"contract: tensor expected, 1st arg is not a tensor\");\n      }\n\n      push(zero);\n      return;\n    }\n\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    ndim = p1.tensor.ndim;\n\n    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {\n      stop(\"contract: index out of range\");\n    }\n\n    l--;\n    m--;\n    n = p1.tensor.dim[l];\n    nelem = 1;\n\n    for (i = o = 0, ref = ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (i !== l && i !== m) {\n        nelem *= p1.tensor.dim[i];\n      }\n    }\n\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - 2;\n    j = 0;\n\n    for (i = i1 = 0, ref1 = ndim; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      if (i !== l && i !== m) {\n        p2.tensor.dim[j++] = p1.tensor.dim[i];\n      }\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n\n    for (i = j1 = 0, ref2 = ndim; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n\n    for (i = l1 = 0, ref3 = nelem; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      push(zero);\n\n      for (j = m1 = 0, ref4 = n; 0 <= ref4 ? m1 < ref4 : m1 > ref4; j = 0 <= ref4 ? ++m1 : --m1) {\n        ai[l] = j;\n        ai[m] = j;\n        h = 0;\n\n        for (k = n1 = 0, ref5 = ndim; 0 <= ref5 ? n1 < ref5 : n1 > ref5; k = 0 <= ref5 ? ++n1 : --n1) {\n          h = h * an[k] + ai[k];\n        }\n\n        push(a[h]);\n        add();\n      }\n\n      b[i] = pop();\n\n      for (j = o1 = ref6 = ndim - 1; ref6 <= 0 ? o1 <= 0 : o1 >= 0; j = ref6 <= 0 ? ++o1 : --o1) {\n        if (j === l || j === m) {\n          continue;\n        }\n\n        if (++ai[j] < an[j]) {\n          break;\n        }\n\n        ai[j] = 0;\n      }\n    }\n\n    if (nelem === 1) {\n      return push(b[0]);\n    } else {\n      return push(p2);\n    }\n  };\n  /* cos =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the cosine of x.\n   */\n\n\n  Eval_cos = function Eval_cos() {\n    push(cadr(p1));\n    Eval();\n    return cosine();\n  };\n\n  cosine = function cosine() {\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      cosine_of_angle_sum();\n    } else {\n      cosine_of_angle();\n    }\n\n    return restore();\n  };\n\n  cosine_of_angle_sum = function cosine_of_angle_sum() {\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      p4 = car(p2);\n\n      if (isnpi(p4)) {\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        cosine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        sine();\n        push(p4);\n        sine();\n        multiply();\n        subtract();\n        return;\n      }\n\n      p2 = cdr(p2);\n    }\n\n    return cosine_of_angle();\n  };\n\n  cosine_of_angle = function cosine_of_angle() {\n    var d, n;\n\n    if (car(p1) === symbol(ARCCOS)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.cos(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    if (car(p1) === symbol(ARCTAN)) {\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      return;\n    }\n\n    push(p1);\n    push_integer(180);\n    multiply();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    divide();\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push(symbol(COS));\n      push(p1);\n      list(2);\n      return;\n    }\n\n    switch (n % 360) {\n      case 90:\n      case 270:\n        return push_integer(0);\n\n      case 60:\n      case 300:\n        return push_rational(1, 2);\n\n      case 120:\n      case 240:\n        return push_rational(-1, 2);\n\n      case 45:\n      case 315:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 135:\n      case 225:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 30:\n      case 330:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 150:\n      case 210:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 0:\n        return push_integer(1);\n\n      case 180:\n        return push_integer(-1);\n\n      default:\n        push(symbol(COS));\n        push(p1);\n        return list(2);\n    }\n  };\n  /* cosh =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the hyperbolic cosine of x\n  \n  ```\n              exp(x) + exp(-x)\n    cosh(x) = ----------------\n                     2\n  ```\n   */\n\n\n  Eval_cosh = function Eval_cosh() {\n    push(cadr(p1));\n    Eval();\n    return ycosh();\n  };\n\n  ycosh = function ycosh() {\n    save();\n    yycosh();\n    return restore();\n  };\n\n  yycosh = function yycosh() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCCOSH)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.cosh(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n\n    push_symbol(COSH);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_decomp = function Eval_decomp() {\n    var h;\n    save();\n    console.log(\"Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!\");\n    h = tos;\n    push(symbol(NIL));\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n\n    _decomp(false);\n\n    list(tos - h);\n    return restore();\n  };\n\n  pushTryNotToDuplicate = function pushTryNotToDuplicate(toBePushed) {\n    if (tos > 0) {\n      if (DEBUG) {\n        console.log(\"comparing \" + toBePushed + \" to: \" + stack[tos - 1]);\n      }\n\n      if (equal(toBePushed, stack[tos - 1])) {\n        if (DEBUG) {\n          console.log(\"skipping \" + toBePushed + \" because it's already on stack \");\n        }\n\n        return;\n      }\n    }\n\n    return push(toBePushed);\n  };\n\n  _decomp = function decomp(generalTransform) {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (DEBUG) {\n      console.log(\"DECOMPOSING \" + p1);\n    }\n\n    if (generalTransform) {\n      if (!iscons(p1)) {\n        if (DEBUG) {\n          console.log(\" ground thing: \" + p1);\n        }\n\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    } else {\n      if (_Find(p1, p2) === 0) {\n        if (DEBUG) {\n          console.log(\" entire expression is constant\");\n        }\n\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    }\n\n    if (isadd(p1)) {\n      decomp_sum(generalTransform);\n      restore();\n      return;\n    }\n\n    if (ismultiply(p1)) {\n      decomp_product(generalTransform);\n      restore();\n      return;\n    }\n\n    if (DEBUG) {\n      console.log(\" naive decomp\");\n    }\n\n    p3 = cdr(p1);\n\n    if (DEBUG) {\n      console.log(\"startig p3: \" + p3);\n    }\n\n    while (iscons(p3)) {\n      if (generalTransform) {\n        push(car(p3));\n      }\n\n      if (DEBUG) {\n        console.log(\"recursive decomposition\");\n      }\n\n      push(car(p3));\n\n      if (DEBUG) {\n        console.log(\"car(p3): \" + car(p3));\n      }\n\n      push(p2);\n\n      if (DEBUG) {\n        console.log(\"p2: \" + p2);\n      }\n\n      _decomp(generalTransform);\n\n      p3 = cdr(p3);\n    }\n\n    return restore();\n  };\n\n  decomp_sum = function decomp_sum(generalTransform) {\n    var h;\n\n    if (DEBUG) {\n      console.log(\" decomposing the sum \");\n    }\n\n    h = 0;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n\n        _decomp(generalTransform);\n      }\n\n      p3 = cdr(p3);\n    }\n\n    h = tos;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n\n      p3 = cdr(p3);\n    }\n\n    if (tos - h) {\n      add_all(tos - h);\n      p3 = pop();\n      pushTryNotToDuplicate(p3);\n      push(p3);\n      return negate();\n    }\n  };\n\n  decomp_product = function decomp_product(generalTransform) {\n    var h;\n\n    if (DEBUG) {\n      console.log(\" decomposing the product \");\n    }\n\n    h = 0;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n\n        _decomp(generalTransform);\n      }\n\n      p3 = cdr(p3);\n    }\n\n    h = tos;\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      if (_Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n\n      p3 = cdr(p3);\n    }\n\n    if (tos - h) {\n      return multiply_all(tos - h);\n    }\n  };\n\n  define_user_function = function define_user_function() {\n    p3 = caadr(p1);\n    p4 = cdadr(p1);\n    p5 = caddr(p1);\n\n    if (!issymbol(p3)) {\n      stop(\"function name?\");\n    }\n\n    if (car(p5) === symbol(EVAL)) {\n      push(cadr(p5));\n      Eval();\n      p5 = pop();\n    }\n\n    push_symbol(FUNCTION);\n    push(p5);\n    push(p4);\n    list(3);\n    p5 = pop();\n    set_binding(p3, p5);\n    return push_symbol(NIL);\n  };\n\n  Eval_function_reference = function Eval_function_reference() {\n    return push(p1);\n  };\n  /* defint =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  f,x,a,b[,y,c,d...]\n  \n  General description\n  -------------------\n  Returns the definite integral of f with respect to x evaluated from \"a\" to b.\n  The argument list can be extended for multiple integrals (or \"iterated\n  integrals\"), for example a double integral (which can represent for\n  example a volume under a surface), or a triple integral, etc. For\n  example, defint(f,x,a,b,y,c,d).\n   */\n\n\n  Eval_defint = function Eval_defint() {\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    p1 = cddr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p3 = pop();\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p4 = pop();\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p5 = pop();\n      push(p2);\n      push(p3);\n      integral();\n      p2 = pop();\n      push(p2);\n      push(p3);\n      push(p5);\n\n      _subst();\n\n      Eval();\n      push(p2);\n      push(p3);\n      push(p4);\n\n      _subst();\n\n      Eval();\n      subtract();\n      p2 = pop();\n    }\n\n    return push(p2);\n  };\n  /* deg =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  p,x\n  \n  General description\n  -------------------\n  Returns the degree of polynomial p(x).\n   */\n\n\n  Eval_degree = function Eval_degree() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n\n    return degree();\n  };\n\n  degree = function degree() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = zero;\n\n    _yydegree(p1);\n\n    push(p3);\n    return restore();\n  };\n\n  _yydegree = function yydegree(p) {\n    var results;\n\n    if (equal(p, p2)) {\n      if (isZeroAtomOrTensor(p3)) {\n        return p3 = one;\n      }\n    } else if (car(p) === symbol(POWER)) {\n      if (equal(cadr(p), p2) && isNumericAtom(caddr(p)) && lessp(p3, caddr(p))) {\n        return p3 = caddr(p);\n      }\n    } else if (iscons(p)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        _yydegree(car(p));\n\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    }\n  };\n  /* denominator =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Returns the denominator of expression x.\n   */\n\n\n  Eval_denominator = function Eval_denominator() {\n    push(cadr(p1));\n    Eval();\n    return _denominator();\n  };\n\n  _denominator = function denominator() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n\n        _denominator();\n\n        theArgument = cdr(theArgument);\n      }\n\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_denominator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      push(theArgument);\n      return reciprocate();\n    } else {\n      return push(one);\n    }\n  };\n\n  Eval_derivative = function Eval_derivative() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n\n    while (1) {\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n\n        if (isNaN(n)) {\n          stop(\"nth derivative: check n\");\n        }\n      } else {\n        n = 1;\n      }\n\n      push(p3);\n\n      if (n >= 0) {\n        for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          derivative();\n        }\n      } else {\n        n = -n;\n\n        for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          integral();\n        }\n      }\n\n      p3 = pop();\n\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n\n        if (p5 === symbol(NIL)) {\n          break;\n        }\n\n        if (isNumericAtom(p5)) {\n          doNothing = 1;\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop();\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n      }\n    }\n\n    return push(p3);\n  };\n\n  derivative = function derivative() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isNumericAtom(p2)) {\n      stop(\"undefined function\");\n    }\n\n    if (istensor(p1)) {\n      if (istensor(p2)) {\n        d_tensor_tensor();\n      } else {\n        d_tensor_scalar();\n      }\n    } else {\n      if (istensor(p2)) {\n        d_scalar_tensor();\n      } else {\n        d_scalar_scalar();\n      }\n    }\n\n    return restore();\n  };\n\n  d_scalar_scalar = function d_scalar_scalar() {\n    if (issymbol(p2)) {\n      return d_scalar_scalar_1();\n    } else {\n      push(p1);\n      push(p2);\n      push(symbol(SECRETX));\n\n      _subst();\n\n      push(symbol(SECRETX));\n      derivative();\n      push(symbol(SECRETX));\n      push(p2);\n      return _subst();\n    }\n  };\n\n  d_scalar_scalar_1 = function d_scalar_scalar_1() {\n    if (equal(p1, p2)) {\n      push(one);\n      return;\n    }\n\n    if (!iscons(p1)) {\n      push(zero);\n      return;\n    }\n\n    if (isadd(p1)) {\n      dsum();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      dproduct();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER)) {\n      dpower();\n      return;\n    }\n\n    if (car(p1) === symbol(DERIVATIVE)) {\n      dd();\n      return;\n    }\n\n    if (car(p1) === symbol(LOG)) {\n      dlog();\n      return;\n    }\n\n    if (car(p1) === symbol(SIN)) {\n      dsin();\n      return;\n    }\n\n    if (car(p1) === symbol(COS)) {\n      dcos();\n      return;\n    }\n\n    if (car(p1) === symbol(TAN)) {\n      dtan();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCSIN)) {\n      darcsin();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCCOS)) {\n      darccos();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCTAN)) {\n      darctan();\n      return;\n    }\n\n    if (car(p1) === symbol(SINH)) {\n      dsinh();\n      return;\n    }\n\n    if (car(p1) === symbol(COSH)) {\n      dcosh();\n      return;\n    }\n\n    if (car(p1) === symbol(TANH)) {\n      dtanh();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCSINH)) {\n      darcsinh();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCCOSH)) {\n      darccosh();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCTANH)) {\n      darctanh();\n      return;\n    }\n\n    if (car(p1) === symbol(ABS)) {\n      dabs();\n      return;\n    }\n\n    if (car(p1) === symbol(SGN)) {\n      dsgn();\n      return;\n    }\n\n    if (car(p1) === symbol(HERMITE)) {\n      dhermite();\n      return;\n    }\n\n    if (car(p1) === symbol(ERF)) {\n      derf();\n      return;\n    }\n\n    if (car(p1) === symbol(ERFC)) {\n      derfc();\n      return;\n    }\n\n    if (car(p1) === symbol(BESSELJ)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbesselj0();\n      } else {\n        dbesseljn();\n      }\n\n      return;\n    }\n\n    if (car(p1) === symbol(BESSELY)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbessely0();\n      } else {\n        dbesselyn();\n      }\n\n      return;\n    }\n\n    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {\n      derivative_of_integral();\n      return;\n    }\n\n    return dfunction();\n  };\n\n  dsum = function dsum() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      derivative();\n      p1 = cdr(p1);\n    }\n\n    return add_all(tos - h);\n  };\n\n  dproduct = function dproduct() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = length(p1) - 1;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p3 = cdr(p1);\n\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        push(car(p3));\n\n        if (i === j) {\n          push(p2);\n          derivative();\n        }\n\n        p3 = cdr(p3);\n      }\n\n      multiply_all(n);\n    }\n\n    return add_all(n);\n  };\n\n  dpower = function dpower() {\n    push(caddr(p1));\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    push(cadr(p1));\n    logarithm();\n    push(caddr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    add();\n    push(p1);\n    return multiply();\n  };\n\n  dlog = function dlog() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    return divide();\n  };\n\n  dd = function dd() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    p3 = pop();\n\n    if (car(p3) === symbol(DERIVATIVE)) {\n      push_symbol(DERIVATIVE);\n      push_symbol(DERIVATIVE);\n      push(cadr(p3));\n\n      if (lessp(caddr(p3), caddr(p1))) {\n        push(caddr(p3));\n        list(3);\n        push(caddr(p1));\n      } else {\n        push(caddr(p1));\n        list(3);\n        push(caddr(p3));\n      }\n\n      return list(3);\n    } else {\n      push(p3);\n      push(caddr(p1));\n      return derivative();\n    }\n  };\n\n  dfunction = function dfunction() {\n    p3 = cdr(p1);\n\n    if (p3 === symbol(NIL) || _Find(p3, p2)) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(zero);\n    }\n  };\n\n  dsin = function dsin() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    return multiply();\n  };\n\n  dcos = function dcos() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sine();\n    multiply();\n    return negate();\n  };\n\n  dtan = function dtan() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsin = function darcsin() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccos = function darccos() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    multiply();\n    return negate();\n  };\n\n  darctan = function darctan() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    add();\n    inverse();\n    multiply();\n    return simplify();\n  };\n\n  dsinh = function dsinh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    return multiply();\n  };\n\n  dcosh = function dcosh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ysinh();\n    return multiply();\n  };\n\n  dtanh = function dtanh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsinh = function darcsinh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccosh = function darccosh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darctanh = function darctanh() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    inverse();\n    return multiply();\n  };\n\n  dabs = function dabs() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sgn();\n    return multiply();\n  };\n\n  dsgn = function dsgn() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    dirac();\n    multiply();\n    push_integer(2);\n    return multiply();\n  };\n\n  dhermite = function dhermite() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(2);\n    push(caddr(p1));\n    multiply();\n    multiply();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    hermite();\n    return multiply();\n  };\n\n  derf = function derf() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  derfc = function derfc() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(-2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  dbesselj0 = function dbesselj0() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesseljn = function dbesseljn() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    besselj();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    besselj();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  dbessely0 = function dbessely0() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesselyn = function dbesselyn() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    bessely();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    bessely();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  derivative_of_integral = function derivative_of_integral() {\n    return push(cadr(p1));\n  };\n  /* det =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Returns the determinant of matrix m.\n  Uses Gaussian elimination for numerical matrices.\n  \n  Example:\n  \n    det(((1,2),(3,4)))\n    > -2\n   */\n\n\n  DET_check_arg = function DET_check_arg() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  det = function det() {\n    var a, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    save();\n    p1 = pop();\n\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    n = p1.tensor.nelem;\n    a = p1.tensor.elem;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtom(a[i])) {\n        break;\n      }\n    }\n\n    if (i === n) {\n      yydetg();\n    } else {\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n      }\n\n      determinant(p1.tensor.dim[0]);\n    }\n\n    return restore();\n  };\n\n  determinant = function determinant(n) {\n    var a, breakFromOutherWhile, h, i, i1, j, k, o, q, ref, ref1, s, sign_, t;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    q = 0;\n    s = 0;\n    sign_ = 0;\n    t = 0;\n    a = [];\n    h = tos - n * n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      a[i] = i;\n      a[i + n] = 0;\n      a[i + n + n] = 1;\n    }\n\n    sign_ = 1;\n    push(zero);\n\n    while (1) {\n      if (sign_ === 1) {\n        push_integer(1);\n      } else {\n        push_integer(-1);\n      }\n\n      for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        k = n * a[i] + i;\n        push(stack[h + k]);\n        multiply();\n      }\n\n      add();\n      j = n - 1;\n      s = 0;\n      breakFromOutherWhile = false;\n\n      while (1) {\n        q = a[n + j] + a[n + n + j];\n\n        if (q < 0) {\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n\n        if (q === j + 1) {\n          if (j === 0) {\n            breakFromOutherWhile = true;\n            break;\n          }\n\n          s++;\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n\n        break;\n      }\n\n      if (breakFromOutherWhile) {\n        break;\n      }\n\n      t = a[j - a[n + j] + s];\n      a[j - a[n + j] + s] = a[j - q + s];\n      a[j - q + s] = t;\n      a[n + j] = q;\n      sign_ = -sign_;\n    }\n\n    stack[h] = stack[tos - 1];\n    return moveTos(h + 1);\n  };\n\n  detg = function detg() {\n    save();\n    p1 = pop();\n\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    yydetg();\n    return restore();\n  };\n\n  yydetg = function yydetg() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n\n    for (i = o = 0, ref = n * n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(p1.tensor.elem[i]);\n    }\n\n    lu_decomp(n);\n    moveTos(tos - n * n);\n    return push(p1);\n  };\n\n  M = function M(h, n, i, j) {\n    return stack[h + n * i + j];\n  };\n\n  setM = function setM(h, n, i, j, value) {\n    return stack[h + n * i + j] = value;\n  };\n\n  lu_decomp = function lu_decomp(n) {\n    var d, h, i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;\n    d = 0;\n    h = 0;\n    i = 0;\n    j = 0;\n    h = tos - n * n;\n    p1 = one;\n\n    for (d = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {\n      if (equal(M(h, n, d, d), zero)) {\n        for (i = i1 = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(M(h, n, i, d), zero)) {\n            break;\n          }\n        }\n\n        if (i === n) {\n          p1 = zero;\n          break;\n        }\n\n        for (j = j1 = ref3 = d, ref4 = n; ref3 <= ref4 ? j1 < ref4 : j1 > ref4; j = ref3 <= ref4 ? ++j1 : --j1) {\n          p2 = M(h, n, d, j);\n          setM(h, n, d, j, M(h, n, i, j));\n          setM(h, n, i, j, p2);\n        }\n\n        push(p1);\n        negate();\n        p1 = pop();\n      }\n\n      push(p1);\n      push(M(h, n, d, d));\n      multiply();\n      p1 = pop();\n\n      for (i = l1 = ref5 = d + 1, ref6 = n; ref5 <= ref6 ? l1 < ref6 : l1 > ref6; i = ref5 <= ref6 ? ++l1 : --l1) {\n        push(M(h, n, i, d));\n        push(M(h, n, d, d));\n        divide();\n        negate();\n        p2 = pop();\n        setM(h, n, i, d, zero);\n\n        for (j = m1 = ref7 = d + 1, ref8 = n; ref7 <= ref8 ? m1 < ref8 : m1 > ref8; j = ref7 <= ref8 ? ++m1 : --m1) {\n          push(M(h, n, d, j));\n          push(p2);\n          multiply();\n          push(M(h, n, i, j));\n          add();\n          setM(h, n, i, j, pop());\n        }\n      }\n    }\n\n    push(p1);\n    push(M(h, n, n - 1, n - 1));\n    multiply();\n    return p1 = pop();\n  };\n\n  Eval_dirac = function Eval_dirac() {\n    push(cadr(p1));\n    Eval();\n    return dirac();\n  };\n\n  dirac = function dirac() {\n    save();\n    ydirac();\n    return restore();\n  };\n\n  ydirac = function ydirac() {\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      if (p1.d === 0) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n\n    if (isrational(p1)) {\n      if (MZERO(mmul(p1.q.a, p1.q.b))) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n\n    if (car(p1) === symbol(POWER)) {\n      push_symbol(DIRAC);\n      push(cadr(p1));\n      list(2);\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push_symbol(DIRAC);\n      push(p1);\n      negate();\n      list(2);\n      return;\n    }\n\n    if (isnegativeterm(p1) || car(p1) === symbol(ADD) && isnegativeterm(cadr(p1))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    push_symbol(DIRAC);\n    push(p1);\n    return list(2);\n  };\n\n  divisors = function divisors() {\n    var h, i, n, o, ref, subsetOfStack;\n    i = 0;\n    h = 0;\n    n = 0;\n    save();\n    h = tos - 1;\n    divisors_onstack();\n    n = tos - h;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(_cmp_expr);\n    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  divisors_onstack = function divisors_onstack() {\n    var h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    h = tos;\n\n    if (isNumericAtom(p1)) {\n      push(p1);\n      factor_small_number();\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n\n      __factor_add();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      if (isNumericAtom(car(p1))) {\n        push(car(p1));\n        factor_small_number();\n        p1 = cdr(p1);\n      }\n\n      while (iscons(p1)) {\n        p2 = car(p1);\n\n        if (car(p2) === symbol(POWER)) {\n          push(cadr(p2));\n          push(caddr(p2));\n        } else {\n          push(p2);\n          push(one);\n        }\n\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(POWER)) {\n      push(cadr(p1));\n      push(caddr(p1));\n    } else {\n      push(p1);\n      push(one);\n    }\n\n    k = tos;\n    push(one);\n\n    _gen(h, k);\n\n    n = tos - k;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      stack[h + i] = stack[k + i];\n    }\n\n    moveTos(h + n);\n    return restore();\n  };\n\n  _gen = function gen(h, k) {\n    var expo, i, o, ref;\n    expo = 0;\n    i = 0;\n    save();\n    p1 = pop();\n\n    if (h === k) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    p2 = stack[h + 0];\n    p3 = stack[h + 1];\n    push(p3);\n    expo = pop_integer();\n\n    if (!isNaN(expo)) {\n      for (i = o = 0, ref = Math.abs(expo); 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n        push(p1);\n        push(p2);\n        push_integer(sign(expo) * i);\n        power();\n        multiply();\n\n        _gen(h + 2, k);\n      }\n    }\n\n    return restore();\n  };\n\n  __factor_add = function __factor_add() {\n    save();\n    p1 = pop();\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n\n    p2 = pop();\n\n    if (isplusone(p2)) {\n      push(p1);\n      push(one);\n      restore();\n      return;\n    }\n\n    if (isNumericAtom(p2)) {\n      push(p2);\n      factor_small_number();\n    } else if (car(p2) === symbol(MULTIPLY)) {\n      p3 = cdr(p2);\n\n      if (isNumericAtom(car(p3))) {\n        push(car(p3));\n        factor_small_number();\n      } else {\n        push(car(p3));\n        push(one);\n      }\n\n      p3 = cdr(p3);\n\n      while (iscons(p3)) {\n        push(car(p3));\n        push(one);\n        p3 = cdr(p3);\n      }\n    } else {\n      push(p2);\n      push(one);\n    }\n\n    push(p2);\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply();\n      add();\n      p3 = cdr(p3);\n    }\n\n    push(one);\n    return restore();\n  };\n\n  dpow = function dpow() {\n    var a, b, base, expo, result, theta;\n    a = 0.0;\n    b = 0.0;\n    base = 0.0;\n    expo = 0.0;\n    result = 0.0;\n    theta = 0.0;\n    expo = pop_double();\n    base = pop_double();\n\n    if (base === 0.0 && expo < 0.0) {\n      stop(\"divide by zero\");\n    }\n\n    if (base >= 0.0 || expo % 1.0 === 0.0) {\n      result = Math.pow(base, expo);\n      push_double(result);\n      return;\n    }\n\n    result = Math.pow(Math.abs(base), expo);\n    theta = Math.PI * expo;\n\n    if (expo % 0.5 === 0.0) {\n      a = 0.0;\n      b = Math.sin(theta);\n    } else {\n      a = Math.cos(theta);\n      b = Math.sin(theta);\n    }\n\n    push_double(a * result);\n    push_double(b * result);\n    push(imaginaryunit);\n    multiply();\n    return add();\n  };\n  /* eigen =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.\n  The eigenval function returns a matrix with the eigenvalues along the diagonal.\n  The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.\n  The eigen function does not return anything but stores the eigenvalue matrix in D\n  and the eigenvector matrix in Q.\n  \n  Input:    stack[tos - 1]    symmetric matrix\n  \n  Output:    D      diagnonal matrix\n        Q      eigenvector matrix\n  \n  D and Q have the property that\n  \n    A == dot(transpose(Q),D,Q)\n  \n  where A is the original matrix.\n  \n  The eigenvalues are on the diagonal of D.\n  The eigenvectors are row vectors in Q.\n  \n  The eigenvalue relation:\n  \n    A X = lambda X\n  \n  can be checked as follows:\n  \n    lambda = D[1,1]\n    X = Q[1]\n    dot(A,X) - lambda X\n  \n  Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.\n  \n  Enter:\n  \n       A = hilbert(3)\n  \n       eigen(A)\n  \n       lambda = D[1,1]\n  \n       X = Q[1]\n  \n       dot(A,X) - lambda X\n  \n  Result:\n  \n       -1.16435e-14\n   \n       -6.46705e-15\n   \n       -4.55191e-15\n  \n  Example 2: Check the relation A = QTDQ.\n  \n  Enter:\n  \n    A - dot(transpose(Q),D,Q)\n  \n  Result: \n  \n    6.27365e-12    -1.58236e-11   1.81902e-11\n   \n    -1.58236e-11   -1.95365e-11   2.56514e-12\n   \n    1.81902e-11    2.56514e-12    1.32627e-11\n   */\n\n\n  EIG_N = 0;\n  EIG_yydd = [];\n  EIG_yyqq = [];\n\n  Eval_eigen = function Eval_eigen() {\n    if (EIG_check_arg() === 0) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n\n    eigen(EIGEN);\n    p1 = usr_symbol(\"D\");\n    set_binding(p1, p2);\n    p1 = usr_symbol(\"Q\");\n    set_binding(p1, p3);\n    return push(symbol(NIL));\n  };\n  /* eigenval =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Compute eigenvalues of m. See \"eigen\" for more info.\n   */\n\n\n  Eval_eigenval = function Eval_eigenval() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVAL);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    eigen(EIGENVAL);\n    return push(p2);\n  };\n  /* eigenvec =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m\n  \n  General description\n  -------------------\n  Compute eigenvectors of m. See \"eigen\" for more info.\n   */\n\n\n  Eval_eigenvec = function Eval_eigenvec() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVEC);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    eigen(EIGENVEC);\n    return push(p3);\n  };\n\n  EIG_check_arg = function EIG_check_arg() {\n    var i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    push(cadr(p1));\n    Eval();\n\n    _yyfloat();\n\n    Eval();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      return 0;\n    }\n\n    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n\n    EIG_N = p1.tensor.dim[0];\n\n    for (i = o = 0, ref = EIG_N; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = EIG_N; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {\n          stop(\"eigen: matrix is not numerical\");\n        }\n      }\n    }\n\n    for (i = j1 = 0, ref2 = EIG_N - 1; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; ref3 <= ref4 ? l1 < ref4 : l1 > ref4; j = ref3 <= ref4 ? ++l1 : --l1) {\n        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {\n          stop(\"eigen: matrix is not symmetrical\");\n        }\n      }\n    }\n\n    return 1;\n  };\n\n  eigen = function eigen(op) {\n    var i, i1, j, j1, l1, m1, n1, o, o1, q1, r1, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;\n    i = 0;\n    j = 0;\n\n    for (i = o = 0, ref = EIG_N * EIG_N; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      EIG_yydd[i] = 0.0;\n    }\n\n    for (i = i1 = 0, ref1 = EIG_N * EIG_N; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      EIG_yyqq[i] = 0.0;\n    }\n\n    for (i = j1 = 0, ref2 = EIG_N; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;\n\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; ref3 <= ref4 ? l1 < ref4 : l1 > ref4; j = ref3 <= ref4 ? ++l1 : --l1) {\n        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;\n        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;\n      }\n    }\n\n    for (i = m1 = 0, ref5 = EIG_N; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i = 0 <= ref5 ? ++m1 : --m1) {\n      EIG_yyqq[EIG_N * i + i] = 1.0;\n\n      for (j = n1 = ref6 = i + 1, ref7 = EIG_N; ref6 <= ref7 ? n1 < ref7 : n1 > ref7; j = ref6 <= ref7 ? ++n1 : --n1) {\n        EIG_yyqq[EIG_N * i + j] = 0.0;\n        EIG_yyqq[EIG_N * j + i] = 0.0;\n      }\n    }\n\n    for (i = o1 = 0; o1 < 100; i = ++o1) {\n      if (step() === 0) {\n        break;\n      }\n    }\n\n    if (i === 100) {\n      printstr(\"\\nnote: eigen did not converge\\n\");\n    }\n\n    if (op === EIGEN || op === EIGENVAL) {\n      push(p1);\n      copy_tensor();\n      p2 = pop();\n\n      for (i = q1 = 0, ref8 = EIG_N; 0 <= ref8 ? q1 < ref8 : q1 > ref8; i = 0 <= ref8 ? ++q1 : --q1) {\n        for (j = r1 = 0, ref9 = EIG_N; 0 <= ref9 ? r1 < ref9 : r1 > ref9; j = 0 <= ref9 ? ++r1 : --r1) {\n          push_double(EIG_yydd[EIG_N * i + j]);\n          p2.tensor.elem[EIG_N * i + j] = pop();\n        }\n      }\n    }\n\n    if (op === EIGEN || op === EIGENVEC) {\n      push(p1);\n      copy_tensor();\n      p3 = pop();\n      results = [];\n\n      for (i = s1 = 0, ref10 = EIG_N; 0 <= ref10 ? s1 < ref10 : s1 > ref10; i = 0 <= ref10 ? ++s1 : --s1) {\n        results.push(function () {\n          var ref11, results1, t1;\n          results1 = [];\n\n          for (j = t1 = 0, ref11 = EIG_N; 0 <= ref11 ? t1 < ref11 : t1 > ref11; j = 0 <= ref11 ? ++t1 : --t1) {\n            push_double(EIG_yyqq[EIG_N * i + j]);\n            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());\n          }\n\n          return results1;\n        }());\n      }\n\n      return results;\n    }\n  };\n\n  step = function step() {\n    var count, i, i1, j, o, ref, ref1, ref2;\n    i = 0;\n    j = 0;\n    count = 0;\n\n    for (i = o = 0, ref = EIG_N - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = ref1 = i + 1, ref2 = EIG_N; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (EIG_yydd[EIG_N * i + j] !== 0.0) {\n          step2(i, j);\n          count++;\n        }\n      }\n    }\n\n    return count;\n  };\n\n  step2 = function step2(p, q) {\n    var c, cc, i1, j1, k, o, ref, ref1, ref2, s, ss, t, theta;\n    k = 0;\n    t = 0.0;\n    theta = 0.0;\n    c = 0.0;\n    cc = 0.0;\n    s = 0.0;\n    ss = 0.0;\n    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];\n    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));\n\n    if (theta < 0.0) {\n      t = -t;\n    }\n\n    c = 1.0 / Math.sqrt(t * t + 1.0);\n    s = t * c;\n\n    for (k = o = 0, ref = EIG_N; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {\n      cc = EIG_yydd[EIG_N * p + k];\n      ss = EIG_yydd[EIG_N * q + k];\n      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;\n    }\n\n    for (k = i1 = 0, ref1 = EIG_N; 0 <= ref1 ? i1 < ref1 : i1 > ref1; k = 0 <= ref1 ? ++i1 : --i1) {\n      cc = EIG_yydd[EIG_N * k + p];\n      ss = EIG_yydd[EIG_N * k + q];\n      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;\n      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;\n    }\n\n    for (k = j1 = 0, ref2 = EIG_N; 0 <= ref2 ? j1 < ref2 : j1 > ref2; k = 0 <= ref2 ? ++j1 : --j1) {\n      cc = EIG_yyqq[EIG_N * p + k];\n      ss = EIG_yyqq[EIG_N * q + k];\n      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;\n    }\n\n    EIG_yydd[EIG_N * p + q] = 0.0;\n    return EIG_yydd[EIG_N * q + p] = 0.0;\n  };\n  /* erf =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Authors\n  -------\n  philippe.billet@noos.fr\n  \n  Parameters\n  ----------\n  x\n  \n  General description\n  -------------------\n  Error function erf(x).\n  erf(-x)=erf(x)\n   */\n\n\n  Eval_erf = function Eval_erf() {\n    push(cadr(p1));\n    Eval();\n    return yerf();\n  };\n\n  yerf = function yerf() {\n    save();\n    yyerf();\n    return restore();\n  };\n\n  yyerf = function yyerf() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      d = 1.0 - erfc(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push_symbol(ERF);\n      push(p1);\n      negate();\n      list(2);\n      negate();\n      return;\n    }\n\n    push_symbol(ERF);\n    push(p1);\n    list(2);\n  };\n\n  Eval_erfc = function Eval_erfc() {\n    push(cadr(p1));\n    Eval();\n    return yerfc();\n  };\n\n  yerfc = function yerfc() {\n    save();\n    yyerfc();\n    return restore();\n  };\n\n  yyerfc = function yyerfc() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      d = erfc(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n\n    push_symbol(ERFC);\n    push(p1);\n    list(2);\n  };\n\n  erfc = function erfc(x) {\n    var ans, t, z;\n\n    if (x === 0) {\n      return 1.0;\n    }\n\n    t = 0.0;\n    z = 0.0;\n    ans = 0.0;\n    z = Math.abs(x);\n    t = 1.0 / (1.0 + 0.5 * z);\n    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));\n\n    if (x >= 0.0) {\n      return ans;\n    } else {\n      return 2.0 - ans;\n    }\n  };\n\n  Eval = function Eval() {\n    var willEvaluateAsFloats;\n    check_esc_flag();\n    save();\n    p1 = pop();\n\n    if (p1 == null) {\n      debugger;\n    }\n\n    if (!evaluatingAsFloats && _isfloating(p1)) {\n      willEvaluateAsFloats = true;\n      evaluatingAsFloats++;\n    }\n\n    switch (p1.k) {\n      case CONS:\n        Eval_cons();\n        break;\n\n      case NUM:\n        if (evaluatingAsFloats) {\n          push_double(convert_rational_to_double(p1));\n        } else {\n          push(p1);\n        }\n\n        break;\n\n      case DOUBLE:\n      case STR:\n        push(p1);\n        break;\n\n      case TENSOR:\n        Eval_tensor();\n        break;\n\n      case SYM:\n        Eval_sym();\n        break;\n\n      default:\n        stop(\"atom?\");\n    }\n\n    if (willEvaluateAsFloats) {\n      evaluatingAsFloats--;\n    }\n\n    return restore();\n  };\n\n  Eval_sym = function Eval_sym() {\n    var cycleString, i, o, positionIfSymbolAlreadyBeingEvaluated, ref, ref1;\n\n    if (iskeyword(p1)) {\n      push(p1);\n      push(symbol(LAST));\n      list(2);\n      Eval();\n      return;\n    } else if (p1 === symbol(PI) && evaluatingAsFloats) {\n      push_double(Math.PI);\n      return;\n    }\n\n    p2 = get_binding(p1);\n\n    if (DEBUG) {\n      console.log(\"looked up: \" + p1 + \" which contains: \" + p2);\n    }\n\n    push(p2);\n\n    if (p1 !== p2) {\n      positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);\n\n      if (positionIfSymbolAlreadyBeingEvaluated !== -1) {\n        cycleString = \"\";\n\n        for (i = o = ref = positionIfSymbolAlreadyBeingEvaluated, ref1 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n          cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i].printname + \" -> \";\n        }\n\n        cycleString += p1.printname;\n        stop(\"recursive evaluation of symbols: \" + cycleString);\n        return;\n      }\n\n      chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);\n      Eval();\n      return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();\n    }\n  };\n\n  Eval_cons = function Eval_cons() {\n    var cons_head;\n    cons_head = car(p1);\n\n    if (car(cons_head) === symbol(EVAL)) {\n      Eval_user_function();\n      return;\n    }\n\n    if (!issymbol(cons_head)) {\n      stop(\"cons?\");\n    }\n\n    switch (symnum(cons_head)) {\n      case ABS:\n        return Eval_abs();\n\n      case ADD:\n        return Eval_add();\n\n      case ADJ:\n        return Eval_adj();\n\n      case AND:\n        return Eval_and();\n\n      case ARCCOS:\n        return Eval_arccos();\n\n      case ARCCOSH:\n        return Eval_arccosh();\n\n      case ARCSIN:\n        return Eval_arcsin();\n\n      case ARCSINH:\n        return Eval_arcsinh();\n\n      case ARCTAN:\n        return Eval_arctan();\n\n      case ARCTANH:\n        return Eval_arctanh();\n\n      case ARG:\n        return Eval_arg();\n\n      case ATOMIZE:\n        return Eval_atomize();\n\n      case BESSELJ:\n        return Eval_besselj();\n\n      case BESSELY:\n        return Eval_bessely();\n\n      case BINDING:\n        return Eval_binding();\n\n      case BINOMIAL:\n        return Eval_binomial();\n\n      case CEILING:\n        return Eval_ceiling();\n\n      case CHECK:\n        return Eval_check();\n\n      case CHOOSE:\n        return Eval_choose();\n\n      case CIRCEXP:\n        return Eval_circexp();\n\n      case CLEAR:\n        return Eval_clear();\n\n      case CLEARALL:\n        return Eval_clearall();\n\n      case CLEARPATTERNS:\n        return Eval_clearpatterns();\n\n      case CLOCK:\n        return Eval_clock();\n\n      case COEFF:\n        return Eval_coeff();\n\n      case COFACTOR:\n        return Eval_cofactor();\n\n      case CONDENSE:\n        return Eval_condense();\n\n      case CONJ:\n        return Eval_conj();\n\n      case CONTRACT:\n        return Eval_contract();\n\n      case COS:\n        return Eval_cos();\n\n      case COSH:\n        return Eval_cosh();\n\n      case DECOMP:\n        return Eval_decomp();\n\n      case DEGREE:\n        return Eval_degree();\n\n      case DEFINT:\n        return Eval_defint();\n\n      case DENOMINATOR:\n        return Eval_denominator();\n\n      case DERIVATIVE:\n        return Eval_derivative();\n\n      case DET:\n        return Eval_det();\n\n      case DIM:\n        return Eval_dim();\n\n      case DIRAC:\n        return Eval_dirac();\n\n      case DIVISORS:\n        return Eval_divisors();\n\n      case DO:\n        return Eval_do();\n\n      case DOT:\n        return _Eval_inner();\n\n      case DRAW:\n        return Eval_draw();\n\n      case DSOLVE:\n        return Eval_dsolve();\n\n      case EIGEN:\n        return Eval_eigen();\n\n      case EIGENVAL:\n        return Eval_eigenval();\n\n      case EIGENVEC:\n        return Eval_eigenvec();\n\n      case ERF:\n        return Eval_erf();\n\n      case ERFC:\n        return Eval_erfc();\n\n      case EVAL:\n        return Eval_Eval();\n\n      case EXP:\n        return Eval_exp();\n\n      case EXPAND:\n        return Eval_expand();\n\n      case EXPCOS:\n        return Eval_expcos();\n\n      case EXPSIN:\n        return Eval_expsin();\n\n      case FACTOR:\n        return Eval_factor();\n\n      case FACTORIAL:\n        return Eval_factorial();\n\n      case FACTORPOLY:\n        return Eval_factorpoly();\n\n      case FILTER:\n        return Eval_filter();\n\n      case FLOATF:\n        return Eval_float();\n\n      case APPROXRATIO:\n        return Eval_approxratio();\n\n      case FLOOR:\n        return Eval_floor();\n\n      case FOR:\n        return Eval_for();\n\n      case FUNCTION:\n        return Eval_function_reference();\n\n      case GAMMA:\n        return Eval_gamma();\n\n      case GCD:\n        return Eval_gcd();\n\n      case HERMITE:\n        return Eval_hermite();\n\n      case HILBERT:\n        return Eval_hilbert();\n\n      case IMAG:\n        return Eval_imag();\n\n      case INDEX:\n        return Eval_index();\n\n      case INNER:\n        return _Eval_inner();\n\n      case INTEGRAL:\n        return Eval_integral();\n\n      case INV:\n        return Eval_inv();\n\n      case INVG:\n        return Eval_invg();\n\n      case ISINTEGER:\n        return Eval_isinteger();\n\n      case ISPRIME:\n        return Eval_isprime();\n\n      case LAGUERRE:\n        return Eval_laguerre();\n\n      case LCM:\n        return Eval_lcm();\n\n      case LEADING:\n        return Eval_leading();\n\n      case LEGENDRE:\n        return Eval_legendre();\n\n      case LOG:\n        return Eval_log();\n\n      case LOOKUP:\n        return Eval_lookup();\n\n      case MOD:\n        return Eval_mod();\n\n      case MULTIPLY:\n        return Eval_multiply();\n\n      case NOT:\n        return Eval_not();\n\n      case NROOTS:\n        return Eval_nroots();\n\n      case NUMBER:\n        return Eval_number();\n\n      case NUMERATOR:\n        return Eval_numerator();\n\n      case OPERATOR:\n        return Eval_operator();\n\n      case OR:\n        return Eval_or();\n\n      case OUTER:\n        return Eval_outer();\n\n      case PATTERN:\n        return Eval_pattern();\n\n      case PATTERNSINFO:\n        return Eval_patternsinfo();\n\n      case POLAR:\n        return Eval_polar();\n\n      case POWER:\n        return Eval_power();\n\n      case PRIME:\n        return Eval_prime();\n\n      case PRINT:\n        return Eval_print();\n\n      case PRINT2DASCII:\n        return Eval_print2dascii();\n\n      case PRINTFULL:\n        return Eval_printcomputer();\n\n      case PRINTLATEX:\n        return Eval_printlatex();\n\n      case PRINTLIST:\n        return Eval_printlist();\n\n      case PRINTPLAIN:\n        return Eval_printhuman();\n\n      case PRODUCT:\n        return Eval_product();\n\n      case QUOTE:\n        return Eval_quote();\n\n      case QUOTIENT:\n        return Eval_quotient();\n\n      case RANK:\n        return Eval_rank();\n\n      case RATIONALIZE:\n        return Eval_rationalize();\n\n      case REAL:\n        return Eval_real();\n\n      case ROUND:\n        return Eval_round();\n\n      case YYRECT:\n        return Eval_rect();\n\n      case ROOTS:\n        return Eval_roots();\n\n      case SETQ:\n        return Eval_setq();\n\n      case SGN:\n        return Eval_sgn();\n\n      case SILENTPATTERN:\n        return Eval_silentpattern();\n\n      case SIMPLIFY:\n        return Eval_simplify();\n\n      case SIN:\n        return Eval_sin();\n\n      case SINH:\n        return Eval_sinh();\n\n      case SHAPE:\n        return Eval_shape();\n\n      case SQRT:\n        return Eval_sqrt();\n\n      case STOP:\n        return Eval_stop();\n\n      case SUBST:\n        return Eval_subst();\n\n      case SUM:\n        return Eval_sum();\n\n      case SYMBOLSINFO:\n        return Eval_symbolsinfo();\n\n      case TAN:\n        return Eval_tan();\n\n      case TANH:\n        return Eval_tanh();\n\n      case TAYLOR:\n        return Eval_taylor();\n\n      case TEST:\n        return Eval_test();\n\n      case TESTEQ:\n        return Eval_testeq();\n\n      case TESTGE:\n        return Eval_testge();\n\n      case TESTGT:\n        return Eval_testgt();\n\n      case TESTLE:\n        return Eval_testle();\n\n      case TESTLT:\n        return Eval_testlt();\n\n      case TRANSPOSE:\n        return Eval_transpose();\n\n      case UNIT:\n        return Eval_unit();\n\n      case ZERO:\n        return Eval_zero();\n\n      default:\n        return Eval_user_function();\n    }\n  };\n\n  Eval_binding = function Eval_binding() {\n    return push(get_binding(cadr(p1)));\n  };\n  /* check =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  p\n  \n  General description\n  -------------------\n  Returns whether the predicate p is true/false or unknown:\n  0 if false, 1 if true or remains unevaluated if unknown.\n  Note that if \"check\" is passed an assignment, it turns it into a test,\n  i.e. check(a = b) is turned into check(a==b) \n  so \"a\" is not assigned anything.\n  Like in many programming languages, \"check\" also gives truthyness/falsyness\n  for numeric values. In which case, \"true\" is returned for non-zero values.\n  Potential improvements: \"check\" can't evaluate strings yet.\n   */\n\n\n  Eval_check = function Eval_check() {\n    var checkResult;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n\n    if (checkResult == null) {\n      return push(p1);\n    } else {\n      return push_integer(checkResult);\n    }\n  };\n\n  Eval_det = function Eval_det() {\n    push(cadr(p1));\n    Eval();\n    return det();\n  };\n  /* dim =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  m,n\n  \n  General description\n  -------------------\n  Returns the cardinality of the nth index of tensor \"m\".\n   */\n\n\n  Eval_dim = function Eval_dim() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n\n    if (iscons(cddr(p1))) {\n      push(caddr(p1));\n      Eval();\n      n = pop_integer();\n    } else {\n      n = 1;\n    }\n\n    if (!istensor(p2)) {\n      return push_integer(1);\n    } else if (n < 1 || n > p2.tensor.ndim) {\n      return push(p1);\n    } else {\n      return push_integer(p2.tensor.dim[n - 1]);\n    }\n  };\n\n  Eval_divisors = function Eval_divisors() {\n    push(cadr(p1));\n    Eval();\n    return divisors();\n  };\n  /* do =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,b,...\n  \n  General description\n  -------------------\n  Evaluates each argument from left to right. Returns the result of the last argument.\n   */\n\n\n  Eval_do = function Eval_do() {\n    var results;\n    push(car(p1));\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      pop();\n      push(car(p1));\n      Eval();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  Eval_dsolve = function Eval_dsolve() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    return dsolve();\n  };\n\n  Eval_Eval = function Eval_Eval() {\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      push(cadr(p1));\n      Eval();\n\n      _subst();\n\n      p1 = cddr(p1);\n    }\n\n    return Eval();\n  };\n\n  Eval_exp = function Eval_exp() {\n    push(cadr(p1));\n    Eval();\n    return exponential();\n  };\n\n  Eval_factorial = function Eval_factorial() {\n    push(cadr(p1));\n    Eval();\n    return factorial();\n  };\n\n  Eval_factorpoly = function Eval_factorpoly() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    factorpoly();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factorpoly();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  Eval_hermite = function Eval_hermite() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return hermite();\n  };\n\n  Eval_hilbert = function Eval_hilbert() {\n    push(cadr(p1));\n    Eval();\n    return hilbert();\n  };\n\n  Eval_index = function Eval_index() {\n    var h, orig, theTensor;\n    h = tos;\n    orig = p1;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    theTensor = stack[tos - 1];\n\n    if (isNumericAtom(theTensor)) {\n      stop(\"trying to access a scalar as a tensor\");\n    }\n\n    if (!istensor(theTensor)) {\n      moveTos(h);\n      push(orig);\n      return;\n    }\n\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n\n      if (!isintegerorintegerfloat(stack[tos - 1])) {\n        moveTos(h);\n        push(orig);\n        return;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    return index_function(tos - h);\n  };\n\n  Eval_inv = function Eval_inv() {\n    push(cadr(p1));\n    Eval();\n    return _inv();\n  };\n\n  Eval_invg = function Eval_invg() {\n    push(cadr(p1));\n    Eval();\n    return invg();\n  };\n\n  Eval_isinteger = function Eval_isinteger() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (isrational(p1)) {\n      if (isinteger(p1)) {\n        push(one);\n      } else {\n        push(zero);\n      }\n\n      return;\n    }\n\n    if (isdouble(p1)) {\n      n = Math.floor(p1.d);\n\n      if (n === p1.d) {\n        push(one);\n      } else {\n        push(zero);\n      }\n\n      return;\n    }\n\n    push_symbol(ISINTEGER);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_number = function Eval_number() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1.k === NUM || p1.k === DOUBLE) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_operator = function Eval_operator() {\n    var h;\n    h = tos;\n    push_symbol(OPERATOR);\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p1 = cdr(p1);\n    }\n\n    return list(tos - h);\n  };\n\n  Eval_quote = function Eval_quote() {\n    return push(cadr(p1));\n  };\n\n  Eval_rank = function Eval_rank() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (istensor(p1)) {\n      return push_integer(p1.tensor.ndim);\n    } else {\n      return push(zero);\n    }\n  };\n\n  Eval_setq = function Eval_setq() {\n    if (caadr(p1) === symbol(INDEX)) {\n      setq_indexed();\n      return;\n    }\n\n    if (iscons(cadr(p1))) {\n      define_user_function();\n      return;\n    }\n\n    if (!issymbol(cadr(p1))) {\n      stop(\"symbol assignment: error in symbol\");\n    }\n\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    set_binding(cadr(p1), p2);\n    return push(symbol(NIL));\n  };\n\n  setq_indexed = function setq_indexed() {\n    var h;\n    p4 = cadadr(p1);\n    console.log(\"p4: \" + p4);\n\n    if (!issymbol(p4)) {\n      stop(\"indexed assignment: expected a symbol name\");\n    }\n\n    h = tos;\n    push(caddr(p1));\n    Eval();\n    p2 = cdadr(p1);\n\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      p2 = cdr(p2);\n    }\n\n    set_component(tos - h);\n    p3 = pop();\n    set_binding(p4, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_sqrt = function Eval_sqrt() {\n    push(cadr(p1));\n    Eval();\n    push_rational(1, 2);\n    return power();\n  };\n\n  Eval_stop = function Eval_stop() {\n    return stop(\"user stop\");\n  };\n\n  Eval_subst = function Eval_subst() {\n    push(cadddr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadr(p1));\n    Eval();\n\n    _subst();\n\n    return Eval();\n  };\n\n  Eval_unit = function Eval_unit() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      push(p1);\n      return;\n    }\n\n    if (n < 1) {\n      push(p1);\n      return;\n    }\n\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[n * i + i] = one;\n    }\n\n    check_tensor_dimensions(p1);\n    return push(p1);\n  };\n\n  Eval_noexpand = function Eval_noexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  Eval_predicate = function Eval_predicate() {\n    save();\n    p1 = top();\n\n    if (car(p1) === symbol(SETQ)) {\n      pop();\n      push_symbol(TESTEQ);\n      push(cadr(p1));\n      push(caddr(p1));\n      list(3);\n    }\n\n    Eval();\n    return restore();\n  };\n\n  Eval_expand = function Eval_expand() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    return _expand();\n  };\n\n  _expand = function expand() {\n    var prev_expanding;\n    save();\n    p9 = pop();\n    p5 = pop();\n\n    if (istensor(p5)) {\n      expand_tensor();\n      restore();\n      return;\n    }\n\n    if (car(p5) === symbol(ADD)) {\n      push_integer(0);\n      p1 = cdr(p5);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p9);\n\n        _expand();\n\n        add();\n        p1 = cdr(p1);\n      }\n\n      restore();\n      return;\n    }\n\n    push(p5);\n\n    _numerator();\n\n    p3 = pop();\n    push(p5);\n\n    _denominator();\n\n    p2 = pop();\n    remove_negative_exponents();\n    push(p3);\n    push(p2);\n    push(p9);\n\n    if (isone(p3) || isone(p2)) {\n      if (!ispolyexpandedform(p2, p9) || isone(p2)) {\n        pop();\n        pop();\n        pop();\n        push(p5);\n        restore();\n        return;\n      }\n    }\n\n    divpoly();\n    p7 = pop();\n    push(p3);\n    push(p2);\n    push(p7);\n    multiply();\n    subtract();\n    p3 = pop();\n\n    if (isZeroAtomOrTensor(p3)) {\n      push(p7);\n      restore();\n      return;\n    }\n\n    push(p2);\n    push(p9);\n    factorpoly();\n    p2 = pop();\n    expand_get_C();\n    expand_get_B();\n    expand_get_A();\n\n    if (istensor(p4)) {\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n\n      _inv();\n\n      expanding = prev_expanding;\n      push(p3);\n\n      _inner();\n\n      push(p2);\n\n      _inner();\n    } else {\n      push(p3);\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p2);\n      multiply();\n    }\n\n    push(p7);\n    add();\n    return restore();\n  };\n\n  expand_tensor = function expand_tensor() {\n    var i, o, ref;\n    i = 0;\n    push(p5);\n    copy_tensor();\n    p5 = pop();\n\n    for (i = o = 0, ref = p5.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(p5.tensor.elem[i]);\n      push(p9);\n\n      _expand();\n\n      p5.tensor.elem[i] = pop();\n    }\n\n    return push(p5);\n  };\n\n  remove_negative_exponents = function remove_negative_exponents() {\n    var h, i, j, k, n, o, ref;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    n = 0;\n    h = tos;\n    factors(p2);\n    factors(p3);\n    n = tos - h;\n    j = 0;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p1 = stack[h + i];\n\n      if (car(p1) !== symbol(POWER)) {\n        continue;\n      }\n\n      if (cadr(p1) !== p9) {\n        continue;\n      }\n\n      push(caddr(p1));\n      k = pop_integer();\n\n      if (isNaN(k)) {\n        continue;\n      }\n\n      if (k < j) {\n        j = k;\n      }\n    }\n\n    moveTos(h);\n\n    if (j === 0) {\n      return;\n    }\n\n    push(p2);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    p2 = pop();\n    push(p3);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    return p3 = pop();\n  };\n\n  expand_get_C = function expand_get_C() {\n    var a, h, i, i1, j, n, o, prev_expanding, ref, ref1;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    h = tos;\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p1 = cdr(p2);\n\n      while (iscons(p1)) {\n        p5 = car(p1);\n        expand_get_CF();\n        p1 = cdr(p1);\n      }\n    } else {\n      p5 = p2;\n      expand_get_CF();\n    }\n\n    n = tos - h;\n\n    if (n === 1) {\n      p4 = pop();\n      return;\n    }\n\n    p4 = alloc_tensor(n * n);\n    p4.tensor.ndim = 2;\n    p4.tensor.dim[0] = n;\n    p4.tensor.dim[1] = n;\n    a = h;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        push(stack[a + j]);\n        push(p9);\n        push_integer(i);\n        power();\n        prev_expanding = expanding;\n        expanding = 1;\n        divide();\n        expanding = prev_expanding;\n        push(p9);\n        filter();\n        p4.tensor.elem[n * i + j] = pop();\n      }\n    }\n\n    return moveTos(tos - n);\n  };\n\n  expand_get_CF = function expand_get_CF() {\n    var d, i, j, n, o, prev_expanding, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n\n    if (!_Find(p5, p9)) {\n      return;\n    }\n\n    prev_expanding = expanding;\n    expanding = 1;\n    trivial_divide();\n    expanding = prev_expanding;\n\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p6 = cadr(p5);\n    } else {\n      n = 1;\n      p6 = p5;\n    }\n\n    push(p6);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      results.push(function () {\n        var i1, ref1, results1;\n        results1 = [];\n\n        for (j = i1 = 0, ref1 = d; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p8);\n          push(p6);\n          push_integer(i);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          expanding = prev_expanding;\n          push(p9);\n          push_integer(j);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          results1.push(expanding = prev_expanding);\n        }\n\n        return results1;\n      }());\n    }\n\n    return results;\n  };\n\n  trivial_divide = function trivial_divide() {\n    var h;\n    h = 0;\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      h = tos;\n      p0 = cdr(p2);\n\n      while (iscons(p0)) {\n        if (!equal(car(p0), p5)) {\n          push(car(p0));\n          Eval();\n        }\n\n        p0 = cdr(p0);\n      }\n\n      multiply_all(tos - h);\n    } else {\n      push_integer(1);\n    }\n\n    return p8 = pop();\n  };\n\n  expand_get_B = function expand_get_B() {\n    var i, n, o, prev_expanding, ref;\n    i = 0;\n    n = 0;\n\n    if (!istensor(p4)) {\n      return;\n    }\n\n    n = p4.tensor.dim[0];\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(p3);\n      push(p9);\n      push_integer(i);\n      power();\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p9);\n      filter();\n      p8.tensor.elem[i] = pop();\n    }\n\n    return p3 = p8;\n  };\n\n  expand_get_A = function expand_get_A() {\n    var h, i, n, o, ref;\n    h = 0;\n    i = 0;\n    n = 0;\n\n    if (!istensor(p4)) {\n      push(p2);\n      reciprocate();\n      p2 = pop();\n      return;\n    }\n\n    h = tos;\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p8 = cdr(p2);\n\n      while (iscons(p8)) {\n        p5 = car(p8);\n        expand_get_AF();\n        p8 = cdr(p8);\n      }\n    } else {\n      p5 = p2;\n      expand_get_AF();\n    }\n\n    n = tos - h;\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p8.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(h);\n    return p2 = p8;\n  };\n\n  expand_get_AF = function expand_get_AF() {\n    var d, i, j, n, o, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 1;\n\n    if (!_Find(p5, p9)) {\n      return;\n    }\n\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p5 = cadr(p5);\n    }\n\n    push(p5);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n\n    for (i = o = ref = n; ref <= 0 ? o < 0 : o > 0; i = ref <= 0 ? ++o : --o) {\n      results.push(function () {\n        var i1, ref1, results1;\n        results1 = [];\n\n        for (j = i1 = 0, ref1 = d; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p5);\n          push_integer(i);\n          power();\n          reciprocate();\n          push(p9);\n          push_integer(j);\n          power();\n          results1.push(multiply());\n        }\n\n        return results1;\n      }());\n    }\n\n    return results;\n  };\n\n  Eval_expcos = function Eval_expcos() {\n    push(cadr(p1));\n    Eval();\n    return expcos();\n  };\n\n  expcos = function expcos() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    add();\n    return restore();\n  };\n\n  Eval_expsin = function Eval_expsin() {\n    push(cadr(p1));\n    Eval();\n    return expsin();\n  };\n\n  expsin = function expsin() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    subtract();\n    return restore();\n  };\n\n  Eval_factor = function Eval_factor() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    factor();\n    p1 = cdddr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factor_again();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  factor_again = function factor_again() {\n    var h, n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        factor_term();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      factor_term();\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      multiply_all_noexpand(n);\n    }\n\n    return restore();\n  };\n\n  factor_term = function factor_term() {\n    save();\n    factorpoly();\n    p1 = pop();\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  factor = function factor() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isinteger(p1)) {\n      push(p1);\n      factor_number();\n    } else {\n      push(p1);\n      push(p2);\n      factorpoly();\n    }\n\n    return restore();\n  };\n\n  factor_small_number = function factor_small_number() {\n    var d, expo, i, n, o, ref;\n    i = 0;\n    save();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      stop(\"number too big to factor\");\n    }\n\n    if (n < 0) {\n      n = -n;\n    }\n\n    for (i = o = 0, ref = MAXPRIMETAB; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      d = primetab[i];\n\n      if (d > n / d) {\n        break;\n      }\n\n      expo = 0;\n\n      while (n % d === 0) {\n        n /= d;\n        expo++;\n      }\n\n      if (expo) {\n        push_integer(d);\n        push_integer(expo);\n      }\n    }\n\n    if (n > 1) {\n      push_integer(n);\n      push_integer(1);\n    }\n\n    return restore();\n  };\n\n  factorial = function factorial() {\n    var n;\n    n = 0;\n    save();\n    p1 = pop();\n    push(p1);\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push_symbol(FACTORIAL);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    bignum_factorial(n);\n    return restore();\n  };\n\n  _simplifyfactorials = function simplifyfactorials() {\n    var x;\n    x = 0;\n    save();\n    x = expanding;\n    expanding = 0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      push(zero);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _simplifyfactorials();\n\n        add();\n        p1 = cdr(p1);\n      }\n\n      expanding = x;\n      restore();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      sfac_product();\n      expanding = x;\n      restore();\n      return;\n    }\n\n    push(p1);\n    expanding = x;\n    return restore();\n  };\n\n  sfac_product = function sfac_product() {\n    var i, i1, j, j1, n, o, ref, ref1, ref2, ref3, s;\n    i = 0;\n    j = 0;\n    n = 0;\n    s = tos;\n    p1 = cdr(p1);\n    n = 0;\n\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      n++;\n    }\n\n    for (i = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n\n      for (j = i1 = ref1 = i + 1, ref2 = n; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (stack[s + j] === symbol(NIL)) {\n          continue;\n        }\n\n        sfac_product_f(s, i, j);\n      }\n    }\n\n    push(one);\n\n    for (i = j1 = 0, ref3 = n; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n\n      push(stack[s + i]);\n      multiply();\n    }\n\n    p1 = pop();\n    moveTos(tos - n);\n    return push(p1);\n  };\n\n  sfac_product_f = function sfac_product_f(s, a, b) {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    p1 = stack[s + a];\n    p2 = stack[s + b];\n\n    if (ispower(p1)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n\n    if (ispower(p2)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n\n    if (isfactorial(p1) && isfactorial(p2)) {\n      push(p3);\n      push(p4);\n      add();\n      yyexpand();\n      n = pop_integer();\n\n      if (n !== 0) {\n        return;\n      }\n\n      push(cadr(p1));\n      push(cadr(p2));\n      subtract();\n      yyexpand();\n      n = pop_integer();\n\n      if (n === 0 || isNaN(n)) {\n        return;\n      }\n\n      if (n < 0) {\n        n = -n;\n        p5 = p1;\n        p1 = p2;\n        p2 = p5;\n        p5 = p3;\n        p3 = p4;\n        p4 = p5;\n      }\n\n      push(one);\n\n      for (i = o = 1, ref = n; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {\n        push(cadr(p2));\n        push_integer(i);\n        add();\n        push(p3);\n        power();\n        multiply();\n      }\n\n      stack[s + a] = pop();\n      return stack[s + b] = symbol(NIL);\n    }\n  };\n\n  polycoeff = 0;\n  factpoly_expo = 0;\n\n  factorpoly = function factorpoly() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (!_Find(p1, p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (!ispolyexpandedform(p1, p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (!issymbol(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push(p2);\n    yyfactorpoly();\n    return restore();\n  };\n\n  yyfactorpoly = function yyfactorpoly() {\n    var checkingTheDivision, dividend, foundComplexRoot, foundRealRoot, h, i, i1, j1, l1, o, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, whichRootsAreWeFinding;\n    h = 0;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    if (_isfloating(p1)) {\n      stop(\"floating point numbers in polynomial\");\n    }\n\n    polycoeff = tos;\n    push(p1);\n    push(p2);\n    factpoly_expo = coeff() - 1;\n    rationalize_coefficients(h);\n    whichRootsAreWeFinding = \"real\";\n    remainingPoly = null;\n\n    while (factpoly_expo > 0) {\n      if (isZeroAtomOrTensor(stack[polycoeff + 0])) {\n        push_integer(1);\n        p4 = pop();\n        push_integer(0);\n        p5 = pop();\n      } else {\n        if (whichRootsAreWeFinding === \"real\") {\n          foundRealRoot = get_factor_from_real_root();\n        } else if (whichRootsAreWeFinding === \"complex\") {\n          foundComplexRoot = get_factor_from_complex_root(remainingPoly);\n        }\n      }\n\n      if (whichRootsAreWeFinding === \"real\") {\n        if (foundRealRoot === 0) {\n          whichRootsAreWeFinding = \"complex\";\n          continue;\n        } else {\n          push(p4);\n          push(p2);\n          multiply();\n          push(p5);\n          add();\n          p8 = pop();\n\n          if (DEBUG) {\n            console.log(\"success\\nFACTOR=\" + p8);\n          }\n          /*\n          if (isnegativeterm(p4))\n            push(p8)\n            negate()\n            p8 = pop()\n            push(p7)\n            negate_noexpand()\n            p7 = pop()\n           */\n\n\n          push(p7);\n          push(p8);\n          multiply_noexpand();\n          p7 = pop();\n          yydivpoly();\n\n          while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {\n            factpoly_expo--;\n          }\n\n          push(zero);\n\n          for (i = o = 0, ref = factpoly_expo; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n            push(stack[polycoeff + i]);\n            push(p2);\n            push_integer(i);\n            power();\n            multiply();\n            add();\n          }\n\n          remainingPoly = pop();\n        }\n      } else if (whichRootsAreWeFinding === \"complex\") {\n        if (foundComplexRoot === 0) {\n          break;\n        } else {\n          push(p4);\n          push(p2);\n          subtract();\n          push(p4);\n          conjugate();\n          push(p2);\n          subtract();\n          multiply();\n          p8 = pop();\n\n          if (DEBUG) {\n            console.log(\"success\\nFACTOR=\" + p8);\n          }\n          /*\n          if (isnegativeterm(p4))\n            push(p8)\n            negate()\n            p8 = pop()\n            push(p7)\n            negate_noexpand()\n            p7 = pop()\n           */\n\n\n          push(p7);\n          previousFactorisation = pop();\n          push(p7);\n          push(p8);\n          multiply_noexpand();\n          p7 = pop();\n\n          if (remainingPoly == null) {\n            push(zero);\n\n            for (i = i1 = 0, ref1 = factpoly_expo; 0 <= ref1 ? i1 <= ref1 : i1 >= ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n              push(stack[polycoeff + i]);\n              push(p2);\n              push_integer(i);\n              power();\n              multiply();\n              add();\n            }\n\n            remainingPoly = pop();\n          }\n\n          dividend = remainingPoly;\n          push(dividend);\n          push(p8);\n          push(p2);\n          divpoly();\n          remainingPoly = pop();\n          push(remainingPoly);\n          push(p8);\n          multiply();\n          checkingTheDivision = pop();\n\n          if (!equal(checkingTheDivision, dividend)) {\n            if (DEBUG) {\n              console.log(\"we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting\");\n            }\n\n            if (DEBUG) {\n              console.log(\"so just returning previousFactorisation times dividend: \" + previousFactorisation + \" * \" + dividend);\n            }\n\n            push(previousFactorisation);\n            push(dividend);\n            prev_expanding = expanding;\n            expanding = 0;\n            yycondense();\n            expanding = prev_expanding;\n            multiply_noexpand();\n            p7 = pop();\n            stack[h] = p7;\n            moveTos(h + 1);\n            restore();\n            return;\n          }\n          /*\n          if compare_numbers(startingDegree, remainingDegree)\n             * ok even if we found a complex root that\n             * together with the conjugate generates a poly in Z,\n             * that doesn't mean that the division would end up in Z.\n             * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots\n             * so a factor is 1+x^2 ( = (x+i)*(x-i))\n             * BUT\n           */\n\n\n          for (i = j1 = 0, ref2 = factpoly_expo; 0 <= ref2 ? j1 <= ref2 : j1 >= ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n            pop();\n          }\n\n          push(remainingPoly);\n          push(p2);\n          coeff();\n          factpoly_expo -= 2;\n        }\n      }\n    }\n\n    push(zero);\n\n    for (i = l1 = 0, ref3 = factpoly_expo; 0 <= ref3 ? l1 <= ref3 : l1 >= ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[polycoeff + i]);\n      push(p2);\n      push_integer(i);\n      power();\n      multiply();\n      add();\n    }\n\n    p1 = pop();\n\n    if (DEBUG) {\n      console.log(\"POLY=\" + p1);\n    }\n\n    push(p1);\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    p1 = pop();\n\n    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {\n      push(p1);\n      negate();\n      p1 = pop();\n      push(p7);\n      negate_noexpand();\n      p7 = pop();\n    }\n\n    push(p7);\n    push(p1);\n    multiply_noexpand();\n    p7 = pop();\n\n    if (DEBUG) {\n      console.log(\"RESULT=\" + p7);\n    }\n\n    stack[h] = p7;\n    moveTos(h + 1);\n    return restore();\n  };\n\n  rationalize_coefficients = function rationalize_coefficients(h) {\n    var i, i1, o, ref, ref1, ref2, ref3;\n    i = 0;\n    p7 = one;\n\n    for (i = o = ref = h, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n      push(stack[i]);\n\n      _denominator();\n\n      push(p7);\n      lcm();\n      p7 = pop();\n    }\n\n    for (i = i1 = ref2 = h, ref3 = tos; ref2 <= ref3 ? i1 < ref3 : i1 > ref3; i = ref2 <= ref3 ? ++i1 : --i1) {\n      push(p7);\n      push(stack[i]);\n      multiply();\n      stack[i] = pop();\n    }\n\n    push(p7);\n    reciprocate();\n    p7 = pop();\n\n    if (DEBUG) {\n      return console.log(\"rationalize_coefficients result\");\n    }\n  };\n\n  get_factor_from_real_root = function get_factor_from_real_root() {\n    var a0, an, h, i, i1, j, j1, l1, m1, na0, nan, o, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n\n    if (DEBUG) {\n      push(zero);\n\n      for (i = o = 0, ref = factpoly_expo; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n        push(stack[polycoeff + i]);\n        push(p2);\n        push_integer(i);\n        power();\n        multiply();\n        add();\n      }\n\n      p1 = pop();\n      console.log(\"POLY=\" + p1);\n    }\n\n    h = tos;\n    an = tos;\n    push(stack[polycoeff + factpoly_expo]);\n    divisors_onstack();\n    nan = tos - an;\n    a0 = tos;\n    push(stack[polycoeff + 0]);\n    divisors_onstack();\n    na0 = tos - a0;\n\n    if (DEBUG) {\n      console.log(\"divisors of base term\");\n\n      for (i = i1 = 0, ref1 = na0; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        console.log(\", \" + stack[a0 + i]);\n      }\n\n      console.log(\"divisors of leading term\");\n\n      for (i = j1 = 0, ref2 = nan; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n        console.log(\", \" + stack[an + i]);\n      }\n    }\n\n    for (rootsTries_i = l1 = 0, ref3 = nan; 0 <= ref3 ? l1 < ref3 : l1 > ref3; rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {\n      for (rootsTries_j = m1 = 0, ref4 = na0; 0 <= ref4 ? m1 < ref4 : m1 > ref4; rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {\n        p4 = stack[an + rootsTries_i];\n        p5 = stack[a0 + rootsTries_j];\n        push(p5);\n        push(p4);\n        divide();\n        negate();\n        p3 = pop();\n        Evalpoly();\n\n        if (DEBUG) {\n          console.log(\"try A=\" + p4);\n          console.log(\", B=\" + p5);\n          console.log(\", root \" + p2);\n          console.log(\"=-B/A=\" + p3);\n          console.log(\", POLY(\" + p3);\n          console.log(\")=\" + p6);\n        }\n\n        if (isZeroAtomOrTensor(p6)) {\n          moveTos(h);\n\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n\n          return 1;\n        }\n\n        push(p5);\n        negate();\n        p5 = pop();\n        push(p3);\n        negate();\n        p3 = pop();\n        Evalpoly();\n\n        if (DEBUG) {\n          console.log(\"try A=\" + p4);\n          console.log(\", B=\" + p5);\n          console.log(\", root \" + p2);\n          console.log(\"=-B/A=\" + p3);\n          console.log(\", POLY(\" + p3);\n          console.log(\")=\" + p6);\n        }\n\n        if (isZeroAtomOrTensor(p6)) {\n          moveTos(h);\n\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n\n          return 1;\n        }\n      }\n    }\n\n    moveTos(h);\n\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root returning 0\");\n    }\n\n    return 0;\n  };\n\n  get_factor_from_complex_root = function get_factor_from_complex_root(remainingPoly) {\n    var a0, an, h, i, i1, j, na0, nan, o, rootsTries_i, rootsTries_j;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n\n    if (factpoly_expo <= 2) {\n      if (DEBUG) {\n        console.log(\"no more factoring via complex roots to be found in polynomial of degree <= 2\");\n      }\n\n      return 0;\n    }\n\n    p1 = remainingPoly;\n\n    if (DEBUG) {\n      console.log(\"complex root finding for POLY=\" + p1);\n    }\n\n    h = tos;\n    an = tos;\n    push_integer(-1);\n    push_rational(2, 3);\n    power();\n\n    _rect();\n\n    p4 = pop();\n\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + p4);\n    }\n\n    push(p4);\n    p3 = pop();\n    push(p3);\n    Evalpoly();\n\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + p6);\n    }\n\n    if (isZeroAtomOrTensor(p6)) {\n      moveTos(h);\n\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n\n      return 1;\n    }\n\n    push_integer(1);\n    push_rational(2, 3);\n    power();\n\n    _rect();\n\n    p4 = pop();\n\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + p4);\n    }\n\n    push(p4);\n    p3 = pop();\n    push(p3);\n    Evalpoly();\n\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + p6);\n    }\n\n    if (isZeroAtomOrTensor(p6)) {\n      moveTos(h);\n\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n\n      return 1;\n    }\n\n    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {\n      for (rootsTries_j = i1 = 1; i1 <= 5; rootsTries_j = ++i1) {\n        push_integer(rootsTries_i);\n        push_integer(rootsTries_j);\n        push(imaginaryunit);\n        multiply();\n        add();\n\n        _rect();\n\n        p4 = pop();\n        push(p4);\n        p3 = pop();\n        push(p3);\n        Evalpoly();\n\n        if (isZeroAtomOrTensor(p6)) {\n          moveTos(h);\n\n          if (DEBUG) {\n            console.log(\"found complex root: \" + p6);\n          }\n\n          return 1;\n        }\n      }\n    }\n\n    moveTos(h);\n\n    if (DEBUG) {\n      console.log(\"get_factor_from_complex_root returning 0\");\n    }\n\n    return 0;\n  };\n\n  yydivpoly = function yydivpoly() {\n    var i, o, ref;\n    i = 0;\n    p6 = zero;\n\n    for (i = o = ref = factpoly_expo; ref <= 0 ? o < 0 : o > 0; i = ref <= 0 ? ++o : --o) {\n      push(stack[polycoeff + i]);\n      stack[polycoeff + i] = p6;\n      push(p4);\n      divide();\n      p6 = pop();\n      push(stack[polycoeff + i - 1]);\n      push(p6);\n      push(p5);\n      multiply();\n      subtract();\n      stack[polycoeff + i - 1] = pop();\n    }\n\n    stack[polycoeff + 0] = p6;\n\n    if (DEBUG) {\n      return console.log(\"yydivpoly Q:\");\n    }\n  };\n\n  Evalpoly = function Evalpoly() {\n    var i, o, ref;\n    i = 0;\n    push(zero);\n\n    for (i = o = ref = factpoly_expo; ref <= 0 ? o <= 0 : o >= 0; i = ref <= 0 ? ++o : --o) {\n      push(p3);\n      multiply();\n      push(stack[polycoeff + i]);\n\n      if (DEBUG) {\n        console.log(\"Evalpoly top of stack:\");\n        console.log(_print_list(stack[tos - i]));\n      }\n\n      add();\n    }\n\n    return p6 = pop();\n  };\n\n  factors = function factors(p) {\n    var h;\n    h = tos;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        push_term_factors(car(p));\n        p = cdr(p);\n      }\n    } else {\n      push_term_factors(p);\n    }\n\n    return tos - h;\n  };\n\n  push_term_factors = function push_term_factors(p) {\n    var results;\n\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return push(p);\n    }\n  };\n  /*\n  Remove terms that involve a given symbol or expression. For example...\n  \n    filter(x^2 + x + 1, x)    =>  1\n  \n    filter(x^2 + x + 1, x^2)  =>  x + 1\n   */\n\n\n  Eval_filter = function Eval_filter() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      filter();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n  /*\n   For example...\n  \n    push(F)\n    push(X)\n    filter()\n    F = pop()\n   */\n\n\n  filter = function filter() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    filter_main();\n    return restore();\n  };\n\n  filter_main = function filter_main() {\n    if (car(p1) === symbol(ADD)) {\n      return filter_sum();\n    } else if (istensor(p1)) {\n      return filter_tensor();\n    } else if (_Find(p1, p2)) {\n      return push_integer(0);\n    } else {\n      return push(p1);\n    }\n  };\n\n  filter_sum = function filter_sum() {\n    var results;\n    push_integer(0);\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      filter();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  filter_tensor = function filter_tensor() {\n    var i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    n = p1.tensor.nelem;\n    p3 = alloc_tensor(n);\n    p3.tensor.ndim = p1.tensor.ndim;\n\n    for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      filter();\n      p3.tensor.elem[i] = pop();\n    }\n\n    return push(p3);\n  };\n\n  Eval_float = function Eval_float() {\n    evaluatingAsFloats++;\n    push(cadr(p1));\n    Eval();\n\n    _yyfloat();\n\n    Eval();\n    return evaluatingAsFloats--;\n  };\n\n  checkFloatHasWorkedOutCompletely = function checkFloatHasWorkedOutCompletely(nodeToCheck) {\n    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;\n    numberOfPowers = _countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);\n    numberOfPIs = _countOccurrencesOfSymbol(symbol(PI), nodeToCheck);\n    numberOfEs = _countOccurrencesOfSymbol(symbol(E), nodeToCheck);\n    numberOfMults = _countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);\n    numberOfSums = _countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);\n\n    if (DEBUG) {\n      console.log(\"     ... numberOfPowers: \" + numberOfPowers);\n      console.log(\"     ... numberOfPIs: \" + numberOfPIs);\n      console.log(\"     ... numberOfEs: \" + numberOfEs);\n      console.log(\"     ... numberOfMults: \" + numberOfMults);\n      console.log(\"     ... numberOfSums: \" + numberOfSums);\n    }\n\n    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {\n      return stop(\"float: some unevalued parts in \" + nodeToCheck);\n    }\n  };\n\n  zzfloat = function zzfloat() {\n    save();\n    evaluatingAsFloats++;\n    Eval();\n\n    _yyfloat();\n\n    Eval();\n    evaluatingAsFloats--;\n    return restore();\n  };\n\n  _yyfloat = function yyfloat() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    evaluatingAsFloats++;\n    save();\n    p1 = pop();\n\n    if (iscons(p1)) {\n      h = tos;\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _yyfloat();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n\n      for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n\n        _yyfloat();\n\n        p1.tensor.elem[i] = pop();\n      }\n\n      push(p1);\n    } else if (p1.k === NUM) {\n      push(p1);\n      bignum_float();\n    } else if (p1 === symbol(PI)) {\n      push_double(Math.PI);\n    } else if (p1 === symbol(E)) {\n      push_double(Math.E);\n    } else {\n      push(p1);\n    }\n\n    restore();\n    return evaluatingAsFloats--;\n  };\n\n  Eval_floor = function Eval_floor() {\n    push(cadr(p1));\n    Eval();\n    return yfloor();\n  };\n\n  yfloor = function yfloor() {\n    save();\n    yyfloor();\n    return restore();\n  };\n\n  yyfloor = function yyfloor() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (!isNumericAtom(p1)) {\n      push_symbol(FLOOR);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.floor(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n\n    if (isnegativenumber(p1)) {\n      push_integer(-1);\n      return add();\n    }\n  };\n  /*\n  x=0\n  y=2\n  for(do(x=sqrt(2+x),y=2*y/x),k,1,9)\n  float(y)\n  \n  X: k\n  B: 1...9\n  \n  1st parameter is the body\n  2nd parameter is the variable to loop with\n  3rd and 4th are the limits\n   */\n\n\n  Eval_for = function Eval_for() {\n    var i, j, k, loopingVariable, o, ref, ref1;\n    i = 0;\n    j = 0;\n    k = 0;\n    loopingVariable = caddr(p1);\n\n    if (!issymbol(loopingVariable)) {\n      stop(\"for: 2nd arg should be the variable to loop over\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n\n    p4 = get_binding(loopingVariable);\n\n    for (i = o = ref = j, ref1 = k; ref <= ref1 ? o <= ref1 : o >= ref1; i = ref <= ref1 ? ++o : --o) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(loopingVariable, p5);\n      push(cadr(p1));\n      Eval();\n      pop();\n    }\n\n    set_binding(loopingVariable, p4);\n    return push_symbol(NIL);\n  };\n\n  Eval_gamma = function Eval_gamma() {\n    push(cadr(p1));\n    Eval();\n    return gamma();\n  };\n\n  gamma = function gamma() {\n    save();\n    gammaf();\n    return restore();\n  };\n\n  gammaf = function gammaf() {\n    p1 = pop();\n\n    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push_rational(1, 2);\n      power();\n      return;\n    }\n\n    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push_rational(1, 2);\n      power();\n      push_rational(1, 2);\n      multiply();\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push_integer(-1);\n      multiply();\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      push(p1);\n      multiply();\n      sine();\n      push(p1);\n      multiply();\n      push(p1);\n      negate();\n      gamma();\n      multiply();\n      divide();\n      return;\n    }\n\n    if (car(p1) === symbol(ADD)) {\n      gamma_of_sum();\n      return;\n    }\n\n    push_symbol(GAMMA);\n    push(p1);\n    list(2);\n  };\n\n  gamma_of_sum = function gamma_of_sum() {\n    p3 = cdr(p1);\n\n    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {\n      push(cadr(p3));\n      push(cadr(p3));\n      gamma();\n      return multiply();\n    } else {\n      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {\n        push(cadr(p3));\n        gamma();\n        push(cadr(p3));\n        push_integer(-1);\n        add();\n        return divide();\n      } else {\n        push_symbol(GAMMA);\n        push(p1);\n        list(2);\n      }\n    }\n  };\n\n  Eval_gcd = function Eval_gcd() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      gcd();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  gcd = function gcd() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    gcd_main();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  gcd_main = function gcd_main() {\n    var polyVar;\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n\n    if (equal(p1, p2)) {\n      push(p1);\n      return;\n    }\n\n    if (isrational(p1) && isrational(p2)) {\n      push(p1);\n      push(p2);\n      gcd_numbers();\n      return;\n    }\n\n    if (polyVar = areunivarpolysfactoredorexpandedform(p1, p2)) {\n      gcd_polys(polyVar);\n      return;\n    }\n\n    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {\n      gcd_sum_sum();\n      return;\n    }\n\n    if (car(p1) === symbol(ADD)) {\n      gcd_sum(p1);\n      p1 = pop();\n    }\n\n    if (car(p2) === symbol(ADD)) {\n      gcd_sum(p2);\n      p2 = pop();\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      gcd_sum_product();\n      return;\n    }\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      gcd_product_sum();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n\n    return gcd_powers_with_same_base();\n  };\n\n  areunivarpolysfactoredorexpandedform = function areunivarpolysfactoredorexpandedform(p1, p2) {\n    var polyVar;\n\n    if (polyVar = isunivarpolyfactoredorexpandedform(p1)) {\n      if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {\n        return polyVar;\n      }\n    }\n\n    return false;\n  };\n\n  gcd_polys = function gcd_polys(polyVar) {\n    push(p1);\n    push(polyVar);\n    factorpoly();\n    p1 = pop();\n    push(p2);\n    push(polyVar);\n    factorpoly();\n    p2 = pop();\n\n    if (DEBUG) {\n      console.log(\"factored polys:\");\n    }\n\n    if (DEBUG) {\n      console.log(\"p1:\" + p1.toString());\n    }\n\n    if (DEBUG) {\n      console.log(\"p2:\" + p2.toString());\n    }\n\n    if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {\n      if (car(p1) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push(one);\n        list(3);\n        p1 = pop();\n      }\n\n      if (car(p2) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p2);\n        push(one);\n        list(3);\n        p2 = pop();\n      }\n    }\n\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n\n    gcd_powers_with_same_base();\n    return true;\n  };\n\n  gcd_product_product = function gcd_product_product() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n\n    while (iscons(p3)) {\n      p4 = cdr(p2);\n\n      while (iscons(p4)) {\n        push(car(p3));\n        push(car(p4));\n        gcd();\n        multiply();\n        p4 = cdr(p4);\n      }\n\n      results.push(p3 = cdr(p3));\n    }\n\n    return results;\n  };\n\n  gcd_powers_with_same_base = function gcd_powers_with_same_base() {\n    if (car(p1) === symbol(POWER)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n\n    if (car(p2) === symbol(POWER)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n\n    if (!equal(p1, p2)) {\n      push(one);\n      return;\n    }\n\n    if (isNumericAtom(p3) && isNumericAtom(p4)) {\n      push(p1);\n\n      if (lessp(p3, p4)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n\n      power();\n      return;\n    }\n\n    push(p3);\n    push(p4);\n    divide();\n    p5 = pop();\n\n    if (isNumericAtom(p5)) {\n      push(p1);\n\n      if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {\n        p5 = cadr(p3);\n      } else {\n        p5 = one;\n      }\n\n      if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {\n        p6 = cadr(p4);\n      } else {\n        p6 = one;\n      }\n\n      if (lessp(p5, p6)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n\n      power();\n      return;\n    }\n\n    push(p3);\n    push(p4);\n    subtract();\n    p5 = pop();\n\n    if (!isNumericAtom(p5)) {\n      push(one);\n      return;\n    }\n\n    push(p1);\n\n    if (isnegativenumber(p5)) {\n      push(p3);\n    } else {\n      push(p4);\n    }\n\n    return power();\n  };\n\n  gcd_sum_sum = function gcd_sum_sum() {\n    if (length(p1) !== length(p2)) {\n      push(one);\n      return;\n    }\n\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n\n    p3 = pop();\n    p4 = cdr(p2);\n    push(car(p4));\n    p4 = cdr(p4);\n\n    while (iscons(p4)) {\n      push(car(p4));\n      gcd();\n      p4 = cdr(p4);\n    }\n\n    p4 = pop();\n    push(p1);\n    push(p3);\n    divide();\n    p5 = pop();\n    push(p2);\n    push(p4);\n    divide();\n    p6 = pop();\n\n    if (equal(p5, p6)) {\n      push(p5);\n      push(p3);\n      push(p4);\n      gcd();\n      return multiply();\n    } else {\n      return push(one);\n    }\n  };\n\n  gcd_sum = function gcd_sum(p) {\n    var results;\n    p = cdr(p);\n    push(car(p));\n    p = cdr(p);\n    results = [];\n\n    while (iscons(p)) {\n      push(car(p));\n      gcd();\n      results.push(p = cdr(p));\n    }\n\n    return results;\n  };\n\n  gcd_sum_product = function gcd_sum_product() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n\n    while (iscons(p3)) {\n      push(car(p3));\n      push(p2);\n      gcd();\n      multiply();\n      results.push(p3 = cdr(p3));\n    }\n\n    return results;\n  };\n\n  gcd_product_sum = function gcd_product_sum() {\n    var results;\n    push(one);\n    p4 = cdr(p2);\n    results = [];\n\n    while (iscons(p4)) {\n      push(p1);\n      push(car(p4));\n      gcd();\n      multiply();\n      results.push(p4 = cdr(p4));\n    }\n\n    return results;\n  };\n\n  guess = function guess() {\n    var p;\n    p = pop();\n    push(p);\n\n    if (_Find(p, symbol(SYMBOL_X))) {\n      return push_symbol(SYMBOL_X);\n    } else if (_Find(p, symbol(SYMBOL_Y))) {\n      return push_symbol(SYMBOL_Y);\n    } else if (_Find(p, symbol(SYMBOL_Z))) {\n      return push_symbol(SYMBOL_Z);\n    } else if (_Find(p, symbol(SYMBOL_T))) {\n      return push_symbol(SYMBOL_T);\n    } else if (_Find(p, symbol(SYMBOL_S))) {\n      return push_symbol(SYMBOL_S);\n    } else {\n      return push_symbol(SYMBOL_X);\n    }\n  };\n\n  hermite = function hermite() {\n    save();\n    yyhermite();\n    return restore();\n  };\n\n  yyhermite = function yyhermite() {\n    var n;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push_symbol(HERMITE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    if (issymbol(p1)) {\n      return yyhermite2(n);\n    } else {\n      p3 = p1;\n      p1 = symbol(SECRETX);\n      yyhermite2(n);\n      p1 = p3;\n      push(symbol(SECRETX));\n      push(p1);\n\n      _subst();\n\n      return Eval();\n    }\n  };\n\n  yyhermite2 = function yyhermite2(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p4 = pop();\n    results = [];\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p5 = p4;\n      p4 = pop();\n      push(p1);\n      push(p4);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(2);\n      results.push(multiply());\n    }\n\n    return results;\n  };\n\n  hilbert = function hilbert() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p2 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (n < 2) {\n      push_symbol(HILBERT);\n      push(p2);\n      list(2);\n      restore();\n      return;\n    }\n\n    push_zero_matrix(n, n);\n    p1 = pop();\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        push_integer(i + j + 1);\n        inverse();\n        p1.tensor.elem[i * n + j] = pop();\n      }\n    }\n\n    push(p1);\n    return restore();\n  };\n  /*\n   Returns the coefficient of the imaginary part of complex z\n  \n    z    imag(z)\n    -    -------\n  \n    a + i b    b\n  \n    exp(i a)  sin(a)\n   */\n\n\n  DEBUG_IMAG = false;\n\n  Eval_imag = function Eval_imag() {\n    push(cadr(p1));\n    Eval();\n    return imag();\n  };\n\n  imag = function imag() {\n    save();\n\n    _rect();\n\n    p1 = pop();\n\n    if (DEBUG_IMAG) {\n      console.log(\"IMAGE of \" + p1);\n    }\n\n    push(p1);\n    push(p1);\n    conjugate();\n\n    if (DEBUG_IMAG) {\n      console.log(\" image: conjugate result: \" + stack[tos - 1]);\n    }\n\n    subtract();\n    push_integer(2);\n    divide();\n\n    if (DEBUG_IMAG) {\n      console.log(\" image: 1st divide result: \" + stack[tos - 1]);\n    }\n\n    push(imaginaryunit);\n    divide();\n\n    if (DEBUG_IMAG) {\n      console.log(\" image: 2nd divide result: \" + stack[tos - 1]);\n    }\n\n    return restore();\n  };\n\n  index_function = function index_function(n) {\n    var i, i1, j1, k, l1, m, m1, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    save();\n    s = tos - n;\n    p1 = stack[s];\n    ndim = p1.tensor.ndim;\n    m = n - 1;\n\n    if (m > ndim) {\n      stop(\"too many indices for tensor\");\n    }\n\n    k = 0;\n\n    for (i = o = 0, ref = m; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 1]);\n      t = pop_integer();\n\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"index out of range\");\n      }\n\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n\n    if (ndim === m) {\n      moveTos(tos - n);\n      push(p1.tensor.elem[k]);\n      restore();\n      return;\n    }\n\n    for (i = i1 = ref1 = m, ref2 = ndim; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n\n    nelem = 1;\n\n    for (i = j1 = ref3 = m, ref4 = ndim; ref3 <= ref4 ? j1 < ref4 : j1 > ref4; i = ref3 <= ref4 ? ++j1 : --j1) {\n      nelem *= p1.tensor.dim[i];\n    }\n\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - m;\n\n    for (i = l1 = ref5 = m, ref6 = ndim; ref5 <= ref6 ? l1 < ref6 : l1 > ref6; i = ref5 <= ref6 ? ++l1 : --l1) {\n      p2.tensor.dim[i - m] = p1.tensor.dim[i];\n    }\n\n    for (i = m1 = 0, ref7 = nelem; 0 <= ref7 ? m1 < ref7 : m1 > ref7; i = 0 <= ref7 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[k + i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  set_component = function set_component(n) {\n    var i, i1, j1, k, l1, m, m1, n1, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    t = 0;\n    save();\n\n    if (n < 3) {\n      stop(\"error in indexed assign\");\n    }\n\n    s = tos - n;\n    p2 = stack[s];\n    p1 = stack[s + 1];\n\n    if (!istensor(p1)) {\n      stop(\"error in indexed assign: assigning to something that is not a tensor\");\n    }\n\n    ndim = p1.tensor.ndim;\n    m = n - 2;\n\n    if (m > ndim) {\n      stop(\"error in indexed assign\");\n    }\n\n    k = 0;\n\n    for (i = o = 0, ref = m; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 2]);\n      t = pop_integer();\n\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"error in indexed assign\\n\");\n      }\n\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n\n    for (i = i1 = ref1 = m, ref2 = ndim; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n\n    for (i = j1 = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = l1 = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? l1 < ref4 : l1 > ref4; i = 0 <= ref4 ? ++l1 : --l1) {\n      p3.tensor.elem[i] = p1.tensor.elem[i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p3);\n    p1 = p3;\n\n    if (ndim === m) {\n      if (istensor(p2)) {\n        stop(\"error in indexed assign\");\n      }\n\n      p1.tensor.elem[k] = p2;\n      check_tensor_dimensions(p1);\n      moveTos(tos - n);\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (!istensor(p2)) {\n      stop(\"error in indexed assign\");\n    }\n\n    if (ndim - m !== p2.tensor.ndim) {\n      stop(\"error in indexed assign\");\n    }\n\n    for (i = m1 = 0, ref5 = p2.tensor.ndim; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i = 0 <= ref5 ? ++m1 : --m1) {\n      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {\n        stop(\"error in indexed assign\");\n      }\n    }\n\n    for (i = n1 = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? n1 < ref6 : n1 > ref6; i = 0 <= ref6 ? ++n1 : --n1) {\n      p1.tensor.elem[k + i] = p2.tensor.elem[i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p1);\n    return restore();\n  };\n  /* dot =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,b,...\n  \n  General description\n  -------------------\n  \n  The inner (or dot) operator gives products of vectors,\n  matrices, and tensors.\n  \n  Note that for Algebrite, the elements of a vector/matrix\n  can only be scalars. This allows for example to flesh out\n  matrix multiplication using the usual multiplication.\n  So for example block-representations are not allowed.\n  \n  There is an aweful lot of confusion between sw packages on\n  what dot and inner do.\n  \n  First off, the \"dot\" operator is different from the\n  mathematical notion of dot product, which can be\n  slightly confusing.\n  \n  The mathematical notion of dot product is here:\n    http://mathworld.wolfram.com/DotProduct.html\n  \n  However, \"dot\" does that and a bunch of other things,\n  i.e. in Algebrite\n  dot/inner does what the dot of Mathematica does, i.e.:\n  \n  scalar product of vectors:\n  \n    inner((a, b, c), (x, y, z))\n    > a x + b y + c z\n  \n  products of matrices and vectors:\n  \n    inner(((a, b), (c,d)), (x, y))\n    > (a x + b y,c x + d y)\n  \n    inner((x, y), ((a, b), (c,d)))\n    > (a x + c y,b x + d y)\n  \n    inner((x, y), ((a, b), (c,d)), (r, s))\n    > a r x + b s x + c r y + d s y\n  \n  matrix product:\n  \n    inner(((a,b),(c,d)),((r,s),(t,u)))\n    > ((a r + b t,a s + b u),(c r + d t,c s + d u))\n  \n  the \"dot/inner\" operator is associative and\n  distributive but not commutative.\n  \n  In Mathematica, Inner is a generalisation of Dot where\n  the user can specify the multiplication and the addition\n  operators.\n  But here in Algebrite they do the same thing.\n  \n   https://reference.wolfram.com/language/ref/Dot.html\n   https://reference.wolfram.com/language/ref/Inner.html\n  \n   http://uk.mathworks.com/help/matlab/ref/dot.html\n   http://uk.mathworks.com/help/matlab/ref/mtimes.html\n   */\n\n\n  _Eval_inner = function Eval_inner() {\n    var difference, i, i1, j1, l1, moretheArguments, o, operands, ref, ref1, ref2, ref3, refinedOperands, results, secondArgument, shift, theArguments;\n    theArguments = [];\n    theArguments.push(car(cdr(p1)));\n    secondArgument = car(cdr(cdr(p1)));\n\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n\n    moretheArguments = cdr(cdr(p1));\n\n    while (moretheArguments !== symbol(NIL)) {\n      theArguments.push(car(moretheArguments));\n      moretheArguments = cdr(moretheArguments);\n    }\n\n    if (theArguments.length > 2) {\n      push_symbol(INNER);\n      push(theArguments[theArguments.length - 2]);\n      push(theArguments[theArguments.length - 1]);\n      list(3);\n\n      for (i = o = 2, ref = theArguments.length; 2 <= ref ? o < ref : o > ref; i = 2 <= ref ? ++o : --o) {\n        push_symbol(INNER);\n        swap();\n        push(theArguments[theArguments.length - i - 1]);\n        swap();\n        list(3);\n      }\n\n      p1 = pop();\n\n      _Eval_inner();\n\n      return;\n    }\n\n    operands = [];\n\n    _get_innerprod_factors(p1, operands);\n\n    refinedOperands = [];\n\n    for (i = i1 = 0, ref1 = operands.length; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      if (operands[i] === symbol(SYMBOL_IDENTITY_MATRIX)) {\n        continue;\n      } else {\n        refinedOperands.push(operands[i]);\n      }\n    }\n\n    operands = refinedOperands;\n    refinedOperands = [];\n\n    if (operands.length > 1) {\n      shift = 0;\n\n      for (i = j1 = 0, ref2 = operands.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n        if (i + shift + 1 <= operands.length - 1) {\n          if (!(_isNumericAtomOrTensor(operands[i + shift]) || _isNumericAtomOrTensor(operands[i + shift + 1]))) {\n            push(operands[i + shift]);\n            Eval();\n\n            _inv();\n\n            push(operands[i + shift + 1]);\n            Eval();\n            subtract();\n            difference = pop();\n\n            if (isZeroAtomOrTensor(difference)) {\n              shift += 1;\n            } else {\n              refinedOperands.push(operands[i + shift]);\n            }\n          } else {\n            refinedOperands.push(operands[i + shift]);\n          }\n        } else {\n          break;\n        }\n\n        if (i + shift === operands.length - 2) {\n          refinedOperands.push(operands[operands.length - 1]);\n        }\n\n        if (i + shift >= operands.length - 1) {\n          break;\n        }\n      }\n\n      operands = refinedOperands;\n    }\n\n    push(symbol(INNER));\n\n    if (operands.length > 0) {\n      for (i = l1 = 0, ref3 = operands.length; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n        push(operands[i]);\n      }\n    } else {\n      pop();\n      push(symbol(SYMBOL_IDENTITY_MATRIX));\n      return;\n    }\n\n    list(operands.length + 1);\n    p1 = pop();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n\n      _inner();\n\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  _inner = function inner() {\n    var arg1, arg2, arg3, subtractionResult;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isnegativeterm(p2) && isnegativeterm(p1)) {\n      push(p2);\n      negate();\n      p2 = pop();\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n\n    if (isinnerordot(p1)) {\n      arg1 = car(cdr(p1));\n      arg2 = car(cdr(cdr(p1)));\n      arg3 = p2;\n      p1 = arg1;\n      push(arg2);\n      push(arg3);\n\n      _inner();\n\n      p2 = pop();\n    }\n\n    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p2);\n      restore();\n      return;\n    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (istensor(p1) && istensor(p2)) {\n      inner_f();\n    } else {\n      if (!(_isNumericAtomOrTensor(p1) || _isNumericAtomOrTensor(p2))) {\n        push(p1);\n        push(p2);\n\n        _inv();\n\n        subtract();\n        subtractionResult = pop();\n\n        if (isZeroAtomOrTensor(subtractionResult)) {\n          push_symbol(SYMBOL_IDENTITY_MATRIX);\n          restore();\n          return;\n        }\n      }\n\n      if (expanding && isadd(p1)) {\n        p1 = cdr(p1);\n        push(zero);\n\n        while (iscons(p1)) {\n          push(car(p1));\n          push(p2);\n\n          _inner();\n\n          add();\n          p1 = cdr(p1);\n        }\n\n        restore();\n        return;\n      }\n\n      if (expanding && isadd(p2)) {\n        p2 = cdr(p2);\n        push(zero);\n\n        while (iscons(p2)) {\n          push(p1);\n          push(car(p2));\n\n          _inner();\n\n          add();\n          p2 = cdr(p2);\n        }\n\n        restore();\n        return;\n      }\n\n      push(p1);\n      push(p2);\n\n      if (istensor(p1) && isNumericAtom(p2)) {\n        tensor_times_scalar();\n      } else if (isNumericAtom(p1) && istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        if (isNumericAtom(p1) || isNumericAtom(p2)) {\n          multiply();\n        } else {\n          pop();\n          pop();\n          push_symbol(INNER);\n          push(p1);\n          push(p2);\n          list(3);\n          restore();\n          return;\n        }\n      }\n    }\n\n    return restore();\n  };\n\n  inner_f = function inner_f() {\n    var a, ak, b, bk, c, i, i1, j, j1, k, l1, m1, n, n1, ndim, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    n = p1.tensor.dim[p1.tensor.ndim - 1];\n\n    if (n !== p2.tensor.dim[0]) {\n      debugger;\n      stop(\"inner: tensor dimension check\");\n    }\n\n    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;\n\n    if (ndim > MAXDIM) {\n      stop(\"inner: rank of result exceeds maximum\");\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    ak = 1;\n\n    for (i = o = 0, ref = p1.tensor.ndim - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      ak *= p1.tensor.dim[i];\n    }\n\n    bk = 1;\n\n    for (i = i1 = 1, ref1 = p2.tensor.ndim; 1 <= ref1 ? i1 < ref1 : i1 > ref1; i = 1 <= ref1 ? ++i1 : --i1) {\n      bk *= p2.tensor.dim[i];\n    }\n\n    p3 = alloc_tensor(ak * bk);\n    c = p3.tensor.elem;\n\n    for (i = j1 = 0, ref2 = ak; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = 0, ref3 = n; 0 <= ref3 ? l1 < ref3 : l1 > ref3; j = 0 <= ref3 ? ++l1 : --l1) {\n        if (isZeroAtomOrTensor(a[i * n + j])) {\n          continue;\n        }\n\n        for (k = m1 = 0, ref4 = bk; 0 <= ref4 ? m1 < ref4 : m1 > ref4; k = 0 <= ref4 ? ++m1 : --m1) {\n          push(a[i * n + j]);\n          push(b[j * bk + k]);\n          multiply();\n          push(c[i * bk + k]);\n          add();\n          c[i * bk + k] = pop();\n        }\n      }\n    }\n\n    if (ndim === 0) {\n      return push(p3.tensor.elem[0]);\n    } else {\n      p3.tensor.ndim = ndim;\n      j = 0;\n\n      for (i = n1 = 0, ref5 = p1.tensor.ndim - 1; 0 <= ref5 ? n1 < ref5 : n1 > ref5; i = 0 <= ref5 ? ++n1 : --n1) {\n        p3.tensor.dim[i] = p1.tensor.dim[i];\n      }\n\n      j = p1.tensor.ndim - 1;\n\n      for (i = o1 = 0, ref6 = p2.tensor.ndim - 1; 0 <= ref6 ? o1 < ref6 : o1 > ref6; i = 0 <= ref6 ? ++o1 : --o1) {\n        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];\n      }\n\n      return push(p3);\n    }\n  };\n\n  _get_innerprod_factors = function get_innerprod_factors(tree, factors_accumulator) {\n    if (!iscons(tree)) {\n      add_factor_to_accumulator(tree, factors_accumulator);\n      return;\n    }\n\n    if (cdr(tree) === symbol(NIL)) {\n      tree = _get_innerprod_factors(car(tree), factors_accumulator);\n      return;\n    }\n\n    if (isinnerordot(tree)) {\n      _get_innerprod_factors(car(cdr(tree)), factors_accumulator);\n\n      _get_innerprod_factors(cdr(cdr(tree)), factors_accumulator);\n\n      return;\n    }\n\n    return add_factor_to_accumulator(tree, factors_accumulator);\n  };\n\n  add_factor_to_accumulator = function add_factor_to_accumulator(tree, factors_accumulator) {\n    if (tree !== symbol(NIL)) {\n      return factors_accumulator.push(tree);\n    }\n  };\n  /*\n   Table of integrals\n  \n  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where\n  \n    A  is the template expression\n  \n    B  is the result expression\n  \n    C  is an optional list of conditional expressions\n   */\n\n\n  itab = [\"f(a,a*x)\", \"f(1/x,log(x))\", \"f(x^a,x^(a+1)/(a+1))\", \"f(x^(-2),-x^(-1))\", \"f(x^(-1/2),2*x^(1/2))\", \"f(x^(1/2),2/3*x^(3/2))\", \"f(x,x^2/2)\", \"f(x^2,x^3/3)\", \"f(exp(a*x),1/a*exp(a*x))\", \"f(exp(a*x+b),1/a*exp(a*x+b))\", \"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\", \"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\", \"f(log(a*x),x*log(a*x)-x)\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\", \"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/(a+b*x),1/b*log(a+b*x))\", \"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\", \"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\", \"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\", \"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\", \"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\", \"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\", \"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\", \"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\", \"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\", \"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\", \"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\", \"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\", \"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\", \"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\", \"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\", \"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\", \"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\", \"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\", \"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\", \"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\", \"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\", \"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\", \"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\", \"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\", \"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\", \"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\", \"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\", \"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\", \"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\", \"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\", \"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\", \"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\", \"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\", \"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\", \"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\", \"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\", \"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\", \"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\", \"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\", \"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\", \"f(sin(a*x),-cos(a*x)/a)\", \"f(cos(a*x),sin(a*x)/a)\", \"f(tan(a*x),-log(cos(a*x))/a)\", \"f(1/tan(a*x),log(sin(a*x))/a)\", \"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\", \"f(1/sin(a*x),log(tan(a*x/2))/a)\", \"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\", \"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\", \"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\", \"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\", \"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\", \"f(1/cos(a*x)^2,tan(a*x)/a)\", \"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\", \"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\", \"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\", \"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\", \"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\", \"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\", \"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\", \"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\", \"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\", \"f(sin(a+b*x),-cos(a+b*x)/b)\", \"f(cos(a+b*x),sin(a+b*x)/b)\", \"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\", \"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\", \"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\", \"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\", \"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\", \"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\", \"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\", \"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\", \"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\", \"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\", \"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\", \"f(1/x*1/(a+log(x)),log(a+log(x)))\", \"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\", \"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\", \"f(sinh(x),cosh(x))\", \"f(cosh(x),sinh(x))\", \"f(tanh(x),log(cosh(x)))\", \"f(x*sinh(x),x*cosh(x)-sinh(x))\", \"f(x*cosh(x),x*sinh(x)-cosh(x))\", \"f(sinh(x)^2,sinh(2*x)/4-x/2)\", \"f(tanh(x)^2,x-tanh(x))\", \"f(cosh(x)^2,sinh(2*x)/4+x/2)\", \"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\", \"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\", \"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\", \"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\", \"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\", \"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\", \"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\", \"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\", \"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\", \"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\", \"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\", \"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\", 0];\n\n  Eval_integral = function Eval_integral() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n\n    while (1) {\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n\n        if (isNaN(n)) {\n          stop(\"nth integral: check n\");\n        }\n      } else {\n        n = 1;\n      }\n\n      push(p3);\n\n      if (n >= 0) {\n        for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          integral();\n        }\n      } else {\n        n = -n;\n\n        for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          derivative();\n        }\n      }\n\n      p3 = pop();\n\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n\n        if (p5 === symbol(NIL)) {\n          break;\n        }\n\n        if (isNumericAtom(p5)) {\n          doNothing = 1;\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop();\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n      }\n    }\n\n    return push(p3);\n  };\n\n  integral = function integral() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      integral_of_sum();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      integral_of_product();\n    } else {\n      integral_of_form();\n    }\n\n    p1 = pop();\n\n    if (_Find(p1, symbol(INTEGRAL))) {\n      stop(\"integral: sorry, could not find a solution\");\n    }\n\n    push(p1);\n    simplify();\n    Eval();\n    return restore();\n  };\n\n  integral_of_sum = function integral_of_sum() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    push(p2);\n    integral();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      integral();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  integral_of_product = function integral_of_product() {\n    push(p1);\n    push(p2);\n    partition();\n    p1 = pop();\n    integral_of_form();\n    return multiply();\n  };\n\n  integral_of_form = function integral_of_form() {\n    var hc, tab;\n    hc = italu_hashcode(p1, p2).toFixed(6);\n    tab = hashed_itab[hc];\n\n    if (!tab) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    push(p1);\n    push(p2);\n\n    _transform(tab, false);\n\n    p3 = pop();\n\n    if (p3 === symbol(NIL)) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(p3);\n    }\n  };\n\n  hashcode_values = {\n    'x': 0.95532,\n    'constexp': 1.43762,\n    'constant': 1.14416593629414332,\n    'constbase': 1.20364122304218824,\n    'sin': 1.73305482518303221,\n    'arcsin': 1.6483368529465804,\n    'cos': 1.058672123686340116,\n    'arccos': 1.8405225918106694,\n    'tan': 1.12249437762925064,\n    'arctan': 1.1297397925394962,\n    'sinh': 1.8176164926060078,\n    'cosh': 1.9404934661708022,\n    'tanh': 1.6421307715103121,\n    'log': 1.47744370135492387,\n    'erf': 1.0825269225702916\n  };\n\n  italu_hashcode = function italu_hashcode(u, x) {\n    var half;\n\n    if (issymbol(u)) {\n      if (equal(u, x)) {\n        return hashcode_values.x;\n      } else {\n        return hashcode_values.constant;\n      }\n    } else if (iscons(u)) {\n      switch (symnum(car(u))) {\n        case ADD:\n          return hash_addition(cdr(u), x);\n\n        case MULTIPLY:\n          return hash_multiplication(cdr(u), x);\n\n        case POWER:\n          return hash_power(cadr(u), caddr(u), x);\n\n        case EXP:\n          return hash_power(symbol(E), cadr(u), x);\n\n        case SQRT:\n          push_double(0.5);\n          half = pop();\n          return hash_power(cadr(u), half, x);\n\n        default:\n          return hash_function(u, x);\n      }\n    }\n\n    return hashcode_values.constant;\n  };\n\n  hash_function = function hash_function(u, x) {\n    var arg_hash, base, name;\n\n    if (!_Find(cadr(u), x)) {\n      return hashcode_values.constant;\n    }\n\n    name = car(u);\n    arg_hash = italu_hashcode(cadr(u), x);\n    base = hashcode_values[name.printname];\n\n    if (!base) {\n      throw new Error('Unsupported function ' + name.printname);\n    }\n\n    return Math.pow(base, arg_hash);\n  };\n\n  hash_addition = function hash_addition(terms, x) {\n    var k, sum, term, term_hash, term_set, v;\n    term_set = {};\n\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      term_hash = 0;\n\n      if (_Find(term, x)) {\n        term_hash = italu_hashcode(term, x);\n      } else {\n        term_hash = hashcode_values.constant;\n      }\n\n      term_set[term_hash.toFixed(6)] = true;\n    }\n\n    sum = 0;\n\n    for (k in term_set) {\n      if (!hasProp.call(term_set, k)) continue;\n      v = term_set[k];\n      sum = sum + parseFloat(k, 10);\n    }\n\n    return sum;\n  };\n\n  hash_multiplication = function hash_multiplication(terms, x) {\n    var product, term;\n    product = 1;\n\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n\n      if (_Find(term, x)) {\n        product = product * italu_hashcode(term, x);\n      }\n    }\n\n    return product;\n  };\n\n  hash_power = function hash_power(base, power, x) {\n    var base_hash, exp_hash;\n    base_hash = hashcode_values.constant;\n    exp_hash = hashcode_values.constexp;\n\n    if (_Find(base, x)) {\n      base_hash = italu_hashcode(base, x);\n    }\n\n    if (_Find(power, x)) {\n      exp_hash = italu_hashcode(power, x);\n    } else {\n      if (base_hash === hashcode_values.constant) {\n        return hashcode_values.constant;\n      }\n\n      if (isminusone(power)) {\n        exp_hash = -1;\n      } else if (isoneovertwo(power)) {\n        exp_hash = 0.5;\n      } else if (isminusoneovertwo(power)) {\n        exp_hash = -0.5;\n      } else if (equalq(power, 2, 1)) {\n        exp_hash = 2;\n      } else if (equalq(power, -2, 1)) {\n        exp_hash = -2;\n      }\n    }\n\n    return Math.pow(base_hash, exp_hash);\n  };\n\n  make_hashed_itab = function make_hashed_itab() {\n    var f, h, key, len, o, s, tab, u;\n    tab = {};\n\n    for (o = 0, len = itab.length; o < len; o++) {\n      s = itab[o];\n\n      if (!s) {\n        break;\n      }\n\n      scan_meta(s);\n      f = pop();\n      u = cadr(f);\n      h = italu_hashcode(u, symbol(METAX));\n      key = h.toFixed(6);\n\n      if (!tab[key]) {\n        tab[key] = [];\n      }\n\n      tab[key].push(s);\n    }\n\n    console.log('hashed_itab = ' + JSON.stringify(tab, null, 2));\n    return tab;\n  };\n\n  $.make_hashed_itab = make_hashed_itab;\n  hashed_itab = {\n    \"1.144166\": [\"f(a,a*x)\"],\n    \"1.046770\": [\"f(1/x,log(x))\"],\n    \"0.936400\": [\"f(x^a,x^(a+1)/(a+1))\"],\n    \"1.095727\": [\"f(x^(-2),-x^(-1))\"],\n    \"1.023118\": [\"f(x^(-1/2),2*x^(1/2))\"],\n    \"0.977405\": [\"f(x^(1/2),2/3*x^(3/2))\"],\n    \"0.955320\": [\"f(x,x^2/2)\"],\n    \"0.912636\": [\"f(x^2,x^3/3)\"],\n    \"1.137302\": [\"f(exp(a*x),1/a*exp(a*x))\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\"],\n    \"1.326774\": [\"f(exp(a*x+b),1/a*exp(a*x+b))\"],\n    \"1.080259\": [\"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\"],\n    \"1.260228\": [\"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\"],\n    \"1.451902\": [\"f(log(a*x),x*log(a*x)-x)\"],\n    \"0.486192\": [\"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.697274\": [\"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\"],\n    \"0.476307\": [\"f(1/(a+b*x),1/b*log(a+b*x))\"],\n    \"0.226868\": [\"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\"],\n    \"2.904531\": [\"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\"],\n    \"0.455026\": [\"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\"],\n    \"0.216732\": [\"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\"],\n    \"0.434695\": [\"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\"],\n    \"0.207048\": [\"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\"],\n    \"2.650781\": [\"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\"],\n    \"0.498584\": [\"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\"],\n    \"0.237479\": [\"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\"],\n    \"3.040375\": [\"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\"],\n    \"0.521902\": [\"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\"],\n    \"0.446014\": [\"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\"],\n    \"0.248586\": [\"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\"],\n    \"0.464469\": [\"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\"],\n    \"0.443716\": [\"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\"],\n    \"0.236382\": [\"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\"],\n    \"0.508931\": [\"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\"],\n    \"0.532733\": [\"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\"],\n    \"0.480638\": [\"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\"],\n    \"0.438648\": [\"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\"],\n    \"0.459164\": [\"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.450070\": [\"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\"],\n    \"1.448960\": [\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\"],\n    \"1.384221\": [\"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\"],\n    \"1.322374\": [\"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\"],\n    \"1.516728\": [\"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.587665\": [\"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"0.690150\": [\"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\"],\n    \"0.659314\": [\"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\"],\n    \"0.629856\": [\"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\"],\n    \"0.722428\": [\"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\"],\n    \"0.756216\": [\"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.434156\": [\"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\"],\n    \"0.729886\": [\"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"1.501230\": [\"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"0.666120\": [\"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\"],\n    \"1.370077\": [\"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\"],\n    \"1.730087\": [\"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\"],\n    \"0.578006\": [\"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\"],\n    \"0.552180\": [\"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\"],\n    \"1.652787\": [\"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\"],\n    \"1.308862\": [\"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\"],\n    \"1.342944\": [\"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\"],\n    \"0.636358\": [\"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"0.652928\": [\"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\"],\n    \"0.764022\": [\"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\"],\n    \"1.578940\": [\"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\"],\n    \"1.620055\": [\"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\"],\n    \"0.332117\": [\"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\"],\n    \"1.571443\": [\"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"1.690994\": [\"f(sin(a*x),-cos(a*x)/a)\"],\n    \"1.055979\": [\"f(cos(a*x),sin(a*x)/a)\"],\n    \"1.116714\": [\"f(tan(a*x),-log(cos(a*x))/a)\"],\n    \"0.895484\": [\"f(1/tan(a*x),log(sin(a*x))/a)\"],\n    \"0.946989\": [\"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\"],\n    \"0.591368\": [\"f(1/sin(a*x),log(tan(a*x/2))/a)\"],\n    \"2.859462\": [\"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\"],\n    \"2.128050\": [\"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"1.115091\": [\"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\"],\n    \"1.081452\": [\"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"0.349716\": [\"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\"],\n    \"0.896788\": [\"f(1/cos(a*x)^2,tan(a*x)/a)\"],\n    \"1.785654\": [\"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\"],\n    \"3.188560\": [\"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\"],\n    \"1.516463\": [\"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\"],\n    \"2.707879\": [\"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\"],\n    \"0.369293\": [\"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\"],\n    \"0.560019\": [\"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\"],\n    \"0.530332\": [\"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\"],\n    \"0.331177\": [\"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\"],\n    \"0.313621\": [\"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\"],\n    \"3.172365\": [\"f(sin(a+b*x),-cos(a+b*x)/b)\"],\n    \"1.127162\": [\"f(cos(a+b*x),sin(a+b*x)/b)\"],\n    \"0.352714\": [\"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\"],\n    \"0.454515\": [\"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\"],\n    \"1.615441\": [\"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\"],\n    \"1.543263\": [\"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\"],\n    \"1.008798\": [\"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\"],\n    \"0.963724\": [\"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\"],\n    \"1.611938\": [\"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\"],\n    \"1.791033\": [\"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\"],\n    \"1.123599\": [\"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\"],\n    \"1.387031\": [\"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\"],\n    \"1.325058\": [\"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\"],\n    \"2.108018\": [\"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\"],\n    \"0.403214\": [\"f(1/x*1/(a+log(x)),log(a+log(x)))\"],\n    \"2.269268\": [\"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\"],\n    \"2.486498\": [\"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\"],\n    \"1.769733\": [\"f(sinh(x),cosh(x))\"],\n    \"1.883858\": [\"f(cosh(x),sinh(x))\"],\n    \"1.606140\": [\"f(tanh(x),log(cosh(x)))\"],\n    \"1.690661\": [\"f(x*sinh(x),x*cosh(x)-sinh(x))\"],\n    \"1.799688\": [\"f(x*cosh(x),x*sinh(x)-cosh(x))\"],\n    \"3.131954\": [\"f(sinh(x)^2,sinh(2*x)/4-x/2)\"],\n    \"2.579685\": [\"f(tanh(x)^2,x-tanh(x))\"],\n    \"3.548923\": [\"f(cosh(x)^2,sinh(2*x)/4+x/2)\"],\n    \"1.058866\": [\"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\"],\n    \"1.235270\": [\"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\"],\n    \"1.130783\": [\"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\"],\n    \"1.078698\": [\"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\"],\n    \"2.573650\": [\"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\"],\n    \"2.640666\": [\"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\"],\n    \"1.086487\": [\"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\"],\n    \"1.267493\": [\"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\"],\n    \"1.037943\": [\"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.210862\": [\"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.064970\": [\"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\"],\n    \"1.242392\": [\"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\"]\n  };\n\n  INV_check_arg = function INV_check_arg() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  _inv = function inv() {\n    var accumulator, eachEntry, i, n, o, ref;\n    i = 0;\n    n = 0;\n    save();\n    p1 = pop();\n\n    if (isinv(p1)) {\n      push(car(cdr(p1)));\n      restore();\n      return;\n    }\n\n    if (isidentitymatrix(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n\n      while (iscons(p1)) {\n        accumulator.push(car(p1));\n        p1 = cdr(p1);\n      }\n\n      for (eachEntry = o = ref = accumulator.length - 1; ref <= 0 ? o <= 0 : o >= 0; eachEntry = ref <= 0 ? ++o : --o) {\n        push(accumulator[eachEntry]);\n\n        _inv();\n\n        if (eachEntry !== accumulator.length - 1) {\n          _inner();\n        }\n      }\n\n      restore();\n      return;\n    }\n\n    if (INV_check_arg() === 0) {\n      push_symbol(INV);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    if (_isNumericAtomOrTensor(p1)) {\n      yyinvg();\n    } else {\n      push(p1);\n      adj();\n      push(p1);\n      det();\n      p2 = pop();\n\n      if (isZeroAtomOrTensor(p2)) {\n        stop(\"inverse of singular matrix\");\n      }\n\n      push(p2);\n      divide();\n    }\n\n    return restore();\n  };\n\n  invg = function invg() {\n    save();\n    p1 = pop();\n\n    if (INV_check_arg() === 0) {\n      push_symbol(INVG);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n\n    yyinvg();\n    return restore();\n  };\n\n  yyinvg = function yyinvg() {\n    var h, i, i1, j, j1, l1, n, o, ref, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    h = tos;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i === j) {\n          push(one);\n        } else {\n          push(zero);\n        }\n      }\n    }\n\n    for (i = j1 = 0, ref2 = n * n; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      push(p1.tensor.elem[i]);\n    }\n\n    INV_decomp(n);\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n\n    for (i = l1 = 0, ref3 = n * n; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(tos - 2 * n * n);\n    return push(p1);\n  };\n\n  INV_decomp = function INV_decomp(n) {\n    var a, d, i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4, results, u;\n    a = 0;\n    d = 0;\n    i = 0;\n    j = 0;\n    u = 0;\n    a = tos - n * n;\n    u = a - n * n;\n    results = [];\n\n    for (d = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {\n      if (equal(stack[a + n * d + d], zero)) {\n        for (i = i1 = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? i1 < ref2 : i1 > ref2; i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(stack[a + n * i + d], zero)) {\n            break;\n          }\n        }\n\n        if (i === n) {\n          stop(\"inverse of singular matrix\");\n        }\n\n        for (j = j1 = 0, ref3 = n; 0 <= ref3 ? j1 < ref3 : j1 > ref3; j = 0 <= ref3 ? ++j1 : --j1) {\n          p2 = stack[a + n * d + j];\n          stack[a + n * d + j] = stack[a + n * i + j];\n          stack[a + n * i + j] = p2;\n          p2 = stack[u + n * d + j];\n          stack[u + n * d + j] = stack[u + n * i + j];\n          stack[u + n * i + j] = p2;\n        }\n      }\n\n      p2 = stack[a + n * d + d];\n\n      for (j = l1 = 0, ref4 = n; 0 <= ref4 ? l1 < ref4 : l1 > ref4; j = 0 <= ref4 ? ++l1 : --l1) {\n        if (j > d) {\n          push(stack[a + n * d + j]);\n          push(p2);\n          divide();\n          stack[a + n * d + j] = pop();\n        }\n\n        push(stack[u + n * d + j]);\n        push(p2);\n        divide();\n        stack[u + n * d + j] = pop();\n      }\n\n      results.push(function () {\n        var m1, ref5, results1;\n        results1 = [];\n\n        for (i = m1 = 0, ref5 = n; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i = 0 <= ref5 ? ++m1 : --m1) {\n          if (i === d) {\n            continue;\n          }\n\n          p2 = stack[a + n * i + d];\n          results1.push(function () {\n            var n1, ref6, results2;\n            results2 = [];\n\n            for (j = n1 = 0, ref6 = n; 0 <= ref6 ? n1 < ref6 : n1 > ref6; j = 0 <= ref6 ? ++n1 : --n1) {\n              if (j > d) {\n                push(stack[a + n * i + j]);\n                push(stack[a + n * d + j]);\n                push(p2);\n                multiply();\n                subtract();\n                stack[a + n * i + j] = pop();\n              }\n\n              push(stack[u + n * i + j]);\n              push(stack[u + n * d + j]);\n              push(p2);\n              multiply();\n              subtract();\n              results2.push(stack[u + n * i + j] = pop());\n            }\n\n            return results2;\n          }());\n        }\n\n        return results1;\n      }());\n    }\n\n    return results;\n  };\n\n  DEBUG_IS = false;\n\n  isZeroAtom = function isZeroAtom(p) {\n    switch (p.k) {\n      case NUM:\n        if (MZERO(p.q.a)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === 0.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isZeroTensor = function isZeroTensor(p) {\n    var i, o, ref;\n\n    if (p.k !== TENSOR) {\n      return 0;\n    }\n\n    for (i = o = 0, ref = p.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      if (!isZeroAtomOrTensor(p.tensor.elem[i])) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  isZeroAtomOrTensor = function isZeroAtomOrTensor(p) {\n    return isZeroAtom(p) || isZeroTensor(p);\n  };\n\n  isZeroLikeOrNonZeroLikeOrUndetermined = function isZeroLikeOrNonZeroLikeOrUndetermined(valueOrPredicate) {\n    var evalledArgument;\n    push(valueOrPredicate);\n    Eval_predicate();\n    evalledArgument = pop();\n\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n\n    if (_isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n\n    push(evalledArgument);\n    zzfloat();\n    evalledArgument = pop();\n\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n\n    if (_isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n\n    if (_Find(evalledArgument, imaginaryunit)) {\n      push(evalledArgument);\n      absValFloat();\n      Eval_predicate();\n      evalledArgument = pop();\n\n      if (isZeroAtomOrTensor(evalledArgument)) {\n        return 0;\n      }\n\n      if (_isNumericAtomOrTensor(evalledArgument)) {\n        return 1;\n      }\n    }\n\n    return null;\n  };\n\n  isnegativenumber = function isnegativenumber(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === -1) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d < 0.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  ispositivenumber = function ispositivenumber(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === 1) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d > 0.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isplustwo = function isplustwo(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === 2.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isplusone = function isplusone(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === 1.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isminusone = function isminusone(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === -1.0) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isone = function isone(p) {\n    return isplusone(p) || isminusone(p);\n  };\n\n  isinteger = function isinteger(p) {\n    if (p.k === NUM && MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isintegerorintegerfloat = function isintegerorintegerfloat(p) {\n    if (p.k === DOUBLE) {\n      if (p.d === Math.round(p.d)) {\n        return 1;\n      }\n\n      return 0;\n    }\n\n    return isinteger(p);\n  };\n\n  isnonnegativeinteger = function isnonnegativeinteger(p) {\n    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isposint = function isposint(p) {\n    if (isinteger(p) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isunivarpolyfactoredorexpandedform = function isunivarpolyfactoredorexpandedform(p, x) {\n    if (x == null) {\n      push(p);\n      guess();\n      x = pop();\n      pop();\n    }\n\n    if (ispolyfactoredorexpandedform(p, x) && _Find(p, symbol(SYMBOL_X)) + _Find(p, symbol(SYMBOL_Y)) + _Find(p, symbol(SYMBOL_Z)) === 1) {\n      return x;\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyfactoredorexpandedform = function ispolyfactoredorexpandedform(p, x) {\n    return ispolyfactoredorexpandedform_factor(p, x);\n  };\n\n  ispolyfactoredorexpandedform_factor = function ispolyfactoredorexpandedform_factor(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (DEBUG) {\n          console.log(\"ispolyfactoredorexpandedform_factor testing \" + car(p));\n        }\n\n        if (!ispolyfactoredorexpandedform_power(car(p), x)) {\n          if (DEBUG) {\n            console.log(\"... tested negative:\" + car(p));\n          }\n\n          return 0;\n        }\n\n        p = cdr(p);\n      }\n\n      return 1;\n    } else {\n      return ispolyfactoredorexpandedform_power(p, x);\n    }\n  };\n\n  ispolyfactoredorexpandedform_power = function ispolyfactoredorexpandedform_power(p, x) {\n    if (car(p) === symbol(POWER)) {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power (isposint(caddr(p)) \" + (isposint(caddr(p)), DEBUG ? console.log(\"ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) \" + ispolyexpandedform_expr(cadr(p), x)) : void 0));\n      }\n\n      return isposint(caddr(p)) && ispolyexpandedform_expr(cadr(p), x);\n    } else {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power not a power, testing if this is exp form: \" + p);\n      }\n\n      return ispolyexpandedform_expr(p, x);\n    }\n  };\n\n  ispolyexpandedform = function ispolyexpandedform(p, x) {\n    if (_Find(p, x)) {\n      return ispolyexpandedform_expr(p, x);\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyexpandedform_expr = function ispolyexpandedform_expr(p, x) {\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (!ispolyexpandedform_term(car(p), x)) {\n          return 0;\n        }\n\n        p = cdr(p);\n      }\n\n      return 1;\n    } else {\n      return ispolyexpandedform_term(p, x);\n    }\n  };\n\n  ispolyexpandedform_term = function ispolyexpandedform_term(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (!ispolyexpandedform_factor(car(p), x)) {\n          return 0;\n        }\n\n        p = cdr(p);\n      }\n\n      return 1;\n    } else {\n      return ispolyexpandedform_factor(p, x);\n    }\n  };\n\n  ispolyexpandedform_factor = function ispolyexpandedform_factor(p, x) {\n    if (equal(p, x)) {\n      return 1;\n    }\n\n    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {\n      if (isposint(caddr(p))) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    if (_Find(p, x)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  isnegativeterm = function isnegativeterm(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  hasNegativeRationalExponent = function hasNegativeRationalExponent(p) {\n    if (car(p) === symbol(POWER) && isrational(car(cdr(cdr(p)))) && isnegativenumber(car(cdr(p)))) {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has imaginary component\");\n      }\n\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has NO imaginary component\");\n      }\n\n      return 0;\n    }\n  };\n\n  isimaginarynumberdouble = function isimaginarynumberdouble(p) {\n    if (car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && hasNegativeRationalExponent(caddr(p)) || equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isimaginarynumber = function isimaginarynumber(p) {\n    if (car(p) === symbol(MULTIPLY) && length(p) === 3 && isNumericAtom(cadr(p)) && equal(caddr(p), imaginaryunit) || equal(p, imaginaryunit) || hasNegativeRationalExponent(caddr(p))) {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" is imaginary number\");\n      }\n\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" isn't an imaginary number\");\n      }\n\n      return 0;\n    }\n  };\n\n  iscomplexnumberdouble = function iscomplexnumberdouble(p) {\n    if (car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p)) || isimaginarynumberdouble(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  iscomplexnumber = function iscomplexnumber(p) {\n    if (DEBUG_IS) {\n      debugger;\n    }\n\n    if (car(p) === symbol(ADD) && length(p) === 3 && isNumericAtom(cadr(p)) && isimaginarynumber(caddr(p)) || isimaginarynumber(p)) {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n\n      return 1;\n    } else {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n\n      return 0;\n    }\n  };\n\n  iseveninteger = function iseveninteger(p) {\n    if (isinteger(p) && p.q.a.isEven()) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isnegative = function isnegative(p) {\n    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {\n      return 1;\n    } else if (isnegativeterm(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  _issymbolic = function issymbolic(p) {\n    if (issymbol(p)) {\n      return 1;\n    } else {\n      while (iscons(p)) {\n        if (_issymbolic(car(p))) {\n          return 1;\n        }\n\n        p = cdr(p);\n      }\n\n      return 0;\n    }\n  };\n\n  isintegerfactor = function isintegerfactor(p) {\n    if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isNumberOneOverSomething = function isNumberOneOverSomething(p) {\n    if (isfraction(p) && MEQUAL(p.q.a.abs(), 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isoneover = function isoneover(p) {\n    if (car(p) === symbol(POWER) && isminusone(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isfraction = function isfraction(p) {\n    if (p.k === NUM && !MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  equaln = function equaln(p, n) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === n) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  equalq = function equalq(p, a, b) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {\n          return 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p.d === a / b) {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  isoneovertwo = function isoneovertwo(p) {\n    if (equalq(p, 1, 2)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isminusoneovertwo = function isminusoneovertwo(p) {\n    if (equalq(p, -1, 2)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isoneoversqrttwo = function isoneoversqrttwo(p) {\n    if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isminusoneoversqrttwo = function isminusoneoversqrttwo(p) {\n    if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  _isfloating = function isfloating(p) {\n    if (p.k === DOUBLE || p === symbol(FLOATF)) {\n      return 1;\n    }\n\n    while (iscons(p)) {\n      if (_isfloating(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  isimaginaryunit = function isimaginaryunit(p) {\n    if (equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isquarterturn = function isquarterturn(p) {\n    var minussign, n;\n    n = 0;\n    minussign = 0;\n\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n\n    if (equal(cadr(p), imaginaryunit)) {\n      if (caddr(p) !== symbol(PI)) {\n        return 0;\n      }\n\n      if (length(p) !== 3) {\n        return 0;\n      }\n\n      return 2;\n    }\n\n    if (!isNumericAtom(cadr(p))) {\n      return 0;\n    }\n\n    if (!equal(caddr(p), imaginaryunit)) {\n      return 0;\n    }\n\n    if (cadddr(p) !== symbol(PI)) {\n      return 0;\n    }\n\n    if (length(p) !== 4) {\n      return 0;\n    }\n\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      return 0;\n    }\n\n    if (n < 1) {\n      minussign = 1;\n      n = -n;\n    }\n\n    switch (n % 4) {\n      case 0:\n        n = 1;\n        break;\n\n      case 1:\n        if (minussign) {\n          n = 4;\n        } else {\n          n = 3;\n        }\n\n        break;\n\n      case 2:\n        n = 2;\n        break;\n\n      case 3:\n        if (minussign) {\n          n = 3;\n        } else {\n          n = 4;\n        }\n\n    }\n\n    return n;\n  };\n\n  isnpi = function isnpi(p) {\n    var doNothing, n;\n    n = 0;\n\n    if (p === symbol(PI)) {\n      return 2;\n    }\n\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {\n      doNothing = 0;\n    } else {\n      return 0;\n    }\n\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      return 0;\n    }\n\n    if (n < 0) {\n      n = 4 - -n % 4;\n    } else {\n      n = 1 + (n - 1) % 4;\n    }\n\n    return n;\n  };\n\n  $.isZeroAtomOrTensor = isZeroAtomOrTensor;\n  $.isnegativenumber = isnegativenumber;\n  $.isplusone = isplusone;\n  $.isminusone = isminusone;\n  $.isinteger = isinteger;\n  $.isnonnegativeinteger = isnonnegativeinteger;\n  $.isposint = isposint;\n  $.isnegativeterm = isnegativeterm;\n  $.isimaginarynumber = isimaginarynumber;\n  $.iscomplexnumber = iscomplexnumber;\n  $.iseveninteger = iseveninteger;\n  $.isnegative = isnegative;\n  $.issymbolic = _issymbolic;\n  $.isintegerfactor = isintegerfactor;\n  $.isoneover = isoneover;\n  $.isfraction = isfraction;\n  $.isoneoversqrttwo = isoneoversqrttwo;\n  $.isminusoneoversqrttwo = isminusoneoversqrttwo;\n  $.isfloating = _isfloating;\n  $.isimaginaryunit = isimaginaryunit;\n  $.isquarterturn = isquarterturn;\n  $.isnpi = isnpi;\n\n  Eval_isprime = function Eval_isprime() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n  /*\n   Laguerre function\n  \n  Example\n  \n    laguerre(x,3)\n  \n  Result\n  \n       1   3    3   2\n    - --- x  + --- x  - 3 x + 1\n       6        2\n  \n  The computation uses the following recurrence relation.\n  \n    L(x,0,k) = 1\n  \n    L(x,1,k) = -x + k + 1\n  \n    n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)\n  \n  In the \"for\" loop i = n-1 so the recurrence relation becomes\n  \n    (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)\n   */\n\n\n  Eval_laguerre = function Eval_laguerre() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n\n    return laguerre();\n  };\n\n  laguerre = function laguerre() {\n    var n;\n    n = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push_symbol(LAGUERRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      restore();\n      return;\n    }\n\n    if (issymbol(p1)) {\n      laguerre2(n);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      laguerre2(n);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n\n      _subst();\n\n      Eval();\n    }\n\n    return restore();\n  };\n\n  laguerre2 = function laguerre2(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n    results = [];\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      subtract();\n      push(p3);\n      add();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p3);\n      add();\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      results.push(divide());\n    }\n\n    return results;\n  };\n\n  Eval_lcm = function Eval_lcm() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      lcm();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  lcm = function lcm() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    yylcm();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yylcm = function yylcm() {\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    gcd();\n    push(p1);\n    divide();\n    push(p2);\n    divide();\n    return inverse();\n  };\n  /*\n   Return the leading coefficient of a polynomial.\n  \n  Example\n  \n    leading(5x^2+x+1,x)\n  \n  Result\n  \n    5\n  \n  The result is undefined if P is not a polynomial.\n   */\n\n\n  Eval_leading = function Eval_leading() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n\n    return leading();\n  };\n\n  leading = function leading() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    degree();\n    p3 = pop();\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    filter();\n    return restore();\n  };\n  /*\n   Legendre function\n  \n  Example\n  \n    legendre(x,3,0)\n  \n  Result\n  \n     5   3    3\n    --- x  - --- x\n     2        2\n  \n  The computation uses the following recurrence relation.\n  \n    P(x,0) = 1\n  \n    P(x,1) = x\n  \n    n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)\n  \n  In the \"for\" loop we have i = n-1 so the recurrence relation becomes\n  \n    (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)\n  \n  For m > 0\n  \n    P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)\n   */\n\n\n  Eval_legendre = function Eval_legendre() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n\n    return legendre();\n  };\n\n  legendre = function legendre() {\n    save();\n\n    __legendre();\n\n    return restore();\n  };\n\n  __legendre = function __legendre() {\n    var m, n;\n    m = 0;\n    n = 0;\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    push(p3);\n    m = pop_integer();\n\n    if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {\n      push_symbol(LEGENDRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      return;\n    }\n\n    if (issymbol(p1)) {\n      __legendre2(n, m);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n\n      __legendre2(n, m);\n\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n\n      _subst();\n\n      Eval();\n    }\n\n    return __legendre3(m);\n  };\n\n  __legendre2 = function __legendre2(n, m) {\n    var i, i1, o, ref, ref1, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      multiply();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      divide();\n    }\n\n    results = [];\n\n    for (i = i1 = 0, ref1 = m; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1);\n      results.push(derivative());\n    }\n\n    return results;\n  };\n\n  __legendre3 = function __legendre3(m) {\n    if (m === 0) {\n      return;\n    }\n\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      sine();\n      square();\n    } else if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      cosine();\n      square();\n    } else {\n      push_integer(1);\n      push(p1);\n      square();\n      subtract();\n    }\n\n    push_integer(m);\n    push_rational(1, 2);\n    multiply();\n    power();\n    multiply();\n\n    if (m % 2) {\n      return negate();\n    }\n  };\n\n  list = function list(n) {\n    var listIterator, o, ref, results;\n    listIterator = 0;\n    push(symbol(NIL));\n    results = [];\n\n    for (listIterator = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; listIterator = 0 <= ref ? ++o : --o) {\n      results.push(cons());\n    }\n\n    return results;\n  };\n\n  Eval_log = function Eval_log() {\n    push(cadr(p1));\n    Eval();\n    return logarithm();\n  };\n\n  logarithm = function logarithm() {\n    save();\n    yylog();\n    return restore();\n  };\n\n  yylog = function yylog() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (p1 === symbol(E)) {\n      push_integer(1);\n      return;\n    }\n\n    if (equaln(p1, 1)) {\n      push_integer(0);\n      return;\n    }\n\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      logarithm();\n      push(imaginaryunit);\n\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n\n      multiply();\n      add();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.log(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isfraction(p1)) {\n      push(p1);\n\n      _numerator();\n\n      logarithm();\n      push(p1);\n\n      _denominator();\n\n      logarithm();\n      subtract();\n      return;\n    }\n\n    if (car(p1) === symbol(POWER)) {\n      push(caddr(p1));\n      push(cadr(p1));\n      logarithm();\n      multiply();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        logarithm();\n        add();\n        p1 = cdr(p1);\n      }\n\n      return;\n    }\n\n    push_symbol(LOG);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_lookup = function Eval_lookup() {\n    p1 = cadr(p1);\n\n    if (!iscons(p1) && cadr(p1).k === SYM) {\n      p1 = get_binding(p1);\n    }\n\n    return push(p1);\n  };\n\n  madd = function madd(a, b) {\n    return a.add(b);\n  };\n\n  msub = function msub(a, b) {\n    return a.subtract(b);\n  };\n\n  addf = function addf(a, b) {\n    return a.add(b);\n  };\n\n  subf = function subf(a, b) {\n    return a.subtract(b);\n  };\n\n  ucmp = function ucmp(a, b) {\n    return a.compareAbs(b);\n  };\n\n  mgcd = function mgcd(u, v) {\n    return bigInt.gcd(u, v);\n  };\n\n  new_string = function new_string(s) {\n    save();\n    p1 = new U();\n    p1.k = STR;\n    p1.str = s;\n    push(p1);\n    return restore();\n  };\n\n  out_of_memory = function out_of_memory() {\n    return stop(\"out of memory\");\n  };\n\n  push_zero_matrix = function push_zero_matrix(i, j) {\n    push(alloc_tensor(i * j));\n    stack[tos - 1].tensor.ndim = 2;\n    stack[tos - 1].tensor.dim[0] = i;\n    return stack[tos - 1].tensor.dim[1] = j;\n  };\n\n  push_identity_matrix = function push_identity_matrix(n) {\n    var i, o, ref;\n    push_zero_matrix(n, n);\n    i = 0;\n\n    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      stack[tos - 1].tensor.elem[i * n + i] = one;\n    }\n\n    return check_tensor_dimensions(stack[tos - 1]);\n  };\n\n  push_cars = function push_cars(p) {\n    var results;\n    results = [];\n\n    while (iscons(p)) {\n      push(car(p));\n      results.push(p = cdr(p));\n    }\n\n    return results;\n  };\n\n  peek = function peek() {\n    save();\n    p1 = pop();\n    push(p1);\n    return restore();\n  };\n\n  equal = function equal(p1, p2) {\n    if (_cmp_expr(p1, p2) === 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  lessp = function lessp(p1, p2) {\n    if (_cmp_expr(p1, p2) < 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  sign = function sign(n) {\n    if (n < 0) {\n      return -1;\n    } else if (n > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  _cmp_expr = function cmp_expr(p1, p2) {\n    var n;\n    n = 0;\n\n    if (p1 === p2) {\n      return 0;\n    }\n\n    if (p1 === symbol(NIL)) {\n      return -1;\n    }\n\n    if (p2 === symbol(NIL)) {\n      return 1;\n    }\n\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      return sign(compare_numbers(p1, p2));\n    }\n\n    if (isNumericAtom(p1)) {\n      return -1;\n    }\n\n    if (isNumericAtom(p2)) {\n      return 1;\n    }\n\n    if (isstr(p1) && isstr(p2)) {\n      return sign(strcmp(p1.str, p2.str));\n    }\n\n    if (isstr(p1)) {\n      return -1;\n    }\n\n    if (isstr(p2)) {\n      return 1;\n    }\n\n    if (issymbol(p1) && issymbol(p2)) {\n      return sign(strcmp(get_printname(p1), get_printname(p2)));\n    }\n\n    if (issymbol(p1)) {\n      return -1;\n    }\n\n    if (issymbol(p2)) {\n      return 1;\n    }\n\n    if (istensor(p1) && istensor(p2)) {\n      return compare_tensors(p1, p2);\n    }\n\n    if (istensor(p1)) {\n      return -1;\n    }\n\n    if (istensor(p2)) {\n      return 1;\n    }\n\n    while (iscons(p1) && iscons(p2)) {\n      n = _cmp_expr(car(p1), car(p2));\n\n      if (n !== 0) {\n        return n;\n      }\n\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n\n    if (iscons(p2)) {\n      return -1;\n    }\n\n    if (iscons(p1)) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  length = function length(p) {\n    var n;\n    n = 0;\n\n    while (iscons(p)) {\n      p = cdr(p);\n      n++;\n    }\n\n    return n;\n  };\n\n  unique = function unique(p) {\n    save();\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n\n    _unique_f(p);\n\n    if (p2 !== symbol(NIL)) {\n      p1 = symbol(NIL);\n    }\n\n    p = p1;\n    restore();\n    return p;\n  };\n\n  _unique_f = function unique_f(p) {\n    if (isstr(p)) {\n      if (p1 === symbol(NIL)) {\n        p1 = p;\n      } else if (p !== p1) {\n        p2 = p;\n      }\n\n      return;\n    }\n\n    while (iscons(p)) {\n      _unique_f(car(p));\n\n      if (p2 !== symbol(NIL)) {\n        return;\n      }\n\n      p = cdr(p);\n    }\n  };\n\n  ssqrt = function ssqrt() {\n    push_rational(1, 2);\n    return power();\n  };\n\n  yyexpand = function yyexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  exponential = function exponential() {\n    push_symbol(E);\n    swap();\n    return power();\n  };\n\n  square = function square() {\n    push_integer(2);\n    return power();\n  };\n\n  sort_stack = function sort_stack(n) {\n    var h, subsetOfStack;\n    h = tos - n;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(_cmp_expr);\n    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n  };\n\n  $.equal = equal;\n  $.length = length;\n\n  mmul = function mmul(a, b) {\n    return a.multiply(b);\n  };\n\n  mdiv = function mdiv(a, b) {\n    return a.divide(b);\n  };\n  /*\n  static void\n  addf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # can be signed or unsigned \n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] + b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n  \n  // a = a - b\n  \n  static void\n  subf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # must be signed\n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] - b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n  \n  // a = b * c\n  \n  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000\n  \n  static void\n  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)\n  {\n    int i\n    unsigned long long t = 0; # must be unsigned\n    for (i = 0; i < len; i++) {\n      t += (unsigned long long) b[i] * c\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n    a[i] = (unsigned int) t\n  }\n   */\n\n\n  mmod = function mmod(a, b) {\n    return a.mod(b);\n  };\n\n  mdivrem = function mdivrem(a, b) {\n    var toReturn;\n    toReturn = a.divmod(b);\n    return [toReturn.quotient, toReturn.remainder];\n  };\n\n  Eval_mod = function Eval_mod() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return mod();\n  };\n\n  mod = function mod() {\n    var n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"mod function: divide by zero\");\n    }\n\n    if (!isNumericAtom(p1) || !isNumericAtom(p2)) {\n      push_symbol(MOD);\n      push(p1);\n      push(p2);\n      list(3);\n      restore();\n      return;\n    }\n\n    if (isdouble(p1)) {\n      push(p1);\n      n = pop_integer();\n\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n\n      push_integer(n);\n      p1 = pop();\n    }\n\n    if (isdouble(p2)) {\n      push(p2);\n      n = pop_integer();\n\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n\n      push_integer(n);\n      p2 = pop();\n    }\n\n    if (!isinteger(p1) || !isinteger(p2)) {\n      stop(\"mod function: integer arguments expected\");\n    }\n\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mmod(p1.q.a, p2.q.a);\n    p3.q.b = mint(1);\n    push(p3);\n    return restore();\n  };\n\n  mpow = function mpow(a, n) {\n    return a.pow(n);\n  };\n\n  mprime = function mprime(n) {\n    return n.isProbablePrime();\n  };\n\n  mroot = function mroot(n, index) {\n    var i, j, k, o, ref, x, y;\n    n = n.abs();\n    i = 0;\n    j = 0;\n    k = 0;\n\n    if (index === 0) {\n      stop(\"root index is zero\");\n    }\n\n    k = 0;\n\n    while (n.shiftRight(k) > 0) {\n      k++;\n    }\n\n    if (k === 0) {\n      return mint(0);\n    }\n\n    k = Math.floor((k - 1) / index);\n    j = Math.floor(k / 32 + 1);\n    x = bigInt(j);\n\n    for (i = o = 0, ref = j; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n      x = x.and(bigInt(1).shiftLeft(i).not());\n    }\n\n    while (k >= 0) {\n      x = x.or(bigInt(1).shiftLeft(k));\n      y = mpow(x, index);\n\n      switch (mcmp(y, n)) {\n        case 0:\n          return x;\n\n        case 1:\n          x = x.and(bigInt(1).shiftLeft(k).not());\n      }\n\n      k--;\n    }\n\n    return 0;\n  };\n\n  Eval_multiply = function Eval_multiply() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      multiply();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  multiply = function multiply() {\n    if (esc_flag) {\n      stop(\"escape key stop\");\n    }\n\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply_numbers();\n    } else {\n      save();\n      yymultiply();\n      return restore();\n    }\n  };\n\n  yymultiply = function yymultiply() {\n    var h, i, n, o, ref, ref1;\n    h = 0;\n    i = 0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n\n    if (isZeroAtom(p1) || isZeroAtom(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n\n      return;\n    }\n\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        multiply();\n        add();\n        p1 = cdr(p1);\n      }\n\n      return;\n    }\n\n    if (expanding && isadd(p2)) {\n      p2 = cdr(p2);\n\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n\n      while (iscons(p2)) {\n        push(p1);\n        push(car(p2));\n        multiply();\n        add();\n        p2 = cdr(p2);\n      }\n\n      return;\n    }\n\n    if (!istensor(p1) && istensor(p2)) {\n      push(p1);\n      push(p2);\n      scalar_times_tensor();\n      return;\n    }\n\n    if (istensor(p1) && !istensor(p2)) {\n      push(p1);\n      push(p2);\n      tensor_times_scalar();\n      return;\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n    } else {\n      push(p1);\n      list(1);\n      p1 = pop();\n    }\n\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n    } else {\n      push(p2);\n      list(1);\n      p2 = pop();\n    }\n\n    if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {\n      push(car(p1));\n      push(car(p2));\n      multiply_numbers();\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    } else if (isNumericAtom(car(p1))) {\n      push(car(p1));\n      p1 = cdr(p1);\n    } else if (isNumericAtom(car(p2))) {\n      push(car(p2));\n      p2 = cdr(p2);\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n    }\n\n    parse_p1();\n    parse_p2();\n\n    while (iscons(p1) && iscons(p2)) {\n      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {\n        push_symbol(OPERATOR);\n        push(cdar(p1));\n        push(cdar(p2));\n        append();\n        cons();\n        p1 = cdr(p1);\n        p2 = cdr(p2);\n        parse_p1();\n        parse_p2();\n        continue;\n      }\n\n      switch (_cmp_expr(p3, p4)) {\n        case -1:\n          push(car(p1));\n          p1 = cdr(p1);\n          parse_p1();\n          break;\n\n        case 1:\n          push(car(p2));\n          p2 = cdr(p2);\n          parse_p2();\n          break;\n\n        case 0:\n          combine_factors(h);\n          p1 = cdr(p1);\n          p2 = cdr(p2);\n          parse_p1();\n          parse_p2();\n          break;\n\n        default:\n          stop(\"internal error 2\");\n      }\n    }\n\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p2)) {\n      push(car(p2));\n      p2 = cdr(p2);\n    }\n\n    __normalize_radical_factors(h);\n\n    if (expanding) {\n      for (i = o = ref = h, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n        if (isadd(stack[i])) {\n          multiply_all(tos - h);\n          return;\n        }\n      }\n    }\n\n    n = tos - h;\n\n    if (n === 1) {\n      return;\n    }\n\n    if (isrational(stack[h]) && equaln(stack[h], 1)) {\n      if (n === 2) {\n        p7 = pop();\n        pop();\n        push(p7);\n      } else {\n        stack[h] = symbol(MULTIPLY);\n        list(n);\n      }\n\n      return;\n    }\n\n    list(n);\n    p7 = pop();\n    push_symbol(MULTIPLY);\n    push(p7);\n    return cons();\n  };\n\n  parse_p1 = function parse_p1() {\n    p3 = car(p1);\n    p5 = evaluatingAsFloats ? one_as_double : one;\n\n    if (car(p3) === symbol(POWER)) {\n      p5 = caddr(p3);\n      return p3 = cadr(p3);\n    }\n  };\n\n  parse_p2 = function parse_p2() {\n    p4 = car(p2);\n    p6 = evaluatingAsFloats ? one_as_double : one;\n\n    if (car(p4) === symbol(POWER)) {\n      p6 = caddr(p4);\n      return p4 = cadr(p4);\n    }\n  };\n\n  combine_factors = function combine_factors(h) {\n    push(p4);\n    push(p5);\n    push(p6);\n    add();\n    power();\n    p7 = pop();\n\n    if (isNumericAtom(p7)) {\n      push(stack[h]);\n      push(p7);\n      multiply_numbers();\n      return stack[h] = pop();\n    } else if (car(p7) === symbol(MULTIPLY)) {\n      if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {\n        push(stack[h]);\n        push(cadr(p7));\n        multiply_numbers();\n        stack[h] = pop();\n        return push(caddr(p7));\n      } else {\n        return push(p7);\n      }\n    } else {\n      return push(p7);\n    }\n  };\n\n  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];\n\n  combine_gammas = function combine_gammas(h) {\n    var n;\n    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];\n\n    if (n < 0) {\n      n = -n;\n      push(stack[h]);\n      negate();\n      stack[h] = pop();\n    }\n\n    if (n > 1) {\n      return push(_gamma[n]);\n    }\n  };\n\n  multiply_noexpand = function multiply_noexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply();\n    return expanding = prev_expanding;\n  };\n\n  multiply_all = function multiply_all(n) {\n    var h, i, o, ref;\n    i = 0;\n\n    if (n === 1) {\n      return;\n    }\n\n    if (n === 0) {\n      push(evaluatingAsFloats ? one_as_double : one);\n      return;\n    }\n\n    h = tos - n;\n    push(stack[h]);\n\n    for (i = o = 1, ref = n; 1 <= ref ? o < ref : o > ref; i = 1 <= ref ? ++o : --o) {\n      push(stack[h + i]);\n      multiply();\n    }\n\n    stack[h] = pop();\n    return moveTos(h + 1);\n  };\n\n  multiply_all_noexpand = function multiply_all_noexpand(n) {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply_all(n);\n    return expanding = prev_expanding;\n  };\n\n  divide = function divide() {\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return divide_numbers();\n    } else {\n      inverse();\n      return multiply();\n    }\n  };\n\n  inverse = function inverse() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return invert_number();\n    } else {\n      push_integer(-1);\n      return power();\n    }\n  };\n\n  reciprocate = function reciprocate() {\n    return inverse();\n  };\n\n  negate = function negate() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return negate_number();\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(-1.0);\n      } else {\n        push_integer(-1);\n      }\n\n      return multiply();\n    }\n  };\n\n  negate_expand = function negate_expand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  negate_noexpand = function negate_noexpand() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  __normalize_radical_factors = function __normalize_radical_factors(h) {\n    var i, i1, j1, o, ref, ref1, ref2, ref3, ref4, ref5;\n    i = 0;\n\n    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {\n      return;\n    }\n\n    for (i = o = ref = h + 1, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {\n      if (__is_radical_number(stack[i])) {\n        break;\n      }\n    }\n\n    if (i === tos) {\n      return;\n    }\n\n    save();\n    push(stack[h]);\n    mp_numerator();\n    p1 = pop();\n\n    for (i = i1 = ref2 = h + 1, ref3 = tos; ref2 <= ref3 ? i1 < ref3 : i1 > ref3; i = ref2 <= ref3 ? ++i1 : --i1) {\n      if (isplusone(p1) || isminusone(p1)) {\n        break;\n      }\n\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n\n      if (!isnegativenumber(p4)) {\n        continue;\n      }\n\n      push(p1);\n      push(p3);\n      divide();\n      p5 = pop();\n\n      if (!isinteger(p5)) {\n        continue;\n      }\n\n      p1 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(evaluatingAsFloats ? one_as_double : one);\n      push(p4);\n      add();\n      list(3);\n      stack[i] = pop();\n    }\n\n    push(stack[h]);\n    mp_denominator();\n    p2 = pop();\n\n    for (i = j1 = ref4 = h + 1, ref5 = tos; ref4 <= ref5 ? j1 < ref5 : j1 > ref5; i = ref4 <= ref5 ? ++j1 : --j1) {\n      if (isplusone(p2)) {\n        break;\n      }\n\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n\n      if (isnegativenumber(p4)) {\n        continue;\n      }\n\n      push(p2);\n      push(p3);\n      divide();\n      p5 = pop();\n\n      if (!isinteger(p5)) {\n        continue;\n      }\n\n      p2 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(p4);\n      push(one);\n      subtract();\n\n      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {\n        if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {\n          pop();\n          pop();\n          pop();\n          push(p1);\n          push(p3);\n          divide();\n          p1 = pop();\n          break;\n        }\n      }\n\n      list(3);\n      stack[i] = pop();\n    }\n\n    push(p1);\n    push(p2);\n    divide();\n    stack[h] = pop();\n    return restore();\n  };\n\n  __is_radical_number = function __is_radical_number(p) {\n    if (car(p) === symbol(POWER) && isNumericAtom(cadr(p)) && isNumericAtom(caddr(p)) && !isminusone(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  NROOTS_YMAX = 101;\n  NROOTS_DELTA = 1.0e-6;\n  NROOTS_EPSILON = 1.0e-9;\n\n  NROOTS_ABS = function NROOTS_ABS(z) {\n    return Math.sqrt(z.r * z.r + z.i * z.i);\n  };\n\n  theRandom = 0.0;\n\n  NROOTS_RANDOM = function NROOTS_RANDOM() {\n    return 4.0 * Math.random() - 2.0;\n  };\n\n  numericRootOfPolynomial = function () {\n    function numericRootOfPolynomial() {}\n\n    numericRootOfPolynomial.prototype.r = 0.0;\n    numericRootOfPolynomial.prototype.i = 0.0;\n    return numericRootOfPolynomial;\n  }();\n\n  nroots_a = new numericRootOfPolynomial();\n  nroots_b = new numericRootOfPolynomial();\n  nroots_x = new numericRootOfPolynomial();\n  nroots_y = new numericRootOfPolynomial();\n  nroots_fa = new numericRootOfPolynomial();\n  nroots_fb = new numericRootOfPolynomial();\n  nroots_dx = new numericRootOfPolynomial();\n  nroots_df = new numericRootOfPolynomial();\n  nroots_c = [];\n\n  for (initNRoots = o = 0, ref = NROOTS_YMAX; 0 <= ref ? o < ref : o > ref; initNRoots = 0 <= ref ? ++o : --o) {\n    nroots_c[initNRoots] = new numericRootOfPolynomial();\n  }\n\n  Eval_nroots = function Eval_nroots() {\n    var h, i, i1, j1, k, l1, n, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    p2 = pop();\n    p1 = pop();\n\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"nroots: polynomial?\");\n    }\n\n    h = tos;\n    push(p1);\n    push(p2);\n    n = coeff();\n\n    if (n > NROOTS_YMAX) {\n      stop(\"nroots: degree?\");\n    }\n\n    for (i = i1 = 0, ref1 = n; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      push(stack[h + i]);\n      real();\n\n      _yyfloat();\n\n      Eval();\n      p1 = pop();\n      push(stack[h + i]);\n      imag();\n\n      _yyfloat();\n\n      Eval();\n      p2 = pop();\n\n      if (!isdouble(p1) || !isdouble(p2)) {\n        stop(\"nroots: coefficients?\");\n      }\n\n      nroots_c[i].r = p1.d;\n      nroots_c[i].i = p2.d;\n    }\n\n    moveTos(h);\n    monic(n);\n\n    for (k = j1 = ref2 = n; j1 > 1; k = j1 += -1) {\n      findroot(k);\n\n      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {\n        nroots_a.r = 0.0;\n      }\n\n      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {\n        nroots_a.i = 0.0;\n      }\n\n      push_double(nroots_a.r);\n      push_double(nroots_a.i);\n      push(imaginaryunit);\n      multiply();\n      add();\n      NROOTS_divpoly(k);\n    }\n\n    n = tos - h;\n\n    if (n > 1) {\n      sort_stack(n);\n      p1 = alloc_tensor(n);\n      p1.tensor.ndim = 1;\n      p1.tensor.dim[0] = n;\n\n      for (i = l1 = 0, ref3 = n; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n        p1.tensor.elem[i] = stack[h + i];\n      }\n\n      moveTos(h);\n      return push(p1);\n    }\n  };\n\n  monic = function monic(n) {\n    var i1, k, ref1, t;\n    k = 0;\n    t = 0.0;\n    nroots_y.r = nroots_c[n - 1].r;\n    nroots_y.i = nroots_c[n - 1].i;\n    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;\n\n    for (k = i1 = 0, ref1 = n - 1; 0 <= ref1 ? i1 < ref1 : i1 > ref1; k = 0 <= ref1 ? ++i1 : --i1) {\n      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;\n      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;\n    }\n\n    nroots_c[n - 1].r = 1.0;\n    return nroots_c[n - 1].i = 0.0;\n  };\n\n  findroot = function findroot(n) {\n    var i1, j, j1, k, nrabs, t;\n    j = 0;\n    k = 0;\n    t = 0.0;\n\n    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {\n      nroots_a.r = 0.0;\n      nroots_a.i = 0.0;\n      return;\n    }\n\n    for (j = i1 = 0; i1 < 100; j = ++i1) {\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      compute_fa(n);\n      nroots_b.r = nroots_a.r;\n      nroots_b.i = nroots_a.i;\n      nroots_fb.r = nroots_fa.r;\n      nroots_fb.i = nroots_fa.i;\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n\n      for (k = j1 = 0; j1 < 1000; k = ++j1) {\n        compute_fa(n);\n        nrabs = NROOTS_ABS(nroots_fa);\n\n        if (DEBUG) {\n          console.log(\"nrabs: \" + nrabs);\n        }\n\n        if (nrabs < NROOTS_EPSILON) {\n          return;\n        }\n\n        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {\n          nroots_x.r = nroots_a.r;\n          nroots_x.i = nroots_a.i;\n          nroots_a.r = nroots_b.r;\n          nroots_a.i = nroots_b.i;\n          nroots_b.r = nroots_x.r;\n          nroots_b.i = nroots_x.i;\n          nroots_x.r = nroots_fa.r;\n          nroots_x.i = nroots_fa.i;\n          nroots_fa.r = nroots_fb.r;\n          nroots_fa.i = nroots_fb.i;\n          nroots_fb.r = nroots_x.r;\n          nroots_fb.i = nroots_x.i;\n        }\n\n        nroots_dx.r = nroots_b.r - nroots_a.r;\n        nroots_dx.i = nroots_b.i - nroots_a.i;\n        nroots_df.r = nroots_fb.r - nroots_fa.r;\n        nroots_df.i = nroots_fb.i - nroots_fa.i;\n        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;\n\n        if (t === 0.0) {\n          break;\n        }\n\n        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;\n        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;\n        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);\n        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);\n      }\n    }\n\n    return stop(\"nroots: convergence error\");\n  };\n\n  compute_fa = function compute_fa(n) {\n    var i1, k, ref1, results, t;\n    k = 0;\n    t = 0.0;\n    nroots_x.r = nroots_a.r;\n    nroots_x.i = nroots_a.i;\n    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;\n    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;\n    results = [];\n\n    for (k = i1 = 2, ref1 = n; 2 <= ref1 ? i1 < ref1 : i1 > ref1; k = 2 <= ref1 ? ++i1 : --i1) {\n      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;\n      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;\n      nroots_x.r = t;\n      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;\n      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);\n    }\n\n    return results;\n  };\n\n  NROOTS_divpoly = function NROOTS_divpoly(n) {\n    var i1, j1, k, ref1, ref2, results;\n    k = 0;\n\n    for (k = i1 = ref1 = n - 1; ref1 <= 0 ? i1 < 0 : i1 > 0; k = ref1 <= 0 ? ++i1 : --i1) {\n      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;\n      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;\n    }\n\n    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {\n      stop(\"nroots: residual error\");\n    }\n\n    results = [];\n\n    for (k = j1 = 0, ref2 = n - 1; 0 <= ref2 ? j1 < ref2 : j1 > ref2; k = 0 <= ref2 ? ++j1 : --j1) {\n      nroots_c[k].r = nroots_c[k + 1].r;\n      results.push(nroots_c[k].i = nroots_c[k + 1].i);\n    }\n\n    return results;\n  };\n\n  Eval_numerator = function Eval_numerator() {\n    push(cadr(p1));\n    Eval();\n    return _numerator();\n  };\n\n  _numerator = function numerator() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n\n        _numerator();\n\n        theArgument = cdr(theArgument);\n      }\n\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_numerator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      return push(one);\n    } else {\n      return push(theArgument);\n    }\n  };\n\n  Eval_outer = function Eval_outer() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      outer();\n      results.push(p1 = cdr(p1));\n    }\n\n    return results;\n  };\n\n  outer = function outer() {\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (istensor(p1) && istensor(p2)) {\n      yyouter();\n    } else {\n      push(p1);\n      push(p2);\n\n      if (istensor(p1)) {\n        tensor_times_scalar();\n      } else if (istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        multiply();\n      }\n    }\n\n    return restore();\n  };\n\n  yyouter = function yyouter() {\n    var i, i1, j, j1, k, l1, m1, ndim, nelem, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    k = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n\n    if (ndim > MAXDIM) {\n      stop(\"outer: rank of result exceeds maximum\");\n    }\n\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = i1 = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    j = i;\n\n    for (i = j1 = 0, ref2 = p2.tensor.ndim; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      p3.tensor.dim[j + i] = p2.tensor.dim[i];\n    }\n\n    k = 0;\n\n    for (i = l1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      for (j = m1 = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? m1 < ref4 : m1 > ref4; j = 0 <= ref4 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2.tensor.elem[j]);\n        multiply();\n        p3.tensor.elem[k++] = pop();\n      }\n    }\n\n    return push(p3);\n  };\n  /*\n   Partition a term\n  \n    Input stack:\n  \n      term (factor or product of factors)\n  \n      free variable\n  \n    Output stack:\n  \n      constant expression\n  \n      variable expression\n   */\n\n\n  partition = function partition() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push_integer(1);\n    p3 = pop();\n    p4 = p3;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      if (_Find(car(p1), p2)) {\n        push(p4);\n        push(car(p1));\n        multiply();\n        p4 = pop();\n      } else {\n        push(p3);\n        push(car(p1));\n        multiply();\n        p3 = pop();\n      }\n\n      p1 = cdr(p1);\n    }\n\n    push(p3);\n    push(p4);\n    return restore();\n  };\n  /*\n    Add a pattern i.e. a substitution rule.\n    Substitution rule needs a template as first argument\n    and what to transform it to as second argument.\n    Optional third argument is a boolean test which\n    adds conditions to when the rule is applied.\n   */\n\n\n  Eval_silentpattern = function Eval_silentpattern() {\n    Eval_pattern();\n    pop();\n    return push_symbol(NIL);\n  };\n\n  Eval_pattern = function Eval_pattern() {\n    var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;\n\n    if (!iscons(cdr(p1))) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n\n    firstArgument = car(cdr(p1));\n    secondArgument = car(cdr(cdr(p1)));\n\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n\n    if (!iscons(cdr(cdr(p1)))) {\n      thirdArgument = symbol(NIL);\n    } else {\n      thirdArgument = car(cdr(cdr(cdr(p1))));\n    }\n\n    if (equal(firstArgument, secondArgument)) {\n      stop(\"recursive pattern\");\n    }\n\n    stringKey = \"template: \" + _print_list(firstArgument);\n    stringKey += \" tests: \" + _print_list(thirdArgument);\n\n    if (DEBUG) {\n      console.log(\"pattern stringkey: \" + stringKey);\n    }\n\n    patternPosition = userSimplificationsInStringForm.indexOf(stringKey);\n\n    if (patternPosition === -1) {\n      userSimplificationsInStringForm.push(stringKey);\n      userSimplificationsInListForm.push(cdr(p1));\n    } else {\n      if (DEBUG) {\n        console.log(\"pattern already exists, replacing. \" + cdr(p1));\n      }\n\n      userSimplificationsInStringForm[patternPosition] = stringKey;\n      userSimplificationsInListForm[patternPosition] = cdr(p1);\n    }\n\n    push_symbol(PATTERN);\n    push(cdr(p1));\n    return list(2);\n  };\n  /*\n    Clear all patterns\n   */\n\n\n  do_clearPatterns = function do_clearPatterns() {\n    userSimplificationsInListForm = [];\n    return userSimplificationsInStringForm = [];\n  };\n\n  Eval_clearpatterns = function Eval_clearpatterns() {\n    do_clearPatterns();\n    return push_symbol(NIL);\n  };\n\n  Eval_patternsinfo = function Eval_patternsinfo() {\n    var patternsinfoToBePrinted;\n    patternsinfoToBePrinted = patternsinfo();\n\n    if (patternsinfoToBePrinted !== \"\") {\n      return new_string(patternsinfoToBePrinted);\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  patternsinfo = function patternsinfo() {\n    var i, i1, len, patternsinfoToBePrinted;\n    patternsinfoToBePrinted = \"\";\n\n    for (i1 = 0, len = userSimplificationsInListForm.length; i1 < len; i1++) {\n      i = userSimplificationsInListForm[i1];\n      patternsinfoToBePrinted += userSimplificationsInListForm + \"\\n\";\n    }\n\n    return patternsinfoToBePrinted;\n  };\n  /*\n  Convert complex z to polar form\n  \n    Input:    push  z\n  \n    Output:    Result on stack\n  \n    polar(z) = abs(z) * exp(i * arg(z))\n   */\n\n\n  Eval_polar = function Eval_polar() {\n    push(cadr(p1));\n    Eval();\n    return polar();\n  };\n\n  polar = function polar() {\n    evaluatingPolar++;\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n    push(imaginaryunit);\n    push(p1);\n    arg();\n    multiply();\n    exponential();\n    multiply();\n    evaluatingPolar--;\n    return restore();\n  };\n\n  n_factor_number = 0;\n\n  factor_number = function factor_number() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    n_factor_number = p1.q.a;\n    h = tos;\n    factor_a();\n\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      cons();\n    }\n\n    return restore();\n  };\n\n  factor_a = function factor_a() {\n    var i1, k;\n    k = 0;\n\n    if (n_factor_number.isNegative()) {\n      n_factor_number = setSignTo(n_factor_number, 1);\n      push_integer(-1);\n    }\n\n    for (k = i1 = 0; i1 < 10000; k = ++i1) {\n      try_kth_prime(k);\n\n      if (n_factor_number.compare(1) === 0) {\n        return;\n      }\n    }\n\n    return factor_b();\n  };\n\n  try_kth_prime = function try_kth_prime(k) {\n    var count, d, q, r, ref1;\n    count = 0;\n    d = mint(primetab[k]);\n    count = 0;\n\n    while (1) {\n      if (n_factor_number.compare(1) === 0) {\n        if (count) {\n          push_factor(d, count);\n        }\n\n        return;\n      }\n\n      ref1 = mdivrem(n_factor_number, d), q = ref1[0], r = ref1[1];\n\n      if (r.isZero()) {\n        count++;\n        n_factor_number = q;\n      } else {\n        break;\n      }\n    }\n\n    if (count) {\n      push_factor(d, count);\n    }\n\n    if (mcmp(q, d) === -1) {\n      push_factor(n_factor_number, 1);\n      return n_factor_number = mint(1);\n    }\n  };\n\n  factor_b = function factor_b() {\n    var bigint_one, g, k, l, t, x, xprime;\n    k = 0;\n    l = 0;\n    bigint_one = mint(1);\n    x = mint(5);\n    xprime = mint(2);\n    k = 1;\n    l = 1;\n\n    while (1) {\n      if (mprime(n_factor_number)) {\n        push_factor(n_factor_number, 1);\n        return 0;\n      }\n\n      while (1) {\n        if (esc_flag) {\n          stop(\"esc\");\n        }\n\n        t = msub(xprime, x);\n        t = setSignTo(t, 1);\n        g = mgcd(t, n_factor_number);\n\n        if (MEQUAL(g, 1)) {\n          if (--k === 0) {\n            xprime = x;\n            l *= 2;\n            k = l;\n          }\n\n          t = mmul(x, x);\n          x = madd(t, bigint_one);\n          t = mmod(x, n_factor_number);\n          x = t;\n          continue;\n        }\n\n        push_factor(g, 1);\n\n        if (mcmp(g, n_factor_number) === 0) {\n          return -1;\n        }\n\n        t = mdiv(n_factor_number, g);\n        n_factor_number = t;\n        t = mmod(x, n_factor_number);\n        x = t;\n        t = mmod(xprime, n_factor_number);\n        xprime = t;\n        break;\n      }\n    }\n  };\n\n  push_factor = function push_factor(d, count) {\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = d;\n    p1.q.b = mint(1);\n    push(p1);\n\n    if (count > 1) {\n      push_symbol(POWER);\n      swap();\n      p1 = new U();\n      p1.k = NUM;\n      p1.q.a = mint(count);\n      p1.q.b = mint(1);\n      push(p1);\n      return list(3);\n    }\n  };\n  /* Power function\n  \n    Input:    push  Base\n  \n        push  Exponent\n  \n    Output:    Result on stack\n   */\n\n\n  DEBUG_POWER = false;\n\n  Eval_power = function Eval_power() {\n    if (DEBUG_POWER) {\n      debugger;\n    }\n\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return power();\n  };\n\n  power = function power() {\n    save();\n    yypower();\n    return restore();\n  };\n\n  yypower = function yypower() {\n    var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n;\n\n    if (DEBUG_POWER) {\n      debugger;\n    }\n\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    inputExp = p2;\n    inputBase = p1;\n\n    if (DEBUG_POWER) {\n      console.log(\"POWER: \" + p1 + \" ^ \" + p2);\n    }\n\n    if (equal(p1, one) || isZeroAtomOrTensor(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (equal(p2, one)) {\n      push(p1);\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && isminusone(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n\n      negate();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && isoneovertwo(p2)) {\n      push(imaginaryunit);\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && isminusoneovertwo(p2)) {\n      push(imaginaryunit);\n      negate();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: -1 ^ rational\");\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\" trick: p2.q.a , p2.q.b \" + p2.q.a + \" , \" + p2.q.b);\n      }\n\n      if (p2.q.a < p2.q.b) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n      } else {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push_symbol(POWER);\n        push(p1);\n        push_rational(p2.q.a.mod(p2.q.b), p2.q.b);\n        list(3);\n        list(3);\n\n        if (DEBUG_POWER) {\n          console.log(\" trick applied : \" + stack[tos - 1]);\n        }\n      }\n\n      _rect();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isrational(p1) && isrational(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: isrational(p1) && isrational(p2)\");\n      }\n\n      push(p1);\n      push(p2);\n      qpow();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: both base and exponent are either rational or double \");\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\"POWER - isNumericAtom(p1) && isNumericAtom(p2)\");\n      }\n\n      push(p1);\n      push(p2);\n      dpow();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (istensor(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: istensor(p1) \");\n      }\n\n      power_tensor();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: even power of absolute of real value \");\n      }\n\n      push(cadr(p1));\n      push(p2);\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {\n      push(cadr(p2));\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (p1 === symbol(E) && isdouble(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: p1 == symbol(E) && isdouble(p2) \");\n      }\n\n      push_double(Math.exp(p2.d));\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (p1 === symbol(E) && _Find(p2, imaginaryunit) !== 0 && _Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n\n      if (DEBUG_POWER) {\n        console.log(\"   power: turning complex exponential to rect: \" + stack[tos - 1]);\n      }\n\n      _rect();\n\n      hopefullySimplified = pop();\n\n      if (_Find(hopefullySimplified, symbol(PI)) === 0) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: turned complex exponential to rect: \" + hopefullySimplified);\n        }\n\n        push(hopefullySimplified);\n        return;\n      }\n    }\n\n    if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) \");\n      }\n\n      p1 = cdr(p1);\n      push(car(p1));\n      push(p2);\n      power();\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        power();\n        multiply();\n        p1 = cdr(p1);\n      }\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    is_a_moreThanZero = false;\n\n    if (isNumericAtom(cadr(p1))) {\n      is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));\n    }\n\n    if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) {\n      push(cadr(p1));\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    b_isEven_and_c_isItsInverse = false;\n\n    if (iseveninteger(caddr(p1))) {\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      isThisOne = pop();\n\n      if (isone(isThisOne)) {\n        b_isEven_and_c_isItsInverse = true;\n      }\n    }\n\n    if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse \");\n      }\n\n      push(cadr(p1));\n      abs();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (expanding && isadd(p1) && isNumericAtom(p2)) {\n      push(p2);\n      n = pop_integer();\n\n      if (n > 1 && !isNaN(n)) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: expanding && isadd(p1) && isNumericAtom(p2) \");\n        }\n\n        power_sum(n);\n\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n\n        return;\n      }\n    }\n\n    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) \");\n      }\n\n      push_integer(1);\n      push(cadr(p1));\n      cosine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) \");\n      }\n\n      push_integer(1);\n      push(cadr(p1));\n      sine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n\n      return;\n    }\n\n    if (iscomplexnumber(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\" power - handling the case (a + ib) ^ n\");\n      }\n\n      if (isinteger(p2)) {\n        push(p1);\n        conjugate();\n        p3 = pop();\n        push(p3);\n        push(p3);\n        push(p1);\n        multiply();\n        divide();\n\n        if (!isone(p2)) {\n          push(p2);\n          negate();\n          power();\n        }\n\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n\n        return;\n      }\n\n      if (isNumericAtom(p2)) {\n        push(p1);\n        abs();\n        push(p2);\n        power();\n        push_integer(-1);\n        push(p1);\n        arg();\n        push(p2);\n        multiply();\n\n        if (evaluatingAsFloats || iscomplexnumberdouble(p1) && isdouble(p2)) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n\n        divide();\n        power();\n        multiply();\n\n        if (avoidCalculatingPowersIntoArctans) {\n          if (_Find(stack[tos - 1], symbol(ARCTAN))) {\n            pop();\n            push_symbol(POWER);\n            push(p1);\n            push(p2);\n            list(3);\n          }\n        }\n\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n\n        return;\n      }\n    }\n\n    if (simplify_polar()) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: using simplify_polar\");\n      }\n\n      return;\n    }\n\n    if (DEBUG_POWER) {\n      console.log(\"   power: nothing can be done \");\n    }\n\n    push_symbol(POWER);\n    push(p1);\n    push(p2);\n    list(3);\n\n    if (DEBUG_POWER) {\n      return console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n    }\n  };\n\n  power_sum = function power_sum(n) {\n    var a, i, i1, j, j1, k, l1, ref1, ref2, ref3;\n    a = [];\n    i = 0;\n    j = 0;\n    k = 0;\n    k = length(p1) - 1;\n    push_frame(k * (n + 1));\n    p1 = cdr(p1);\n\n    for (i = i1 = 0, ref1 = k; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n      for (j = j1 = 0, ref2 = n; 0 <= ref2 ? j1 <= ref2 : j1 >= ref2; j = 0 <= ref2 ? ++j1 : --j1) {\n        push(car(p1));\n        push_integer(j);\n        power();\n        stack[frame + i * (n + 1) + j] = pop();\n      }\n\n      p1 = cdr(p1);\n    }\n\n    push_integer(n);\n    factorial();\n    p1 = pop();\n\n    for (i = l1 = 0, ref3 = k; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n      a[i] = 0;\n    }\n\n    push(zero);\n\n    _multinomial_sum(k, n, a, 0, n);\n\n    return pop_frame(k * (n + 1));\n  };\n\n  _multinomial_sum = function multinomial_sum(k, n, a, i, m) {\n    var i1, j, j1, l1, ref1, ref2, ref3;\n    j = 0;\n\n    if (i < k - 1) {\n      for (j = i1 = 0, ref1 = m; 0 <= ref1 ? i1 <= ref1 : i1 >= ref1; j = 0 <= ref1 ? ++i1 : --i1) {\n        a[i] = j;\n\n        _multinomial_sum(k, n, a, i + 1, m - j);\n      }\n\n      return;\n    }\n\n    a[i] = m;\n    push(p1);\n\n    for (j = j1 = 0, ref2 = k; 0 <= ref2 ? j1 < ref2 : j1 > ref2; j = 0 <= ref2 ? ++j1 : --j1) {\n      push_integer(a[j]);\n      factorial();\n      divide();\n    }\n\n    for (j = l1 = 0, ref3 = k; 0 <= ref3 ? l1 < ref3 : l1 > ref3; j = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[frame + j * (n + 1) + a[j]]);\n      multiply();\n    }\n\n    return add();\n  };\n\n  simplify_polar = function simplify_polar() {\n    var doNothing, n;\n    n = 0;\n    n = isquarterturn(p2);\n\n    switch (n) {\n      case 0:\n        doNothing = 1;\n        break;\n\n      case 1:\n        push_integer(1);\n        return 1;\n\n      case 2:\n        push_integer(-1);\n        return 1;\n\n      case 3:\n        push(imaginaryunit);\n        return 1;\n\n      case 4:\n        push(imaginaryunit);\n        negate();\n        return 1;\n    }\n\n    if (car(p2) === symbol(ADD)) {\n      p3 = cdr(p2);\n\n      while (iscons(p3)) {\n        n = isquarterturn(car(p3));\n\n        if (n) {\n          break;\n        }\n\n        p3 = cdr(p3);\n      }\n\n      switch (n) {\n        case 0:\n          return 0;\n\n        case 1:\n          push_integer(1);\n          break;\n\n        case 2:\n          push_integer(-1);\n          break;\n\n        case 3:\n          push(imaginaryunit);\n          break;\n\n        case 4:\n          push(imaginaryunit);\n          negate();\n      }\n\n      push(p2);\n      push(car(p3));\n      subtract();\n      exponential();\n      multiply();\n      return 1;\n    }\n\n    return 0;\n  };\n\n  Eval_prime = function Eval_prime() {\n    push(cadr(p1));\n    Eval();\n    return prime();\n  };\n\n  prime = function prime() {\n    var n;\n    n = 0;\n    n = pop_integer();\n\n    if (n < 1 || n > MAXPRIMETAB) {\n      stop(\"prime: Argument out of range.\");\n    }\n\n    n = primetab[n - 1];\n    return push_integer(n);\n  };\n\n  power_str = \"^\";\n  codeGen = false;\n\n  Eval_print = function Eval_print() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);\n    return push(symbol(NIL));\n  };\n\n  Eval_print2dascii = function Eval_print2dascii() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);\n    return push(symbol(NIL));\n  };\n\n  Eval_printcomputer = function Eval_printcomputer() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);\n    return push(symbol(NIL));\n  };\n\n  Eval_printlatex = function Eval_printlatex() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);\n    return push(symbol(NIL));\n  };\n\n  Eval_printhuman = function Eval_printhuman() {\n    var original_test_flag;\n    original_test_flag = test_flag;\n    test_flag = 0;\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);\n    test_flag = original_test_flag;\n    return push(symbol(NIL));\n  };\n\n  Eval_printlist = function Eval_printlist() {\n    var beenPrinted;\n    beenPrinted = _print(cdr(p1), PRINTMODE_LIST);\n    stringsEmittedByUserPrintouts += beenPrinted;\n    return push(symbol(NIL));\n  };\n\n  _print = function _print(p, passedPrintMode) {\n    var accumulator, origPrintMode;\n    accumulator = \"\";\n\n    while (iscons(p)) {\n      push(car(p));\n      Eval();\n      p2 = pop();\n      /*\n      if (issymbol(car(p)) && car(p) != p2)\n        push_symbol(SETQ);\n        push(car(p));\n        push(p2);\n        list(3);\n        p2 = pop();\n       */\n\n      origPrintMode = printMode;\n\n      if (passedPrintMode === PRINTMODE_COMPUTER) {\n        printMode = PRINTMODE_COMPUTER;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_FULL_PRINT);\n      } else if (passedPrintMode === PRINTMODE_HUMAN) {\n        printMode = PRINTMODE_HUMAN;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_PLAIN_PRINT);\n      } else if (passedPrintMode === PRINTMODE_2DASCII) {\n        printMode = PRINTMODE_2DASCII;\n        accumulator = print2dascii(p2);\n        rememberPrint(accumulator, LAST_2DASCII_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LATEX) {\n        printMode = PRINTMODE_LATEX;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_LATEX_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LIST) {\n        printMode = PRINTMODE_LIST;\n        accumulator = _print_list(p2);\n        rememberPrint(accumulator, LAST_LIST_PRINT);\n      }\n\n      printMode = origPrintMode;\n      p = cdr(p);\n    }\n\n    if (DEBUG) {\n      console.log(\"emttedString from display: \" + stringsEmittedByUserPrintouts);\n    }\n\n    return accumulator;\n  };\n\n  rememberPrint = function rememberPrint(theString, theTypeOfPrint) {\n    var parsedString;\n    scan('\"' + theString + '\"');\n    parsedString = pop();\n    return set_binding(symbol(theTypeOfPrint), parsedString);\n  };\n\n  print_str = function print_str(s) {\n    if (DEBUG) {\n      console.log(\"emttedString from print_str: \" + stringsEmittedByUserPrintouts);\n    }\n\n    return s;\n  };\n\n  print_char = function print_char(c) {\n    return c;\n  };\n\n  collectLatexStringFromReturnValue = function collectLatexStringFromReturnValue(p) {\n    var origPrintMode, originalCodeGen, returnedString;\n    origPrintMode = printMode;\n    printMode = PRINTMODE_LATEX;\n    originalCodeGen = codeGen;\n    codeGen = false;\n    returnedString = print_expr(p);\n    returnedString = returnedString.replace(/_/g, \"\\\\_\");\n    printMode = origPrintMode;\n    codeGen = originalCodeGen;\n\n    if (DEBUG) {\n      console.log(\"emttedString from collectLatexStringFromReturnValue: \" + stringsEmittedByUserPrintouts);\n    }\n\n    return returnedString;\n  };\n\n  printline = function printline(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(p);\n    return accumulator;\n  };\n\n  print_base_of_denom = function print_base_of_denom(p1) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) {\n      accumulator += print_char('(');\n      accumulator += print_expr(p1);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p1);\n    }\n\n    return accumulator;\n  };\n\n  print_expo_of_denom = function print_expo_of_denom(p2) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) {\n      accumulator += print_char('(');\n      accumulator += print_expr(p2);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p2);\n    }\n\n    return accumulator;\n  };\n\n  print_denom = function print_denom(p, d) {\n    var accumulator;\n    accumulator = \"\";\n    save();\n    p1 = cadr(p);\n    p2 = caddr(p);\n\n    if (isminusone(p2)) {\n      accumulator += print_base_of_denom(p1);\n      restore();\n      return accumulator;\n    }\n\n    if (d === 1) {\n      accumulator += print_char('(');\n    }\n\n    push(p2);\n    negate();\n    p2 = pop();\n    accumulator += _print_power(p1, p2);\n\n    if (d === 1) {\n      accumulator += print_char(')');\n    }\n\n    restore();\n    return accumulator;\n  };\n\n  print_a_over_b = function print_a_over_b(p) {\n    var accumulator, d, doNothing, n;\n    accumulator = \"\";\n    flag = 0;\n    n = 0;\n    d = 0;\n    save();\n    n = 0;\n    d = 0;\n    p1 = cdr(p);\n    p2 = car(p1);\n\n    if (isrational(p2)) {\n      push(p2);\n      mp_numerator();\n\n      _absval();\n\n      p3 = pop();\n      push(p2);\n      mp_denominator();\n      p4 = pop();\n\n      if (!isplusone(p3)) {\n        n++;\n      }\n\n      if (!isplusone(p4)) {\n        d++;\n      }\n\n      p1 = cdr(p1);\n    } else {\n      p3 = one;\n      p4 = one;\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (is_denominator(p2)) {\n        d++;\n      } else {\n        n++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('\\\\frac{');\n    }\n\n    if (n === 0) {\n      accumulator += print_char('1');\n    } else {\n      flag = 0;\n      p1 = cdr(p);\n\n      if (isrational(car(p1))) {\n        p1 = cdr(p1);\n      }\n\n      if (!isplusone(p3)) {\n        accumulator += _print_factor(p3);\n        flag = 1;\n      }\n\n      while (iscons(p1)) {\n        p2 = car(p1);\n\n        if (is_denominator(p2)) {\n          doNothing = 1;\n        } else {\n          if (flag) {\n            accumulator += print_multiply_sign();\n          }\n\n          accumulator += _print_factor(p2);\n          flag = 1;\n        }\n\n        p1 = cdr(p1);\n      }\n    }\n\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}{');\n    } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n      accumulator += print_str(\" / \");\n    } else {\n      accumulator += print_str(\"/\");\n    }\n\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char('(');\n    }\n\n    flag = 0;\n    p1 = cdr(p);\n\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    if (!isplusone(p4)) {\n      accumulator += _print_factor(p4);\n      flag = 1;\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (is_denominator(p2)) {\n        if (flag) {\n          accumulator += print_multiply_sign();\n        }\n\n        accumulator += print_denom(p2, d);\n        flag = 1;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char(')');\n    }\n\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}');\n    }\n\n    restore();\n    return accumulator;\n  };\n\n  print_expr = function print_expr(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isadd(p)) {\n      p = cdr(p);\n\n      if (sign_of_term(car(p)) === '-') {\n        accumulator += print_str(\"-\");\n      }\n\n      accumulator += print_term(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (sign_of_term(car(p)) === '+') {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" + \");\n          } else {\n            accumulator += print_str(\"+\");\n          }\n        } else {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" - \");\n          } else {\n            accumulator += print_str(\"-\");\n          }\n        }\n\n        accumulator += print_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (sign_of_term(p) === '-') {\n        accumulator += print_str(\"-\");\n      }\n\n      accumulator += print_term(p);\n    }\n\n    return accumulator;\n  };\n\n  sign_of_term = function sign_of_term(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && lessp(cadr(p), zero)) {\n      accumulator += '-';\n    } else if (isNumericAtom(p) && lessp(p, zero)) {\n      accumulator += '-';\n    } else {\n      accumulator += '+';\n    }\n\n    return accumulator;\n  };\n\n  print_term = function print_term(p) {\n    var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;\n    accumulator = \"\";\n\n    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {\n      accumulator += print_a_over_b(p);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n\n      if (isminusone(car(p))) {\n        p = cdr(p);\n      }\n\n      previousFactorWasANumber = false;\n\n      if (isNumericAtom(car(p))) {\n        previousFactorWasANumber = true;\n      }\n\n      numberOneOverSomething = false;\n\n      if (printMode === PRINTMODE_LATEX && iscons(cdr(p)) && isNumberOneOverSomething(car(p))) {\n        numberOneOverSomething = true;\n        denom = car(p).q.b.toString();\n      }\n\n      if (numberOneOverSomething) {\n        origAccumulator = accumulator;\n        accumulator = \"\";\n      } else {\n        accumulator += _print_factor(car(p));\n      }\n\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (printMode === PRINTMODE_LATEX) {\n          if (previousFactorWasANumber) {\n            if (caar(p) === symbol(POWER)) {\n              if (isNumericAtom(car(cdr(car(p))))) {\n                if (!isfraction(car(cdr(cdr(car(p)))))) {\n                  accumulator += \" \\\\cdot \";\n                }\n              }\n            }\n          }\n        }\n\n        accumulator += print_multiply_sign();\n        accumulator += _print_factor(car(p));\n        previousFactorWasANumber = false;\n\n        if (isNumericAtom(car(p))) {\n          previousFactorWasANumber = true;\n        }\n\n        p = cdr(p);\n      }\n\n      if (numberOneOverSomething) {\n        accumulator = origAccumulator + \"\\\\frac{\" + accumulator + \"}{\" + denom + \"}\";\n      }\n    } else {\n      accumulator += _print_factor(p);\n    }\n\n    return accumulator;\n  };\n\n  print_subexpr = function print_subexpr(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_char('(');\n    accumulator += print_expr(p);\n    accumulator += print_char(')');\n    return accumulator;\n  };\n\n  print_factorial_function = function print_factorial_function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cadr(p);\n\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(p);\n    } else {\n      accumulator += print_expr(p);\n    }\n\n    accumulator += print_char('!');\n    return accumulator;\n  };\n\n  print_ABS_latex = function print_ABS_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\left |\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\right |\");\n    return accumulator;\n  };\n\n  print_BINOMIAL_latex = function print_BINOMIAL_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\binom{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"}{\");\n    accumulator += print_expr(caddr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_DOT_latex = function print_DOT_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\cdot \");\n    accumulator += print_expr(caddr(p));\n    return accumulator;\n  };\n\n  print_DOT_codegen = function print_DOT_codegen(p) {\n    var accumulator;\n    accumulator = \"dot(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \", \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SIN_codegen = function print_SIN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.sin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_COS_codegen = function print_COS_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.cos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_TAN_codegen = function print_TAN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.tan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCSIN_codegen = function print_ARCSIN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.asin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCCOS_codegen = function print_ARCCOS_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.acos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCTAN_codegen = function print_ARCTAN_codegen(p) {\n    var accumulator;\n    accumulator = \"Math.atan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SQRT_latex = function print_SQRT_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\sqrt{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_latex = function print_TRANSPOSE_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n\n    accumulator += print_expr(cadr(p));\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^T\");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_codegen = function print_TRANSPOSE_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"transpose(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_UNIT_codegen = function print_UNIT_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"identity(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_INV_latex = function print_INV_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n\n    accumulator += print_expr(cadr(p));\n\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^{-1}\");\n    return accumulator;\n  };\n\n  print_INV_codegen = function print_INV_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"inv(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_DEFINT_latex = function print_DEFINT_latex(p) {\n    var accumulator, functionBody, i, i1, numberOfIntegrals, originalIntegral, ref1, theIntegral, theVariable;\n    accumulator = \"\";\n    functionBody = car(cdr(p));\n    p = cdr(p);\n    originalIntegral = p;\n    numberOfIntegrals = 0;\n\n    while (iscons(cdr(cdr(p)))) {\n      numberOfIntegrals++;\n      theIntegral = cdr(cdr(p));\n      accumulator += print_str(\"\\\\int^{\");\n      accumulator += print_expr(car(cdr(theIntegral)));\n      accumulator += print_str(\"}_{\");\n      accumulator += print_expr(car(theIntegral));\n      accumulator += print_str(\"} \\\\! \");\n      p = cdr(theIntegral);\n    }\n\n    accumulator += print_expr(functionBody);\n    accumulator += print_str(\" \\\\,\");\n    p = originalIntegral;\n\n    for (i = i1 = 1, ref1 = numberOfIntegrals; 1 <= ref1 ? i1 <= ref1 : i1 >= ref1; i = 1 <= ref1 ? ++i1 : --i1) {\n      theVariable = cdr(p);\n      accumulator += print_str(\" \\\\mathrm{d} \");\n      accumulator += print_expr(car(theVariable));\n\n      if (i < numberOfIntegrals) {\n        accumulator += print_str(\" \\\\, \");\n      }\n\n      p = cdr(cdr(theVariable));\n    }\n\n    return accumulator;\n  };\n\n  print_tensor = function print_tensor(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += _print_tensor_inner(p, 0, 0)[1];\n    return accumulator;\n  };\n\n  _print_tensor_inner = function print_tensor_inner(p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, ref3, retString;\n    accumulator = \"\";\n    accumulator += print_str(\"[\");\n\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        ref2 = _print_tensor_inner(p, j + 1, k), k = ref2[0], retString = ref2[1];\n        accumulator += retString;\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n      }\n    } else {\n      for (i = j1 = 0, ref3 = p.tensor.dim[j]; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n\n        k++;\n      }\n    }\n\n    accumulator += print_str(\"]\");\n    return [k, accumulator];\n  };\n\n  print_tensor_latex = function print_tensor_latex(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (p.tensor.ndim <= 2) {\n      accumulator += _print_tensor_inner_latex(true, p, 0, 0)[1];\n    }\n\n    return accumulator;\n  };\n\n  _print_tensor_inner_latex = function print_tensor_inner_latex(firstLevel, p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, ref3, retString;\n    accumulator = \"\";\n\n    if (firstLevel) {\n      accumulator += \"\\\\begin{bmatrix} \";\n    }\n\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? i1 < ref1 : i1 > ref1; i = 0 <= ref1 ? ++i1 : --i1) {\n        ref2 = _print_tensor_inner_latex(0, p, j + 1, k), k = ref2[0], retString = ref2[1];\n        accumulator += retString;\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" \\\\\\\\ \");\n        }\n      }\n    } else {\n      for (i = j1 = 0, ref3 = p.tensor.dim[j]; 0 <= ref3 ? j1 < ref3 : j1 > ref3; i = 0 <= ref3 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" & \");\n        }\n\n        k++;\n      }\n    }\n\n    if (firstLevel) {\n      accumulator += \" \\\\end{bmatrix}\";\n    }\n\n    return [k, accumulator];\n  };\n\n  print_SUM_latex = function print_SUM_latex(p) {\n    var accumulator;\n    accumulator = \"\\\\sum_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_SUM_codegen = function print_SUM_codegen(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderSum = 0; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderSum += \" + print_expr(body) + \";\" + \" } \" + \" return holderSum;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_TEST_latex = function print_TEST_latex(p) {\n    var accumulator;\n    accumulator = \"\\\\left\\\\{ \\\\begin{array}{ll}\";\n    p = cdr(p);\n\n    while (iscons(p)) {\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"{\";\n        accumulator += print_expr(car(p));\n        accumulator += \"} & otherwise \";\n        accumulator += \" \\\\\\\\\\\\\\\\\";\n        break;\n      }\n\n      accumulator += \"{\";\n      accumulator += print_expr(cadr(p));\n      accumulator += \"} & if & \";\n      accumulator += print_expr(car(p));\n      accumulator += \" \\\\\\\\\\\\\\\\\";\n      p = cddr(p);\n    }\n\n    accumulator = accumulator.substring(0, accumulator.length - 4);\n    return accumulator += \"\\\\end{array} \\\\right.\";\n  };\n\n  print_TEST_codegen = function print_TEST_codegen(p) {\n    var accumulator, howManyIfs;\n    accumulator = \"(function(){\";\n    p = cdr(p);\n    howManyIfs = 0;\n\n    while (iscons(p)) {\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"else {\";\n        accumulator += \"return (\" + print_expr(car(p)) + \");\";\n        accumulator += \"}\";\n        break;\n      }\n\n      if (howManyIfs) {\n        accumulator += \" else \";\n      }\n\n      accumulator += \"if (\" + print_expr(car(p)) + \"){\";\n      accumulator += \"return (\" + print_expr(cadr(p)) + \");\";\n      accumulator += \"}\";\n      howManyIfs++;\n      p = cddr(p);\n    }\n\n    accumulator += \"})()\";\n    return accumulator;\n  };\n\n  print_TESTLT_latex = function print_TESTLT_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" < \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTLE_latex = function print_TESTLE_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\leq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGT_latex = function print_TESTGT_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" > \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGE_latex = function print_TESTGE_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\geq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTEQ_latex = function print_TESTEQ_latex(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" = \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_FOR_codegen = function print_FOR_codegen(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   \" + print_expr(body) + \" } \" + \"})()\";\n    return accumulator;\n  };\n\n  print_DO_codegen = function print_DO_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n\n    while (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n    }\n\n    return accumulator;\n  };\n\n  print_SETQ_codegen = function print_SETQ_codegen(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \" = \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"; \";\n    return accumulator;\n  };\n\n  print_PRODUCT_latex = function print_PRODUCT_latex(p) {\n    var accumulator;\n    accumulator = \"\\\\prod_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_PRODUCT_codegen = function print_PRODUCT_codegen(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderProduct = 1; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderProduct *= \" + print_expr(body) + \";\" + \" } \" + \" return holderProduct;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_base = function print_base(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(cadr(p));\n      accumulator += print_str(')');\n    } else if (isNumericAtom(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {\n      accumulator += print_str('(');\n      accumulator += _print_factor(cadr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += _print_factor(cadr(p));\n    }\n\n    return accumulator;\n  };\n\n  print_exponent = function print_exponent(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    if (iscons(caddr(p)) || isfraction(caddr(p)) || isNumericAtom(caddr(p)) && lessp(caddr(p), zero)) {\n      accumulator += print_str('(');\n      accumulator += print_expr(caddr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += _print_factor(caddr(p));\n    }\n\n    return accumulator;\n  };\n\n  _print_power = function print_power(base, exponent) {\n    var accumulator, denomExponent, newExponent, numExponent;\n    accumulator = \"\";\n\n    if (DEBUG) {\n      console.log(\"power base: \" + base + \" \" + \" exponent: \" + exponent);\n    }\n\n    if (isoneovertwo(exponent)) {\n      if (equaln(base, 2)) {\n        if (codeGen) {\n          accumulator += print_str(\"Math.SQRT2\");\n          return accumulator;\n        }\n      } else {\n        if (printMode === PRINTMODE_LATEX) {\n          accumulator += print_str(\"\\\\sqrt{\");\n          accumulator += print_expr(base);\n          accumulator += print_str(\"}\");\n          return accumulator;\n        } else if (codeGen) {\n          accumulator += print_str(\"Math.sqrt(\");\n          accumulator += print_expr(base);\n          accumulator += print_str(')');\n          return accumulator;\n        }\n      }\n    }\n\n    if (equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1) && base === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.exp(\");\n        accumulator += print_expo_of_denom(exponent);\n        accumulator += print_str(')');\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"e^{\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(\"}\");\n      } else {\n        accumulator += print_str(\"exp(\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      }\n\n      return accumulator;\n    }\n\n    if (codeGen) {\n      accumulator += print_str(\"Math.pow(\");\n      accumulator += print_base_of_denom(base);\n      accumulator += print_str(\", \");\n      accumulator += print_expo_of_denom(exponent);\n      accumulator += print_str(')');\n      return accumulator;\n    }\n\n    if (equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0) || base.printname !== \"x\") {\n      if (base !== symbol(E)) {\n        if (isminusone(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_expr(base);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_expr(base);\n          }\n\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n\n          return accumulator;\n        }\n\n        if (isnegativeterm(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n\n          push(exponent);\n          push_integer(-1);\n          multiply();\n          newExponent = pop();\n\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += _print_power(base, newExponent);\n            accumulator += print_str(')');\n          } else {\n            accumulator += _print_power(base, newExponent);\n          }\n\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n\n          return accumulator;\n        }\n      }\n\n      if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\sqrt\");\n        push(exponent);\n\n        _denominator();\n\n        denomExponent = pop();\n\n        if (!isplustwo(denomExponent)) {\n          accumulator += print_str(\"[\");\n          accumulator += print_expr(denomExponent);\n          accumulator += print_str(\"]\");\n        }\n\n        accumulator += print_str(\"{\");\n        push(exponent);\n\n        _numerator();\n\n        numExponent = pop();\n        exponent = numExponent;\n        accumulator += _print_power(base, exponent);\n        accumulator += print_str(\"}\");\n        return accumulator;\n      }\n    }\n\n    if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {\n      accumulator += print_expr(base);\n    } else {\n      if (isadd(base) || isnegativenumber(base)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(base);\n        accumulator += print_str(')');\n      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str('(');\n        }\n\n        accumulator += _print_factor(base, true);\n\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str(')');\n        }\n      } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {\n        accumulator += print_str('(');\n        accumulator += _print_factor(base);\n        accumulator += print_str(')');\n      } else {\n        accumulator += _print_factor(base);\n      }\n\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(power_str);\n      } else {\n        accumulator += print_str(\"^\");\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        if (print_expr(exponent).length > 1) {\n          accumulator += print_str(\"{\");\n          accumulator += print_expr(exponent);\n          accumulator += print_str(\"}\");\n        } else {\n          accumulator += print_expr(exponent);\n        }\n      } else if (iscons(exponent) || isfraction(exponent) || isNumericAtom(exponent) && lessp(exponent, zero)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      } else {\n        accumulator += _print_factor(exponent);\n      }\n    }\n\n    return accumulator;\n  };\n\n  print_index_function = function print_index_function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(car(p));\n    } else {\n      accumulator += print_expr(car(p));\n    }\n\n    accumulator += print_str('[');\n    p = cdr(p);\n\n    if (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        accumulator += print_str(',');\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n      }\n    }\n\n    accumulator += print_str(']');\n    return accumulator;\n  };\n\n  _print_factor = function print_factor(p, omitParens) {\n    var accumulator, base, exponent, fbody, parameters, returned;\n    accumulator = \"\";\n\n    if (isNumericAtom(p)) {\n      accumulator += print_number(p, false);\n      return accumulator;\n    }\n\n    if (isstr(p)) {\n      accumulator += print_str(\"\\\"\");\n      accumulator += print_str(p.str);\n      accumulator += print_str(\"\\\"\");\n      return accumulator;\n    }\n\n    if (istensor(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_tensor_latex(p);\n      } else {\n        accumulator += print_tensor(p);\n      }\n\n      return accumulator;\n    }\n\n    if (car(p) === symbol(MULTIPLY)) {\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\left (\");\n          } else {\n            accumulator += print_str('(');\n          }\n        }\n      }\n\n      accumulator += print_expr(p);\n\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\right ) \");\n          } else {\n            accumulator += print_str(')');\n          }\n        }\n      }\n\n      return accumulator;\n    } else if (isadd(p)) {\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n\n      accumulator += print_expr(p);\n\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n\n      return accumulator;\n    }\n\n    if (car(p) === symbol(POWER)) {\n      base = cadr(p);\n      exponent = caddr(p);\n      accumulator += _print_power(base, exponent);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(FUNCTION)) {\n      fbody = cadr(p);\n\n      if (!codeGen) {\n        parameters = caddr(p);\n        accumulator += print_str(\"function \");\n\n        if (DEBUG) {\n          console.log(\"emittedString from print_factor \" + stringsEmittedByUserPrintouts);\n        }\n\n        returned = _print_list(parameters);\n        accumulator += returned;\n        accumulator += print_str(\" -> \");\n      }\n\n      accumulator += print_expr(fbody);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(PATTERN)) {\n      accumulator += print_expr(caadr(p));\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\" \\\\rightarrow \");\n      } else {\n        if (printMode === PRINTMODE_HUMAN && !test_flag) {\n          accumulator += print_str(\" -> \");\n        } else {\n          accumulator += print_str(\"->\");\n        }\n      }\n\n      accumulator += print_expr(car(cdr(cadr(p))));\n      return accumulator;\n    }\n\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      accumulator += print_index_function(p);\n      return accumulator;\n    }\n\n    if (car(p) === symbol(FACTORIAL)) {\n      accumulator += print_factorial_function(p);\n      return accumulator;\n    } else if (car(p) === symbol(ABS) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_ABS_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_SQRT_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(TRANSPOSE)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TRANSPOSE_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_TRANSPOSE_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(UNIT)) {\n      if (codeGen) {\n        accumulator += print_UNIT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(INV)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_INV_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_INV_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_BINOMIAL_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_DEFINT_latex(p);\n      return accumulator;\n    } else if (isinnerordot(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_DOT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_DOT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SIN)) {\n      if (codeGen) {\n        accumulator += print_SIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(COS)) {\n      if (codeGen) {\n        accumulator += print_COS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TAN)) {\n      if (codeGen) {\n        accumulator += print_TAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCSIN)) {\n      if (codeGen) {\n        accumulator += print_ARCSIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCCOS)) {\n      if (codeGen) {\n        accumulator += print_ARCCOS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCTAN)) {\n      if (codeGen) {\n        accumulator += print_ARCTAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SUM)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_SUM_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_SUM_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(PRODUCT)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_PRODUCT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_PRODUCT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FOR)) {\n      if (codeGen) {\n        accumulator += print_FOR_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(DO)) {\n      if (codeGen) {\n        accumulator += print_DO_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TEST)) {\n      if (codeGen) {\n        accumulator += print_TEST_codegen(p);\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TEST_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") < (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") <= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") > (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") >= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTEQ)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") === (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTEQ_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FLOOR)) {\n      if (codeGen) {\n        accumulator += \"Math.floor(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lfloor {\" + print_expr(cadr(p)) + \"} \\\\rfloor \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(CEILING)) {\n      if (codeGen) {\n        accumulator += \"Math.ceiling(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lceil {\" + print_expr(cadr(p)) + \"} \\\\rceil \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ROUND)) {\n      if (codeGen) {\n        accumulator += \"Math.round(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SETQ)) {\n      if (codeGen) {\n        accumulator += print_SETQ_codegen(p);\n        return accumulator;\n      } else {\n        accumulator += print_expr(cadr(p));\n        accumulator += print_str(\"=\");\n        accumulator += print_expr(caddr(p));\n        return accumulator;\n      }\n    }\n\n    if (iscons(p)) {\n      accumulator += _print_factor(car(p));\n      p = cdr(p);\n\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n\n      if (iscons(p)) {\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n\n        while (iscons(p)) {\n          accumulator += print_str(\",\");\n          accumulator += print_expr(car(p));\n          p = cdr(p);\n        }\n      }\n\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n\n      return accumulator;\n    }\n\n    if (p === symbol(DERIVATIVE)) {\n      accumulator += print_char('d');\n    } else if (p === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.E\");\n      } else {\n        accumulator += print_str(\"e\");\n      }\n    } else if (p === symbol(PI)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\pi\");\n      } else {\n        accumulator += print_str(\"pi\");\n      }\n    } else {\n      accumulator += print_str(get_printname(p));\n    }\n\n    return accumulator;\n  };\n\n  _print_list = function print_list(p) {\n    var accumulator;\n    accumulator = \"\";\n\n    switch (p.k) {\n      case CONS:\n        accumulator += '(';\n        accumulator += _print_list(car(p));\n\n        if (p === cdr(p) && p !== symbol(NIL)) {\n          console.log(\"oh no recursive!\");\n          debugger;\n        }\n\n        p = cdr(p);\n\n        while (iscons(p)) {\n          accumulator += \" \";\n          accumulator += _print_list(car(p));\n          p = cdr(p);\n\n          if (p === cdr(p) && p !== symbol(NIL)) {\n            console.log(\"oh no recursive!\");\n            debugger;\n          }\n        }\n\n        if (p !== symbol(NIL)) {\n          accumulator += \" . \";\n          accumulator += _print_list(p);\n        }\n\n        accumulator += ')';\n        break;\n\n      case STR:\n        accumulator += p.str;\n        break;\n\n      case NUM:\n      case DOUBLE:\n        accumulator += print_number(p, true);\n        break;\n\n      case SYM:\n        accumulator += get_printname(p);\n        break;\n\n      default:\n        accumulator += \"<tensor>\";\n    }\n\n    return accumulator;\n  };\n\n  print_multiply_sign = function print_multiply_sign() {\n    var accumulator;\n    accumulator = \"\";\n\n    if (printMode === PRINTMODE_LATEX) {\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(\" \");\n      } else {\n        return accumulator;\n      }\n    }\n\n    if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {\n      accumulator += print_str(\" \");\n    } else {\n      accumulator += print_str(\"*\");\n    }\n\n    return accumulator;\n  };\n\n  is_denominator = function is_denominator(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  any_denominators = function any_denominators(p) {\n    var q;\n    p = cdr(p);\n\n    while (iscons(p)) {\n      q = car(p);\n\n      if (is_denominator(q)) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n  /*\n  \n  Prints in \"2d\", e.g. instead of 1/(x+1)^2 :\n  \n        1\n   ----------\n           2\n    (1 + x)\n  \n   Note that although this looks more natural, a) it's not parsable and\n   b) it can be occasionally be ambiguous, such as:\n  \n     1\n   ----\n     2\n   x\n  \n  is 1/x^2 but it also looks a little like x^(1/2)\n   */\n\n\n  YMAX = 10000;\n\n  glyph = function () {\n    function glyph() {}\n\n    glyph.prototype.c = 0;\n    glyph.prototype.x = 0;\n    glyph.prototype.y = 0;\n    return glyph;\n  }();\n\n  chartab = [];\n\n  for (charTabIndex = i1 = 0, ref1 = YMAX; 0 <= ref1 ? i1 < ref1 : i1 > ref1; charTabIndex = 0 <= ref1 ? ++i1 : --i1) {\n    chartab[charTabIndex] = new glyph();\n  }\n\n  yindex = 0;\n  level = 0;\n  emit_x = 0;\n  expr_level = 0;\n  display_flag = 0;\n\n  printchar_nowrap = function printchar_nowrap(character) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += character;\n    return accumulator;\n  };\n\n  printchar = function printchar(character) {\n    return printchar_nowrap(character);\n  };\n\n  print2dascii = function print2dascii(p) {\n    var beenPrinted, h, ref2, w, y;\n    h = 0;\n    w = 0;\n    y = 0;\n    save();\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_top_expr(p);\n    ref2 = get_size(0, yindex), h = ref2[0], w = ref2[1], y = ref2[2];\n\n    if (w > 100) {\n      printline(p);\n      restore();\n      return;\n    }\n\n    beenPrinted = print_glyphs();\n    restore();\n    return beenPrinted;\n  };\n\n  emit_top_expr = function emit_top_expr(p) {\n    if (car(p) === symbol(SETQ)) {\n      emit_expr(cadr(p));\n\n      __emit_str(\" = \");\n\n      emit_expr(caddr(p));\n      return;\n    }\n\n    if (istensor(p)) {\n      return emit_tensor(p);\n    } else {\n      return emit_expr(p);\n    }\n  };\n\n  will_be_displayed_as_fraction = function will_be_displayed_as_fraction(p) {\n    if (level > 0) {\n      return 0;\n    }\n\n    if (isfraction(p)) {\n      return 1;\n    }\n\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n\n    if (isfraction(cadr(p))) {\n      return 1;\n    }\n\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  emit_expr = function emit_expr(p) {\n    expr_level++;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n\n      if (__is_negative(car(p))) {\n        __emit_char('-');\n\n        if (will_be_displayed_as_fraction(car(p))) {\n          __emit_char(' ');\n        }\n      }\n\n      emit_term(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n\n          __emit_char('-');\n\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n\n          __emit_char('+');\n\n          __emit_char(' ');\n        }\n\n        emit_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (__is_negative(p)) {\n        __emit_char('-');\n\n        if (will_be_displayed_as_fraction(p)) {\n          __emit_char(' ');\n        }\n      }\n\n      emit_term(p);\n    }\n\n    return expr_level--;\n  };\n\n  emit_unsigned_expr = function emit_unsigned_expr(p) {\n    var results;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      emit_term(car(p));\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n\n          __emit_char('-');\n\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n\n          __emit_char('+');\n\n          __emit_char(' ');\n        }\n\n        emit_term(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return emit_term(p);\n    }\n  };\n\n  __is_negative = function __is_negative(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    }\n\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  emit_term = function emit_term(p) {\n    var n;\n\n    if (car(p) === symbol(MULTIPLY)) {\n      n = count_denominators(p);\n\n      if (n && level === 0) {\n        return emit_fraction(p, n);\n      } else {\n        return emit_multiply(p, n);\n      }\n    } else {\n      return emit_factor(p);\n    }\n  };\n\n  isdenominator = function isdenominator(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  count_denominators = function count_denominators(p) {\n    var count, q;\n    count = 0;\n    p = cdr(p);\n\n    while (iscons(p)) {\n      q = car(p);\n\n      if (isdenominator(q)) {\n        count++;\n      }\n\n      p = cdr(p);\n    }\n\n    return count;\n  };\n\n  emit_multiply = function emit_multiply(p, n) {\n    var results;\n\n    if (n === 0) {\n      p = cdr(p);\n\n      if (isplusone(car(p)) || isminusone(car(p))) {\n        p = cdr(p);\n      }\n\n      emit_factor(car(p));\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        __emit_char(' ');\n\n        emit_factor(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      emit_numerators(p);\n\n      __emit_char('/');\n\n      if (n > 1 || isfraction(cadr(p))) {\n        __emit_char('(');\n\n        emit_denominators(p);\n        return __emit_char(')');\n      } else {\n        return emit_denominators(p);\n      }\n    }\n  };\n\n  emit_fraction = function emit_fraction(p, d) {\n    var count, doNothing, k1, k2, n, x;\n    count = 0;\n    k1 = 0;\n    k2 = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = one;\n    p4 = one;\n\n    if (isrational(cadr(p))) {\n      push(cadr(p));\n      mp_numerator();\n\n      _absval();\n\n      p3 = pop();\n      push(cadr(p));\n      mp_denominator();\n      p4 = pop();\n    }\n\n    if (isdouble(cadr(p))) {\n      push(cadr(p));\n\n      _absval();\n\n      p3 = pop();\n    }\n\n    if (isplusone(p3)) {\n      n = 0;\n    } else {\n      n = 1;\n    }\n\n    p1 = cdr(p);\n\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        n++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    x = emit_x;\n    k1 = yindex;\n    count = 0;\n\n    if (!isplusone(p3)) {\n      emit_number(p3, 0);\n      count++;\n    }\n\n    p1 = cdr(p);\n\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n\n        if (n === 1) {\n          emit_expr(p2);\n        } else {\n          emit_factor(p2);\n        }\n\n        count++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    if (count === 0) {\n      __emit_char('1');\n    }\n\n    k2 = yindex;\n    count = 0;\n\n    if (!isplusone(p4)) {\n      emit_number(p4, 0);\n      count++;\n      d++;\n    }\n\n    p1 = cdr(p);\n\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n\n    while (iscons(p1)) {\n      p2 = car(p1);\n\n      if (isdenominator(p2)) {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n\n        emit_denominator(p2, d);\n        count++;\n      }\n\n      p1 = cdr(p1);\n    }\n\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  emit_numerators = function emit_numerators(p) {\n    var doNothing, n;\n    save();\n    n = 0;\n    p1 = one;\n    p = cdr(p);\n\n    if (isrational(car(p))) {\n      push(car(p));\n      mp_numerator();\n\n      _absval();\n\n      p1 = pop();\n      p = cdr(p);\n    } else if (isdouble(car(p))) {\n      push(car(p));\n\n      _absval();\n\n      p1 = pop();\n      p = cdr(p);\n    }\n\n    n = 0;\n\n    if (!isplusone(p1)) {\n      emit_number(p1, 0);\n      n++;\n    }\n\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        doNothing = 1;\n      } else {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n\n        emit_factor(car(p));\n        n++;\n      }\n\n      p = cdr(p);\n    }\n\n    if (n === 0) {\n      __emit_char('1');\n    }\n\n    return restore();\n  };\n\n  emit_denominators = function emit_denominators(p) {\n    var n;\n    save();\n    n = 0;\n    p = cdr(p);\n\n    if (isfraction(car(p))) {\n      push(car(p));\n      mp_denominator();\n      p1 = pop();\n      emit_number(p1, 0);\n      n++;\n      p = cdr(p);\n    }\n\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n\n        emit_denominator(car(p), 0);\n        n++;\n      }\n\n      p = cdr(p);\n    }\n\n    return restore();\n  };\n\n  emit_factor = function emit_factor(p) {\n    if (istensor(p)) {\n      if (level === 0) {\n        emit_flat_tensor(p);\n      } else {\n        emit_flat_tensor(p);\n      }\n\n      return;\n    }\n\n    if (isdouble(p)) {\n      emit_number(p, 0);\n      return;\n    }\n\n    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {\n      emit_subexpr(p);\n      return;\n    }\n\n    if (car(p) === symbol(POWER)) {\n      emit_power(p);\n      return;\n    }\n\n    if (iscons(p)) {\n      emit_function(p);\n      return;\n    }\n\n    if (isNumericAtom(p)) {\n      if (level === 0) {\n        emit_numerical_fraction(p);\n      } else {\n        emit_number(p, 0);\n      }\n\n      return;\n    }\n\n    if (issymbol(p)) {\n      emit_symbol(p);\n      return;\n    }\n\n    if (isstr(p)) {\n      emit_string(p);\n    }\n  };\n\n  emit_numerical_fraction = function emit_numerical_fraction(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    save();\n    push(p);\n    mp_numerator();\n\n    _absval();\n\n    p3 = pop();\n    push(p);\n    mp_denominator();\n    p4 = pop();\n\n    if (isplusone(p4)) {\n      emit_number(p3, 0);\n      restore();\n      return;\n    }\n\n    x = emit_x;\n    k1 = yindex;\n    emit_number(p3, 0);\n    k2 = yindex;\n    emit_number(p4, 0);\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  isfactor = function isfactor(p) {\n    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {\n      return 1;\n    }\n\n    if (issymbol(p)) {\n      return 1;\n    }\n\n    if (isfraction(p)) {\n      return 0;\n    }\n\n    if (isnegativenumber(p)) {\n      return 0;\n    }\n\n    if (isNumericAtom(p)) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  emit_power = function emit_power(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n\n    if (cadr(p) === symbol(E)) {\n      __emit_str(\"exp(\");\n\n      emit_expr(caddr(p));\n\n      __emit_char(')');\n\n      return;\n    }\n\n    if (level > 0) {\n      if (isminusone(caddr(p))) {\n        __emit_char('1');\n\n        __emit_char('/');\n\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n      } else {\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n\n        __emit_char('^');\n\n        if (isfactor(caddr(p))) {\n          emit_factor(caddr(p));\n        } else {\n          emit_subexpr(caddr(p));\n        }\n      }\n\n      return;\n    }\n\n    if (__is_negative(caddr(p))) {\n      x = emit_x;\n      k1 = yindex;\n\n      __emit_char('1');\n\n      k2 = yindex;\n      emit_denominator(p, 1);\n      fixup_fraction(x, k1, k2);\n      return;\n    }\n\n    k1 = yindex;\n\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n\n    k2 = yindex;\n    level++;\n    emit_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_denominator = function emit_denominator(p, n) {\n    var k1, k2;\n    k1 = 0;\n    k2 = 0;\n\n    if (isminusone(caddr(p))) {\n      if (n === 1) {\n        emit_expr(cadr(p));\n      } else {\n        emit_factor(cadr(p));\n      }\n\n      return;\n    }\n\n    k1 = yindex;\n\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n\n    k2 = yindex;\n    level++;\n    emit_unsigned_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_function = function emit_function(p) {\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      emit_index_function(p);\n      return;\n    }\n\n    if (car(p) === symbol(FACTORIAL)) {\n      emit_factorial_function(p);\n      return;\n    }\n\n    if (car(p) === symbol(DERIVATIVE)) {\n      __emit_char('d');\n    } else {\n      emit_symbol(car(p));\n    }\n\n    __emit_char('(');\n\n    p = cdr(p);\n\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        __emit_char(',');\n\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n\n    return __emit_char(')');\n  };\n\n  emit_index_function = function emit_index_function(p) {\n    p = cdr(p);\n\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      emit_subexpr(car(p));\n    } else {\n      emit_expr(car(p));\n    }\n\n    __emit_char('[');\n\n    p = cdr(p);\n\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n\n      while (iscons(p)) {\n        __emit_char(',');\n\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n\n    return __emit_char(']');\n  };\n\n  emit_factorial_function = function emit_factorial_function(p) {\n    p = cadr(p);\n\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      emit_subexpr(p);\n    } else {\n      emit_expr(p);\n    }\n\n    return __emit_char('!');\n  };\n\n  emit_subexpr = function emit_subexpr(p) {\n    __emit_char('(');\n\n    emit_expr(p);\n    return __emit_char(')');\n  };\n\n  emit_symbol = function emit_symbol(p) {\n    var i, j1, pPrintName, ref2, results;\n    i = 0;\n\n    if (p === symbol(E)) {\n      __emit_str(\"exp(1)\");\n\n      return;\n    }\n\n    pPrintName = get_printname(p);\n    results = [];\n\n    for (i = j1 = 0, ref2 = pPrintName.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(pPrintName[i]));\n    }\n\n    return results;\n  };\n\n  emit_string = function emit_string(p) {\n    var i, j1, pString, ref2;\n    i = 0;\n    pString = p.str;\n\n    __emit_char('\"');\n\n    for (i = j1 = 0, ref2 = pString.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      __emit_char(pString[i]);\n    }\n\n    return __emit_char('\"');\n  };\n\n  fixup_fraction = function fixup_fraction(x, k1, k2) {\n    var dx, dy, h1, h2, i, j1, ref2, ref3, ref4, results, w, w1, w2, y, y1, y2;\n    dx = 0;\n    dy = 0;\n    i = 0;\n    w = 0;\n    y = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    ref2 = get_size(k1, k2), h1 = ref2[0], w1 = ref2[1], y1 = ref2[2];\n    ref3 = get_size(k2, yindex), h2 = ref3[0], w2 = ref3[1], y2 = ref3[2];\n\n    if (w2 > w1) {\n      dx = (w2 - w1) / 2;\n    } else {\n      dx = 0;\n    }\n\n    dx++;\n    y = y1 + h1 - 1;\n    dy = -y - 1;\n    move(k1, k2, dx, dy);\n\n    if (w2 > w1) {\n      dx = -w1;\n    } else {\n      dx = -w1 + (w1 - w2) / 2;\n    }\n\n    dx++;\n    dy = -y2 + 1;\n    move(k2, yindex, dx, dy);\n\n    if (w2 > w1) {\n      w = w2;\n    } else {\n      w = w1;\n    }\n\n    w += 2;\n    emit_x = x;\n    results = [];\n\n    for (i = j1 = 0, ref4 = w; 0 <= ref4 ? j1 < ref4 : j1 > ref4; i = 0 <= ref4 ? ++j1 : --j1) {\n      results.push(__emit_char('-'));\n    }\n\n    return results;\n  };\n\n  fixup_power = function fixup_power(k1, k2) {\n    var dy, h1, h2, ref2, ref3, w1, w2, y1, y2;\n    dy = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    ref2 = get_size(k1, k2), h1 = ref2[0], w1 = ref2[1], y1 = ref2[2];\n    ref3 = get_size(k2, yindex), h2 = ref3[0], w2 = ref3[1], y2 = ref3[2];\n    dy = -y2 - h2 + 1;\n    dy += y1 - 1;\n    return move(k2, yindex, 0, dy);\n  };\n\n  move = function move(j, k, dx, dy) {\n    var i, j1, ref2, ref3, results;\n    i = 0;\n    results = [];\n\n    for (i = j1 = ref2 = j, ref3 = k; ref2 <= ref3 ? j1 < ref3 : j1 > ref3; i = ref2 <= ref3 ? ++j1 : --j1) {\n      chartab[i].x += dx;\n      results.push(chartab[i].y += dy);\n    }\n\n    return results;\n  };\n\n  get_size = function get_size(j, k) {\n    var h, i, j1, max_x, max_y, min_x, min_y, ref2, ref3, w, y;\n    i = 0;\n    min_x = chartab[j].x;\n    max_x = chartab[j].x;\n    min_y = chartab[j].y;\n    max_y = chartab[j].y;\n\n    for (i = j1 = ref2 = j + 1, ref3 = k; ref2 <= ref3 ? j1 < ref3 : j1 > ref3; i = ref2 <= ref3 ? ++j1 : --j1) {\n      if (chartab[i].x < min_x) {\n        min_x = chartab[i].x;\n      }\n\n      if (chartab[i].x > max_x) {\n        max_x = chartab[i].x;\n      }\n\n      if (chartab[i].y < min_y) {\n        min_y = chartab[i].y;\n      }\n\n      if (chartab[i].y > max_y) {\n        max_y = chartab[i].y;\n      }\n    }\n\n    h = max_y - min_y + 1;\n    w = max_x - min_x + 1;\n    y = min_y;\n    return [h, w, y];\n  };\n\n  displaychar = function displaychar(c) {\n    return __emit_char(c);\n  };\n\n  __emit_char = function __emit_char(c) {\n    if (yindex === YMAX) {\n      return;\n    }\n\n    if (chartab[yindex] == null) {\n      debugger;\n    }\n\n    chartab[yindex].c = c;\n    chartab[yindex].x = emit_x;\n    chartab[yindex].y = 0;\n    yindex++;\n    return emit_x++;\n  };\n\n  __emit_str = function __emit_str(s) {\n    var i, j1, ref2, results;\n    i = 0;\n    results = [];\n\n    for (i = j1 = 0, ref2 = s.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(s[i]));\n    }\n\n    return results;\n  };\n\n  emit_number = function emit_number(p, emit_sign) {\n    var i, j1, l1, m1, ref2, ref3, ref4, results, results1, tmpString;\n    tmpString = \"\";\n    i = 0;\n\n    switch (p.k) {\n      case NUM:\n        tmpString = p.q.a.toString();\n\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n\n        for (i = j1 = 0, ref2 = tmpString.length; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n          __emit_char(tmpString[i]);\n        }\n\n        tmpString = p.q.b.toString();\n\n        if (tmpString === \"1\") {\n          break;\n        }\n\n        __emit_char('/');\n\n        results = [];\n\n        for (i = l1 = 0, ref3 = tmpString.length; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i = 0 <= ref3 ? ++l1 : --l1) {\n          results.push(__emit_char(tmpString[i]));\n        }\n\n        return results;\n        break;\n\n      case DOUBLE:\n        tmpString = doubleToReasonableString(p.d);\n\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n\n        results1 = [];\n\n        for (i = m1 = 0, ref4 = tmpString.length; 0 <= ref4 ? m1 < ref4 : m1 > ref4; i = 0 <= ref4 ? ++m1 : --m1) {\n          results1.push(__emit_char(tmpString[i]));\n        }\n\n        return results1;\n    }\n  };\n\n  cmpGlyphs = function cmpGlyphs(a, b) {\n    if (a.y < b.y) {\n      return -1;\n    }\n\n    if (a.y > b.y) {\n      return 1;\n    }\n\n    if (a.x < b.x) {\n      return -1;\n    }\n\n    if (a.x > b.x) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  print_glyphs = function print_glyphs() {\n    var accumulator, i, j1, ref2, subsetOfStack, x, y;\n    i = 0;\n    accumulator = \"\";\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n\n    for (i = j1 = 0, ref2 = yindex; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        accumulator += printchar('\\n');\n        x = 0;\n        y++;\n      }\n\n      while (chartab[i].x > x) {\n        accumulator += printchar_nowrap(' ');\n        x++;\n      }\n\n      accumulator += printchar_nowrap(chartab[i].c);\n      x++;\n    }\n\n    return accumulator;\n  };\n\n  buffer = \"\";\n\n  getdisplaystr = function getdisplaystr() {\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_expr(pop());\n    fill_buf();\n    return buffer;\n  };\n\n  fill_buf = function fill_buf() {\n    var i, j1, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;\n    tmpBuffer = buffer;\n    sIndex = 0;\n    i = 0;\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n\n    for (i = j1 = 0, ref2 = yindex; 0 <= ref2 ? j1 < ref2 : j1 > ref2; i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        tmpBuffer[sIndex++] = '\\n';\n        x = 0;\n        y++;\n      }\n\n      while (chartab[i].x > x) {\n        tmpBuffer[sIndex++] = ' ';\n        x++;\n      }\n\n      tmpBuffer[sIndex++] = chartab[i].c;\n      x++;\n    }\n\n    return tmpBuffer[sIndex++] = '\\n';\n  };\n\n  N = 100;\n\n  oneElement = function () {\n    function oneElement() {}\n\n    oneElement.prototype.x = 0;\n    oneElement.prototype.y = 0;\n    oneElement.prototype.h = 0;\n    oneElement.prototype.w = 0;\n    oneElement.prototype.index = 0;\n    oneElement.prototype.count = 0;\n    return oneElement;\n  }();\n\n  elem = [];\n\n  for (elelmIndex = j1 = 0; j1 < 10000; elelmIndex = ++j1) {\n    elem[elelmIndex] = new oneElement();\n  }\n\n  SPACE_BETWEEN_COLUMNS = 3;\n  SPACE_BETWEEN_ROWS = 1;\n\n  emit_tensor = function emit_tensor(p) {\n    var col, dx, dy, eh, ew, h, i, l1, m1, n, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, ref6, row, w, x, y;\n    i = 0;\n    n = 0;\n    nrow = 0;\n    ncol = 0;\n    x = 0;\n    y = 0;\n    h = 0;\n    w = 0;\n    dx = 0;\n    dy = 0;\n    eh = 0;\n    ew = 0;\n    row = 0;\n    col = 0;\n\n    if (p.tensor.ndim > 2) {\n      emit_flat_tensor(p);\n      return;\n    }\n\n    nrow = p.tensor.dim[0];\n\n    if (p.tensor.ndim === 2) {\n      ncol = p.tensor.dim[1];\n    } else {\n      ncol = 1;\n    }\n\n    n = nrow * ncol;\n\n    if (n > N) {\n      emit_flat_tensor(p);\n      return;\n    }\n\n    x = emit_x;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      elem[i].index = yindex;\n      elem[i].x = emit_x;\n      emit_expr(p.tensor.elem[i]);\n      elem[i].count = yindex - elem[i].index;\n      ref3 = get_size(elem[i].index, yindex), elem[i].h = ref3[0], elem[i].w = ref3[1], elem[i].y = ref3[2];\n    }\n\n    eh = 0;\n    ew = 0;\n\n    for (i = m1 = 0, ref4 = n; 0 <= ref4 ? m1 < ref4 : m1 > ref4; i = 0 <= ref4 ? ++m1 : --m1) {\n      if (elem[i].h > eh) {\n        eh = elem[i].h;\n      }\n\n      if (elem[i].w > ew) {\n        ew = elem[i].w;\n      }\n    }\n\n    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;\n    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;\n    y = -(h / 2);\n\n    for (row = n1 = 0, ref5 = nrow; 0 <= ref5 ? n1 < ref5 : n1 > ref5; row = 0 <= ref5 ? ++n1 : --n1) {\n      for (col = o1 = 0, ref6 = ncol; 0 <= ref6 ? o1 < ref6 : o1 > ref6; col = 0 <= ref6 ? ++o1 : --o1) {\n        i = row * ncol + col;\n        dx = x - elem[i].x;\n        dy = y - elem[i].y;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n        dx = 0;\n\n        if (col > 0) {\n          dx = col * (ew + SPACE_BETWEEN_COLUMNS);\n        }\n\n        dy = 0;\n\n        if (row > 0) {\n          dy = row * (eh + SPACE_BETWEEN_ROWS);\n        }\n\n        dx += (ew - elem[i].w) / 2;\n        dy += (eh - elem[i].h) / 2;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n      }\n    }\n\n    return emit_x = x + w;\n    /*\n    if 0\n    \n       * left brace\n    \n      for (i = 0; i < h; i++) {\n        if (yindex == YMAX)\n          break\n        chartab[yindex].c = '|'\n        chartab[yindex].x = x - 2\n        chartab[yindex].y = y + i\n        yindex++\n      }\n    \n       * right brace\n    \n      emit_x++\n    \n      for (i = 0; i < h; i++) {\n        if (yindex == YMAX)\n          break\n        chartab[yindex].c = '|'\n        chartab[yindex].x = emit_x\n        chartab[yindex].y = y + i\n        yindex++\n      }\n    \n      emit_x++\n    \n    endif\n     */\n  };\n\n  emit_flat_tensor = function emit_flat_tensor(p) {\n    return _emit_tensor_inner(p, 0, 0);\n  };\n\n  _emit_tensor_inner = function emit_tensor_inner(p, j, k) {\n    var i, l1, ref2;\n    i = 0;\n\n    __emit_char('(');\n\n    for (i = l1 = 0, ref2 = p.tensor.dim[j]; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (j + 1 === p.tensor.ndim) {\n        emit_expr(p.tensor.elem[k]);\n        k = k + 1;\n      } else {\n        k = _emit_tensor_inner(p, j + 1, k);\n      }\n\n      if (i + 1 < p.tensor.dim[j]) {\n        __emit_char(',');\n      }\n    }\n\n    __emit_char(')');\n\n    return k;\n  };\n\n  Eval_product = function Eval_product() {\n    var body, i, indexVariable, j, k, l1, oldIndexVariableValue, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    body = cadr(p1);\n    indexVariable = caddr(p1);\n\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n\n    oldIndexVariableValue = get_binding(indexVariable);\n    push_integer(1);\n\n    for (i = l1 = ref2 = j, ref3 = k; ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n\n      if (DEBUG) {\n        console.log(\"product - factor 1: \" + stack[tos - 1].toString());\n        console.log(\"product - factor 2: \" + stack[tos - 2].toString());\n      }\n\n      multiply();\n\n      if (DEBUG) {\n        console.log(\"product - result: \" + stack[tos - 1].toString());\n      }\n    }\n\n    return set_binding(indexVariable, oldIndexVariableValue);\n  };\n\n  qadd = function qadd() {\n    var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;\n    qadd_frac2 = pop();\n    qadd_frac1 = pop();\n    qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);\n    qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);\n    qadd_numerator = madd(qadd_ab, qadd_ba);\n\n    if (MZERO(qadd_numerator)) {\n      push(zero);\n      return;\n    }\n\n    qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);\n    gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);\n    gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);\n    resultSum = new U();\n    resultSum.k = NUM;\n    resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);\n    resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);\n    return push(resultSum);\n  };\n\n  qdiv = function qdiv() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (MZERO(p2.q.a)) {\n      stop(\"divide by zero\");\n    }\n\n    if (MZERO(p1.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    aa = mmul(p1.q.a, p2.q.b);\n    bb = mmul(p1.q.b, p2.q.a);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  qmul = function qmul() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n\n    aa = mmul(p1.q.a, p2.q.a);\n    bb = mmul(p1.q.b, p2.q.b);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  qpow = function qpow() {\n    save();\n    qpowf();\n    return restore();\n  };\n\n  qpowf = function qpowf() {\n    var a, b, expo, t, x, y;\n    expo = 0;\n    p2 = pop();\n    p1 = pop();\n\n    if (isplusone(p1) || isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n\n    if (isminusone(p1) && isoneovertwo(p2)) {\n      push(imaginaryunit);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      if (isnegativenumber(p2)) {\n        stop(\"divide by zero\");\n      }\n\n      push(zero);\n      return;\n    }\n\n    if (isplusone(p2)) {\n      push(p1);\n      return;\n    }\n\n    if (isinteger(p2)) {\n      push(p2);\n      expo = pop_integer();\n\n      if (isNaN(expo)) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n        return;\n      }\n\n      x = mpow(p1.q.a, Math.abs(expo));\n      y = mpow(p1.q.b, Math.abs(expo));\n\n      if (expo < 0) {\n        t = x;\n        x = y;\n        y = t;\n        x = makeSignSameAs(x, y);\n        y = makePositive(y);\n      }\n\n      p3 = new U();\n      p3.k = NUM;\n      p3.q.a = x;\n      p3.q.b = y;\n      push(p3);\n      return;\n    }\n\n    if (isminusone(p1)) {\n      push(p2);\n      normalize_angle();\n      return;\n    }\n\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      qpow();\n      push_integer(-1);\n      push(p2);\n      qpow();\n      multiply();\n      return;\n    }\n\n    if (!isinteger(p1)) {\n      push(p1);\n      mp_numerator();\n      push(p2);\n      qpow();\n      push(p1);\n      mp_denominator();\n      push(p2);\n      negate();\n      qpow();\n      multiply();\n      return;\n    }\n\n    if (is_small_integer(p1)) {\n      push(p1);\n      push(p2);\n      quickfactor();\n      return;\n    }\n\n    if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    a = p2.q.a;\n    b = p2.q.b;\n    x = mroot(p1.q.a, b);\n\n    if (x === 0) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    y = mpow(x, a);\n    p3 = new U();\n    p3.k = NUM;\n\n    if (p2.q.a.isNegative()) {\n      p3.q.a = bigInt(1);\n      p3.q.b = y;\n    } else {\n      p3.q.a = y;\n      p3.q.b = bigInt(1);\n    }\n\n    return push(p3);\n  };\n\n  normalize_angle = function normalize_angle() {\n    save();\n    p1 = pop();\n\n    if (isinteger(p1)) {\n      if (p1.q.a.isOdd()) {\n        push_integer(-1);\n      } else {\n        push_integer(1);\n      }\n\n      restore();\n      return;\n    }\n\n    push(p1);\n    bignum_truncate();\n    p2 = pop();\n\n    if (isnegativenumber(p1)) {\n      push(p2);\n      push_integer(-1);\n      add();\n      p2 = pop();\n    }\n\n    push(p1);\n    push(p2);\n    subtract();\n    p3 = pop();\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p3);\n    list(3);\n\n    if (p2.q.a.isOdd()) {\n      negate();\n    }\n\n    return restore();\n  };\n\n  is_small_integer = function is_small_integer(p) {\n    return isSmall(p.q.a);\n  };\n\n  quickfactor = function quickfactor() {\n    var h, i, l1, n, ref2, stackIndex;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push(p1);\n    factor_small_number();\n    n = tos - h;\n    stackIndex = h;\n\n    for (i = l1 = 0, ref2 = n; l1 < ref2; i = l1 += 2) {\n      push(stack[stackIndex + i]);\n      push(stack[stackIndex + i + 1]);\n      push(p2);\n      multiply();\n      quickpower();\n    }\n\n    multiply_all(tos - h - n);\n    p1 = pop();\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  quickpower = function quickpower() {\n    var expo;\n    expo = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    bignum_truncate();\n    p3 = pop();\n    push(p2);\n    push(p3);\n    subtract();\n    p4 = pop();\n\n    if (!isZeroAtomOrTensor(p4)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p4);\n      list(3);\n    }\n\n    push(p3);\n    expo = pop_integer();\n\n    if (isNaN(expo)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p3);\n      list(3);\n      restore();\n      return;\n    }\n\n    if (expo === 0) {\n      restore();\n      return;\n    }\n\n    push(p1);\n    bignum_power_number(expo);\n    return restore();\n  };\n\n  Eval_quotient = function Eval_quotient() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p1 = pop();\n\n    if (p1 === symbol(NIL)) {\n      p1 = symbol(SYMBOL_X);\n    }\n\n    push(p1);\n    return divpoly();\n  };\n\n  divpoly = function divpoly() {\n    var dividend, divisor, h, i, l1, m, n, ref2, x;\n    h = 0;\n    i = 0;\n    m = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    dividend = tos;\n    push(p1);\n    push(p3);\n    m = coeff() - 1;\n    divisor = tos;\n    push(p2);\n    push(p3);\n    n = coeff() - 1;\n    x = m - n;\n    push_integer(0);\n    p5 = pop();\n\n    while (x >= 0) {\n      push(stack[dividend + m]);\n      push(stack[divisor + n]);\n      divide();\n      p4 = pop();\n\n      for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        push(stack[dividend + x + i]);\n        push(stack[divisor + i]);\n        push(p4);\n        multiply();\n        subtract();\n        stack[dividend + x + i] = pop();\n      }\n\n      push(p5);\n      push(p4);\n      push(p3);\n      push_integer(x);\n      power();\n      multiply();\n      add();\n      p5 = pop();\n      m--;\n      x--;\n    }\n\n    moveTos(h);\n    push(p5);\n    return restore();\n  };\n\n  Eval_rationalize = function Eval_rationalize() {\n    push(cadr(p1));\n    Eval();\n    return rationalize();\n  };\n\n  rationalize = function rationalize() {\n    var x;\n    x = expanding;\n    yyrationalize();\n    return expanding = x;\n  };\n\n  yyrationalize = function yyrationalize() {\n    var commonDenominator, eachTerm, theArgument;\n    theArgument = pop();\n\n    if (istensor(theArgument)) {\n      __rationalize_tensor(theArgument);\n\n      return;\n    }\n\n    expanding = 0;\n\n    if (car(theArgument) !== symbol(ADD)) {\n      push(theArgument);\n      return;\n    }\n\n    if (DEBUG) {\n      printf(\"rationalize: this is the input expr:\\n\");\n      printline(theArgument);\n    }\n\n    push(one);\n    multiply_denominators(theArgument);\n    commonDenominator = pop();\n\n    if (DEBUG) {\n      printf(\"rationalize: this is the common denominator:\\n\");\n      printline(commonDenominator);\n    }\n\n    push(zero);\n    eachTerm = cdr(theArgument);\n\n    while (iscons(eachTerm)) {\n      push(commonDenominator);\n      push(car(eachTerm));\n      multiply();\n      add();\n      eachTerm = cdr(eachTerm);\n    }\n\n    if (DEBUG) {\n      printf(\"rationalize: original expr times common denominator:\\n\");\n      printline(stack[tos - 1]);\n    }\n\n    Condense();\n\n    if (DEBUG) {\n      printf(\"rationalize: after factoring:\\n\");\n      printline(stack[tos - 1]);\n    }\n\n    push(commonDenominator);\n    divide();\n\n    if (DEBUG) {\n      printf(\"rationalize: after dividing by common denom. (and we're done):\\n\");\n      return printline(stack[tos - 1]);\n    }\n  };\n\n  multiply_denominators = function multiply_denominators(p) {\n    var results;\n\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        multiply_denominators_term(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return multiply_denominators_term(p);\n    }\n  };\n\n  multiply_denominators_term = function multiply_denominators_term(p) {\n    var results;\n\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n\n      while (iscons(p)) {\n        multiply_denominators_factor(car(p));\n        results.push(p = cdr(p));\n      }\n\n      return results;\n    } else {\n      return multiply_denominators_factor(p);\n    }\n  };\n\n  multiply_denominators_factor = function multiply_denominators_factor(p) {\n    if (car(p) !== symbol(POWER)) {\n      return;\n    }\n\n    push(p);\n    p = caddr(p);\n\n    if (isnegativenumber(p)) {\n      inverse();\n\n      __lcm();\n\n      return;\n    }\n\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      inverse();\n\n      __lcm();\n\n      return;\n    }\n\n    return pop();\n  };\n\n  __rationalize_tensor = function __rationalize_tensor(theTensor) {\n    var i, l1, n, ref2;\n    i = 0;\n    push(theTensor);\n    Eval();\n    theTensor = pop();\n\n    if (!istensor(theTensor)) {\n      push(theTensor);\n      return;\n    }\n\n    n = theTensor.tensor.nelem;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      push(theTensor.tensor.elem[i]);\n      rationalize();\n      theTensor.tensor.elem[i] = pop();\n    }\n\n    check_tensor_dimensions(theTensor);\n    return push(theTensor);\n  };\n\n  __lcm = function __lcm() {\n    save();\n    p1 = pop();\n    p2 = pop();\n    push(p1);\n    push(p2);\n    multiply();\n    push(p1);\n    push(p2);\n    gcd();\n    divide();\n    return restore();\n  };\n  /*\n   Returns the real part of complex z\n  \n    z    real(z)\n    -    -------\n  \n    a + i b    a\n  \n    exp(i a)  cos(a)\n   */\n\n\n  Eval_real = function Eval_real() {\n    push(cadr(p1));\n    Eval();\n    return real();\n  };\n\n  real = function real() {\n    save();\n\n    _rect();\n\n    p1 = pop();\n    push(p1);\n    push(p1);\n    conjugate();\n    add();\n    push_integer(2);\n    divide();\n    return restore();\n  };\n  /*\n  Convert complex z to rectangular form\n  \n    Input:    push  z\n  \n    Output:    Result on stack\n   */\n\n\n  DEBUG_RECT = false;\n\n  Eval_rect = function Eval_rect() {\n    push(cadr(p1));\n    Eval();\n    return _rect();\n  };\n\n  _rect = function rect() {\n    var input;\n    save();\n    p1 = pop();\n    input = p1;\n\n    if (DEBUG_RECT) {\n      console.log(\"RECT of \" + input);\n    }\n\n    if (DEBUG_RECT) {\n      console.log(\"any clock forms in : \" + input + \" ? \" + _findPossibleClockForm(input));\n    }\n\n    if (issymbol(p1)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push(p1);\n      } else {\n        push_symbol(YYRECT);\n        push(p1);\n        list(2);\n      }\n    } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !_findPossibleExponentialForm(p1) && !_findPossibleClockForm(p1) && !(_Find(p1, symbol(SIN)) && _Find(p1, symbol(COS)) && _Find(p1, imaginaryunit))) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n\n      push(p1);\n    } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      push(p1);\n    } else if (car(p1) === symbol(ADD)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is a sum \");\n      }\n\n      push_integer(0);\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _rect();\n\n        add();\n        p1 = cdr(p1);\n      }\n    } else {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is NOT a sum \");\n      }\n\n      push(p1);\n      abs();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" abs: \" + stack[tos - 1].toString());\n      }\n\n      push(p1);\n      arg();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" arg of \" + p1 + \" : \" + stack[tos - 1].toString());\n      }\n\n      p1 = pop();\n      push(p1);\n      cosine();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cosine: \" + stack[tos - 1].toString());\n      }\n\n      push(imaginaryunit);\n      push(p1);\n      sine();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" sine: \" + stack[tos - 1].toString());\n      }\n\n      multiply();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" i * sine: \" + stack[tos - 1].toString());\n      }\n\n      add();\n\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cos + i * sine: \" + stack[tos - 1].toString());\n      }\n\n      multiply();\n    }\n\n    restore();\n\n    if (DEBUG_RECT) {\n      return console.log(\"rect of \" + input + \" : \" + stack[tos - 1]);\n    }\n  };\n\n  show_power_debug = false;\n  performing_roots = false;\n\n  Eval_roots = function Eval_roots() {\n    p2 = cadr(p1);\n\n    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n      push(cadr(p2));\n      Eval();\n      push(caddr(p2));\n      Eval();\n      subtract();\n    } else {\n      push(p2);\n      Eval();\n      p2 = pop();\n\n      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n        push(cadr(p2));\n        Eval();\n        push(caddr(p2));\n        Eval();\n        subtract();\n      } else {\n        push(p2);\n      }\n    }\n\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    p2 = pop();\n    p1 = pop();\n\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"roots: 1st argument is not a polynomial\");\n    }\n\n    push(p1);\n    push(p2);\n    return roots();\n  };\n\n  hasImaginaryCoeff = function hasImaginaryCoeff(k) {\n    var h, i, imaginaryCoefficients, l1, ref2;\n    imaginaryCoefficients = false;\n    h = tos;\n\n    for (i = l1 = ref2 = k; l1 > 0; i = l1 += -1) {\n      if (iscomplexnumber(stack[tos - i])) {\n        imaginaryCoefficients = true;\n        break;\n      }\n    }\n\n    return imaginaryCoefficients;\n  };\n\n  isSimpleRoot = function isSimpleRoot(k) {\n    var h, i, isSimpleRootPolynomial, l1, ref2;\n\n    if (k > 2) {\n      isSimpleRootPolynomial = true;\n      h = tos;\n\n      if (isZeroAtomOrTensor(stack[tos - k])) {\n        isSimpleRootPolynomial = false;\n      }\n\n      for (i = l1 = ref2 = k - 1; l1 > 1; i = l1 += -1) {\n        if (!isZeroAtomOrTensor(stack[tos - i])) {\n          isSimpleRootPolynomial = false;\n          break;\n        }\n      }\n    } else {\n      isSimpleRootPolynomial = false;\n    }\n\n    return isSimpleRootPolynomial;\n  };\n\n  normalisedCoeff = function normalisedCoeff() {\n    var divideBy, i, k, l1, m1, miniStack, ref2, ref3;\n    k = coeff();\n    divideBy = stack[tos - 1];\n    miniStack = [];\n\n    for (i = l1 = 1, ref2 = k; 1 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n      miniStack.push(pop());\n    }\n\n    for (i = m1 = ref3 = k - 1; ref3 <= 0 ? m1 <= 0 : m1 >= 0; i = ref3 <= 0 ? ++m1 : --m1) {\n      push(miniStack[i]);\n      push(divideBy);\n      divide();\n    }\n\n    return k;\n  };\n\n  roots = function roots() {\n    var h, i, k, l1, lastCoeff, leadingCoeff, n, ref2;\n    h = 0;\n    i = 0;\n    n = 0;\n    save();\n\n    if (recursionLevelNestedRadicalsRemoval > 1) {\n      pop();\n      pop();\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n\n    performing_roots = true;\n    h = tos - 2;\n\n    if (DEBUG) {\n      console.log(\"checking if \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n    }\n\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    push(p1);\n    push(p2);\n    k = normalisedCoeff();\n\n    if (isSimpleRoot(k)) {\n      if (DEBUG) {\n        console.log(\"yes, \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n      }\n\n      lastCoeff = stack[tos - k];\n      leadingCoeff = stack[tos - 1];\n      moveTos(tos - k);\n      pop();\n      pop();\n      getSimpleRoots(k, leadingCoeff, lastCoeff);\n    } else {\n      moveTos(tos - k);\n      roots2();\n    }\n\n    n = tos - h;\n\n    if (n === 0) {\n      stop(\"roots: the polynomial is not factorable, try nroots\");\n    }\n\n    if (n === 1) {\n      performing_roots = false;\n      restore();\n      return;\n    }\n\n    sort_stack(n);\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n\n    moveTos(h);\n    push(p1);\n    restore();\n    return performing_roots = false;\n  };\n\n  getSimpleRoots = function getSimpleRoots(n, leadingCoeff, lastCoeff) {\n    var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;\n\n    if (DEBUG) {\n      console.log(\"getSimpleRoots\");\n    }\n\n    save();\n    n = n - 1;\n    push(lastCoeff);\n    push_rational(1, n);\n    power();\n    push(leadingCoeff);\n    push_rational(1, n);\n    power();\n    divide();\n    commonPart = pop();\n\n    if (n % 2 === 0) {\n      for (rootsOfOne = l1 = 1, ref2 = n; l1 <= ref2; rootsOfOne = l1 += 2) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        aSol = pop();\n        push(aSol);\n        push(aSol);\n        negate();\n      }\n    } else {\n      for (rootsOfOne = m1 = 1, ref3 = n; 1 <= ref3 ? m1 <= ref3 : m1 >= ref3; rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n\n        if (rootsOfOne % 2 === 0) {\n          negate();\n        }\n      }\n    }\n\n    return restore();\n  };\n\n  roots2 = function roots2() {\n    var k;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    push(p1);\n    push(p2);\n    k = normalisedCoeff();\n\n    if (!hasImaginaryCoeff(k)) {\n      moveTos(tos - k);\n      factorpoly();\n      p1 = pop();\n    } else {\n      moveTos(tos - k);\n      pop();\n      pop();\n    }\n\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        roots3();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      roots3();\n    }\n\n    return restore();\n  };\n\n  roots3 = function roots3() {\n    var n;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {\n      push(cadr(p1));\n      push(p2);\n      n = normalisedCoeff();\n      mini_solve(n);\n    } else if (ispolyexpandedform(p1, p2)) {\n      push(p1);\n      push(p2);\n      n = normalisedCoeff();\n      mini_solve(n);\n    }\n\n    return restore();\n  };\n\n  mini_solve = function mini_solve(n) {\n    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;\n    save();\n\n    if (n === 2) {\n      p3 = pop();\n      p4 = pop();\n      push(p4);\n      push(p3);\n      divide();\n      negate();\n      restore();\n      return;\n    }\n\n    if (n === 3) {\n      p3 = pop();\n      p4 = pop();\n      p5 = pop();\n      push(p4);\n      push_integer(2);\n      power();\n      push_integer(4);\n      push(p3);\n      multiply();\n      push(p5);\n      multiply();\n      subtract();\n      push_rational(1, 2);\n      power();\n      p6 = pop();\n      push(p6);\n      push(p4);\n      subtract();\n      push(p3);\n      push_integer(2);\n      multiply();\n      divide();\n      push(p6);\n      push(p4);\n      add();\n      negate();\n      push(p3);\n      divide();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n\n    if (n === 4 || n === 5) {\n      p3 = pop();\n      p4 = pop();\n      p5 = pop();\n      p6 = pop();\n      push(p5);\n      push(p5);\n      multiply();\n      R_c2 = pop();\n      push(R_c2);\n      push(p5);\n      multiply();\n      R_c3 = pop();\n      push(p4);\n      push(p4);\n      multiply();\n      R_b2 = pop();\n      push(R_b2);\n      push(p4);\n      multiply();\n      R_b3 = pop();\n      push(R_b3);\n      push(p6);\n      multiply();\n      R_b3_d = pop();\n      push(R_b3_d);\n      push_integer(-4);\n      multiply();\n      R_m4_b3_d = pop();\n      push(R_b3);\n      push_integer(2);\n      multiply();\n      R_2_b3 = pop();\n      push(p3);\n      push(p3);\n      multiply();\n      R_a2 = pop();\n      push(R_a2);\n      push(p3);\n      multiply();\n      R_a3 = pop();\n      push_integer(3);\n      push(p3);\n      multiply();\n      R_3_a = pop();\n      push(R_a2);\n      push(p6);\n      multiply();\n      R_a2_d = pop();\n      push(R_a2_d);\n      push(p6);\n      multiply();\n      R_a2_d2 = pop();\n      push(R_a2_d);\n      push_integer(27);\n      multiply();\n      R_27_a2_d = pop();\n      push(R_a2_d2);\n      push_integer(-27);\n      multiply();\n      R_m27_a2_d2 = pop();\n      push(R_3_a);\n      push_integer(2);\n      multiply();\n      R_6_a = pop();\n      push(p3);\n      push(p5);\n      multiply();\n      R_a_c = pop();\n      push(R_a_c);\n      push(p4);\n      multiply();\n      R_a_b_c = pop();\n      push(R_a_b_c);\n      push(p6);\n      multiply();\n      R_a_b_c_d = pop();\n      push(R_a_c);\n      push_integer(3);\n      multiply();\n      R_3_a_c = pop();\n      push_integer(-4);\n      push(p3);\n      push(R_c3);\n      multiply();\n      multiply();\n      R_m4_a_c3 = pop();\n      push(R_a_b_c);\n      push_integer(9);\n      multiply();\n      negate();\n      R_m9_a_b_c = pop();\n      push(R_a_b_c_d);\n      push_integer(18);\n      multiply();\n      R_18_a_b_c_d = pop();\n      push(R_b2);\n      push(R_3_a_c);\n      subtract();\n      R_DELTA0 = pop();\n      push(R_b2);\n      push(R_c2);\n      multiply();\n      R_b2_c2 = pop();\n      push(p4);\n      negate();\n      push(R_3_a);\n      divide();\n      R_m_b_over_3a = pop();\n\n      if (n === 4) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< \");\n        }\n\n        if (DEBUG) {\n          console.log(\"cubic: D0: \" + R_DELTA0.toString());\n        }\n\n        push(R_DELTA0);\n        push_integer(3);\n        power();\n        push_integer(4);\n        multiply();\n        R_4_DELTA03 = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_toBeCheckedIfZero = pop();\n\n        if (DEBUG) {\n          console.log(\"cubic: D0 as float: \" + R_DELTA0_toBeCheckedIfZero.toString());\n        }\n\n        push(R_18_a_b_c_d);\n        push(R_m4_b3_d);\n        push(R_b2_c2);\n        push(R_m4_a_c3);\n        push(R_m27_a2_d2);\n        add();\n        add();\n        add();\n        add();\n        simplify();\n        absValFloat();\n        R_determinant = pop();\n\n        if (DEBUG) {\n          console.log(\"cubic: DETERMINANT: \" + R_determinant.toString());\n        }\n\n        push(R_2_b3);\n        push(R_m9_a_b_c);\n        push(R_27_a2_d);\n        add();\n        add();\n        R_DELTA1 = pop();\n\n        if (DEBUG) {\n          console.log(\"cubic: D1: \" + R_DELTA1.toString());\n        }\n\n        push(R_DELTA1);\n        push_integer(2);\n        power();\n        push(R_4_DELTA03);\n        subtract();\n        push_rational(1, 2);\n        power();\n        simplify();\n        R_Q = pop();\n\n        if (isZeroAtomOrTensor(R_determinant)) {\n          if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is zero\");\n            }\n\n            push(R_m_b_over_3a);\n            restore();\n            return;\n          } else {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is not zero\");\n            }\n\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            push(p4);\n            push(p5);\n            multiply();\n            subtract();\n            push(R_DELTA0);\n            push_integer(2);\n            multiply();\n            divide();\n            root_solution = pop();\n            push(root_solution);\n            push(root_solution);\n            push(R_a_b_c);\n            push_integer(4);\n            multiply();\n            push(p3);\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            multiply();\n            negate();\n            push(R_b3);\n            negate();\n            add();\n            add();\n            push(p3);\n            push(R_DELTA0);\n            multiply();\n            divide();\n            restore();\n            return;\n          }\n        }\n\n        C_CHECKED_AS_NOT_ZERO = false;\n        flipSignOFQSoCIsNotZero = false;\n\n        while (!C_CHECKED_AS_NOT_ZERO) {\n          push(R_Q);\n\n          if (flipSignOFQSoCIsNotZero) {\n            negate();\n          }\n\n          push(R_DELTA1);\n          add();\n          push_rational(1, 2);\n          multiply();\n          push_rational(1, 3);\n          power();\n          simplify();\n          R_C = pop();\n\n          if (DEBUG) {\n            console.log(\"cubic: C: \" + R_C.toString());\n          }\n\n          push(R_C);\n          simplify();\n          absValFloat();\n          R_C_simplified_toCheckIfZero = pop();\n\n          if (DEBUG) {\n            console.log(\"cubic: C as absval and float: \" + R_C_simplified_toCheckIfZero.toString());\n          }\n\n          if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: C IS ZERO flipping the sign\");\n            }\n\n            flipSignOFQSoCIsNotZero = true;\n          } else {\n            C_CHECKED_AS_NOT_ZERO = true;\n          }\n        }\n\n        push(R_C);\n        push(R_3_a);\n        multiply();\n        R_3_a_C = pop();\n        push(R_3_a_C);\n        push_integer(2);\n        multiply();\n        R_6_a_C = pop();\n        push(imaginaryunit);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        multiply();\n        i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        add();\n        one_plus_i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        subtract();\n        one_minus_i_sqrt3 = pop();\n        push(R_C);\n        push(R_3_a);\n        divide();\n        R_C_over_3a = pop();\n        push(R_m_b_over_3a);\n        push(R_C_over_3a);\n        negate();\n        push(R_DELTA0);\n        push(R_3_a_C);\n        divide();\n        negate();\n        add();\n        add();\n        simplify();\n        push(R_m_b_over_3a);\n        push(R_C_over_3a);\n        push(one_plus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide();\n        push(one_minus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide();\n        add();\n        add();\n        simplify();\n        push(R_m_b_over_3a);\n        push(R_C_over_3a);\n        push(one_minus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide();\n        push(one_plus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide();\n        add();\n        add();\n        simplify();\n        restore();\n        return;\n      }\n\n      if (n === 5) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< \");\n        }\n\n        p7 = pop();\n\n        if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {\n          if (DEBUG) {\n            console.log(\"biquadratic case\");\n          }\n\n          push(p3);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(p5);\n          push(symbol(SECRETX));\n          multiply();\n          push(p7);\n          add();\n          add();\n          push(symbol(SECRETX));\n          roots();\n          biquadraticSolutions = pop();\n          ref2 = biquadraticSolutions.tensor.elem;\n\n          for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n            eachSolution = ref2[l1];\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            simplify();\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            negate();\n            simplify();\n          }\n\n          restore();\n          return;\n        }\n\n        push(p6);\n        push(p6);\n        multiply();\n        R_d2 = pop();\n        push(p7);\n        push(p7);\n        multiply();\n        R_e2 = pop();\n        push(R_e2);\n        push(p7);\n        multiply();\n        R_e3 = pop();\n        push_integer(256);\n        push(R_a3);\n        push(R_e3);\n        multiply();\n        multiply();\n        push_integer(-192);\n        push(R_a2_d);\n        push(R_e2);\n        push(p4);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-128);\n        push(R_a2);\n        push(R_c2);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(144);\n        push(R_a2_d2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push(R_m27_a2_d2);\n        push(R_d2);\n        multiply();\n        push_integer(144);\n        push(R_a_b_c);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-6);\n        push(p3);\n        push(R_b2);\n        push(R_d2);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-80);\n        push(R_a_b_c_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(18);\n        push(R_a_b_c_d);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(16);\n        push(R_a_c);\n        push(R_c3);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-4);\n        push(R_a_c);\n        push(R_c2);\n        push(R_d2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(-27);\n        push(R_b3);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(18);\n        push(R_b3_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push(R_m4_b3_d);\n        push(R_d2);\n        multiply();\n        push_integer(-4);\n        push(R_b2_c2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        push(R_b2_c2);\n        push(R_d2);\n        multiply();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        R_determinant = pop();\n\n        if (DEBUG) {\n          console.log(\"R_determinant: \" + R_determinant.toString());\n        }\n\n        push(R_c2);\n        push_integer(-3);\n        push(p4);\n        push(p6);\n        multiply();\n        multiply();\n        push_integer(12);\n        push(p3);\n        push(p7);\n        multiply();\n        multiply();\n        add();\n        add();\n        R_DELTA0 = pop();\n\n        if (DEBUG) {\n          console.log(\"R_DELTA0: \" + R_DELTA0.toString());\n        }\n\n        push_integer(2);\n        push(R_c3);\n        multiply();\n        push_integer(-9);\n        push(p4);\n        push(p5);\n        push(p6);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(27);\n        push(R_b2);\n        push(p7);\n        multiply();\n        multiply();\n        push_integer(27);\n        push(p3);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(-72);\n        push(R_a_c);\n        push(p7);\n        multiply();\n        multiply();\n        add();\n        add();\n        add();\n        add();\n        R_DELTA1 = pop();\n\n        if (DEBUG) {\n          console.log(\"R_DELTA1: \" + R_DELTA1.toString());\n        }\n\n        push_integer(8);\n        push(R_a_c);\n        multiply();\n        push_integer(-3);\n        push(R_b2);\n        multiply();\n        add();\n        push_integer(8);\n        push(R_a2);\n        multiply();\n        divide();\n        R_p = pop();\n\n        if (DEBUG) {\n          console.log(\"p: \" + R_p.toString());\n        }\n\n        push(R_b3);\n        push_integer(-4);\n        push(R_a_b_c);\n        multiply();\n        push_integer(8);\n        push(R_a2_d);\n        multiply();\n        add();\n        add();\n        push_integer(8);\n        push(R_a3);\n        multiply();\n        divide();\n        R_q = pop();\n\n        if (DEBUG) {\n          console.log(\"q: \" + R_q.toString());\n        }\n\n        if (DEBUG) {\n          console.log(\"tos 1 \" + tos);\n        }\n\n        if (!isZeroAtomOrTensor(p4)) {\n          if (DEBUG) {\n            console.log(\"tos 2 \" + tos);\n          }\n\n          push_integer(8);\n          push(p5);\n          push(p3);\n          multiply();\n          multiply();\n          push_integer(-3);\n          push(p4);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          divide();\n          R_p = pop();\n\n          if (DEBUG) {\n            console.log(\"p for depressed quartic: \" + R_p.toString());\n          }\n\n          push(p4);\n          push_integer(3);\n          power();\n          push_integer(-4);\n          push(p3);\n          push(p4);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          push_integer(8);\n          push(p6);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          multiply();\n          add();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(3);\n          power();\n          multiply();\n          divide();\n          R_q = pop();\n\n          if (DEBUG) {\n            console.log(\"q for depressed quartic: \" + R_q.toString());\n          }\n\n          push(p4);\n          push_integer(4);\n          power();\n          push_integer(-3);\n          multiply();\n          push_integer(256);\n          push(R_a3);\n          push(p7);\n          multiply();\n          multiply();\n          push_integer(-64);\n          push(R_a2_d);\n          push(p4);\n          multiply();\n          multiply();\n          push_integer(16);\n          push(R_b2);\n          push(p3);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          add();\n          add();\n          add();\n          push_integer(256);\n          push(p3);\n          push_integer(4);\n          power();\n          multiply();\n          divide();\n          R_r = pop();\n\n          if (DEBUG) {\n            console.log(\"r for depressed quartic: \" + R_r.toString());\n          }\n\n          if (DEBUG) {\n            console.log(\"tos 4 \" + tos);\n          }\n\n          push(symbol(SECRETX));\n          push_integer(4);\n          power();\n\n          if (DEBUG) {\n            console.log(\"4 * x^4: \" + stack[tos - 1].toString());\n          }\n\n          push(R_p);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n\n          if (DEBUG) {\n            console.log(\"R_p * x^2: \" + stack[tos - 1].toString());\n          }\n\n          push(R_q);\n          push(symbol(SECRETX));\n          multiply();\n\n          if (DEBUG) {\n            console.log(\"R_q * x: \" + stack[tos - 1].toString());\n          }\n\n          push(R_r);\n\n          if (DEBUG) {\n            console.log(\"R_r: \" + stack[tos - 1].toString());\n          }\n\n          add();\n          add();\n          add();\n          simplify();\n\n          if (DEBUG) {\n            console.log(\"solving depressed quartic: \" + stack[tos - 1].toString());\n          }\n\n          push(symbol(SECRETX));\n          roots();\n          depressedSolutions = pop();\n\n          if (DEBUG) {\n            console.log(\"depressedSolutions: \" + depressedSolutions);\n          }\n\n          ref3 = depressedSolutions.tensor.elem;\n\n          for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {\n            eachSolution = ref3[m1];\n            push(eachSolution);\n            push(p4);\n            push_integer(4);\n            push(p3);\n            multiply();\n            divide();\n            subtract();\n            simplify();\n\n            if (DEBUG) {\n              console.log(\"solution from depressed: \" + stack[tos - 1].toString());\n            }\n          }\n\n          restore();\n          return;\n        } else {\n          R_p = p5;\n          R_q = p6;\n          R_r = p7;\n          /*\n           * Descartes' solution\n           * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution\n           * finding the \"u\" in the depressed equation\n          \n          push_integer(2)\n          push(R_p)\n          multiply()\n          coeff2 = pop()\n          \n          push_integer(-4)\n          push(R_p)\n          push_integer(2)\n          power()\n          multiply()\n          push(R_r)\n          multiply()\n          coeff3 = pop()\n          \n          push(R_q)\n          push_integer(2)\n          power()\n          negate()\n          coeff4 = pop()\n          \n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(3)\n          power()\n          \n          push(coeff2)\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          multiply()\n          \n          push(coeff3)\n          push(symbol(SECRETX))\n          multiply()\n          \n          push(coeff4)\n          \n          add()\n          add()\n          add()\n          \n          console.log(\"Descarte's resolventCubic: \" +  stack[tos-1].toString())\n          push(symbol(SECRETX))\n          \n          roots()\n          \n          resolventCubicSolutions = pop()\n          console.log(\"Descarte's resolventCubic solutions: \" +  resolventCubicSolutions)\n          console.log(\"tos: \" +  tos)\n          \n          R_u = null\n          #R_u = resolventCubicSolutions.tensor.elem[1]\n          for eachSolution in resolventCubicSolutions.tensor.elem\n            console.log(\"examining solution: \" +  eachSolution)\n            push(eachSolution)\n            push_integer(2)\n            multiply()\n            push(R_p)\n            add()\n          \n            absValFloat()\n            toBeCheckedIFZero = pop()\n            console.log(\"abs value is: \" +  eachSolution)\n            if !isZeroAtomOrTensor(toBeCheckedIFZero)\n              R_u = eachSolution\n              break\n          \n          console.log(\"chosen solution: \" +  R_u)\n          \n          push(R_u)\n          negate()\n          R_s = pop()\n          \n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          add()\n          add()\n          push_integer(2)\n          divide()\n          R_t = pop()\n          \n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          subtract()\n          add()\n          push_integer(2)\n          divide()\n          R_v = pop()\n          \n           * factoring the quartic into two quadratics:\n          \n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          \n          push(R_s)\n          push(symbol(SECRETX))\n          multiply()\n          \n          push(R_t)\n          \n          add()\n          add()\n          \n          console.log(\"factored quartic 1: \" + stack[tos-1].toString())\n          \n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          \n          push(R_u)\n          push(symbol(SECRETX))\n          multiply()\n          \n          push(R_v)\n          \n          add()\n          add()\n          \n          console.log(\"factored quartic 2: \" + stack[tos-1].toString())\n          pop()\n          \n          restore()\n          return\n           */\n\n          push_rational(5, 2);\n          push(R_p);\n          multiply();\n          coeff2 = pop();\n          push_integer(2);\n          push(R_p);\n          push_integer(2);\n          power();\n          multiply();\n          push(R_r);\n          subtract();\n          coeff3 = pop();\n          push(R_p);\n          push_integer(3);\n          power();\n          push_integer(2);\n          divide();\n          push_rational(-1, 2);\n          push(R_p);\n          push(R_r);\n          multiply();\n          multiply();\n          push_rational(-1, 8);\n          push(R_q);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n          coeff4 = pop();\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          push(coeff2);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(coeff3);\n          push(symbol(SECRETX));\n          multiply();\n          push(coeff4);\n          add();\n          add();\n          add();\n\n          if (DEBUG) {\n            console.log(\"resolventCubic: \" + stack[tos - 1].toString());\n          }\n\n          push(symbol(SECRETX));\n          roots();\n          resolventCubicSolutions = pop();\n\n          if (DEBUG) {\n            console.log(\"resolventCubicSolutions: \" + resolventCubicSolutions);\n          }\n\n          R_m = null;\n          ref4 = resolventCubicSolutions.tensor.elem;\n\n          for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {\n            eachSolution = ref4[n1];\n\n            if (DEBUG) {\n              console.log(\"examining solution: \" + eachSolution);\n            }\n\n            push(eachSolution);\n            push_integer(2);\n            multiply();\n            push(R_p);\n            add();\n            absValFloat();\n            toBeCheckedIFZero = pop();\n\n            if (DEBUG) {\n              console.log(\"abs value is: \" + eachSolution);\n            }\n\n            if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {\n              R_m = eachSolution;\n              break;\n            }\n          }\n\n          if (DEBUG) {\n            console.log(\"chosen solution: \" + R_m);\n          }\n\n          push(R_m);\n          push_integer(2);\n          multiply();\n          push(R_p);\n          add();\n          push_rational(1, 2);\n          power();\n          simplify();\n          sqrtPPlus2M = pop();\n          push(R_q);\n          push_integer(2);\n          multiply();\n          push(sqrtPPlus2M);\n          divide();\n          simplify();\n          TwoQOversqrtPPlus2M = pop();\n          push(R_p);\n          push_integer(3);\n          multiply();\n          push(R_m);\n          push_integer(2);\n          multiply();\n          add();\n          ThreePPlus2M = pop();\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          restore();\n          return;\n        }\n\n        push(R_determinant);\n        simplify();\n        absValFloat();\n        R_determinant_simplified_toCheckIfZero = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_simplified_toCheckIfZero = pop();\n        S_CHECKED_AS_NOT_ZERO = false;\n        choiceOfRadicalInQSoSIsNotZero = 0;\n\n        while (!S_CHECKED_AS_NOT_ZERO) {\n          Q_CHECKED_AS_NOT_ZERO = false;\n          flipSignOFRadicalSoQIsNotZero = false;\n\n          while (!Q_CHECKED_AS_NOT_ZERO) {\n            push(R_DELTA1);\n            push(R_DELTA1);\n            push_integer(2);\n            power();\n            push_integer(-4);\n            push(R_DELTA0);\n            push_integer(3);\n            power();\n            multiply();\n            add();\n            push_rational(1, 2);\n            power();\n\n            if (flipSignOFRadicalSoQIsNotZero) {\n              negate();\n            }\n\n            add();\n            push_integer(2);\n            divide();\n\n            if (DEBUG) {\n              console.log(\"content of cubic root: \" + stack[tos - 1].toString());\n            }\n\n            push_rational(1, 3);\n            power();\n            simplify();\n            R_principalCubicRoot = pop();\n\n            if (DEBUG) {\n              console.log(\"principal cubic root: \" + R_principalCubicRoot.toString());\n            }\n\n            if (DEBUG) {\n              console.log(\"tos : \" + tos);\n            }\n\n            if (choiceOfRadicalInQSoSIsNotZero === 0) {\n              if (DEBUG) {\n                console.log(\"chosing principal cubic root\");\n              }\n\n              push(R_principalCubicRoot);\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond principal\");\n              }\n\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(-1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond beyond principal\");\n              }\n\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            }\n\n            simplify();\n            R_Q = pop();\n\n            if (DEBUG) {\n              console.log(\"Q \" + R_Q.toString());\n            }\n\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n\n            push(R_Q);\n            simplify();\n            absValFloat();\n            R_Q_simplified_toCheckIfZero = pop();\n\n            if (DEBUG) {\n              console.log(\"Q simplified and abs\" + R_Q_simplified_toCheckIfZero.toString());\n            }\n\n            if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && !isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero)) {\n              if (DEBUG) {\n                console.log(\" *********************************** Q IS ZERO and it matters, flipping the sign\");\n              }\n\n              flipSignOFRadicalSoQIsNotZero = true;\n            } else {\n              Q_CHECKED_AS_NOT_ZERO = true;\n            }\n\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n          }\n\n          push_rational(-2, 3);\n          push(R_p);\n          multiply();\n          push(R_Q);\n          push(R_DELTA0);\n          push(R_Q);\n          divide();\n          add();\n          push(R_3_a);\n          divide();\n          add();\n          push_rational(1, 2);\n          power();\n          push_integer(2);\n          divide();\n          show_power_debug = true;\n          simplify();\n          R_S = pop();\n\n          if (DEBUG) {\n            console.log(\"S \" + R_S.toString());\n          }\n\n          push(R_S);\n          simplify();\n          absValFloat();\n          R_S_simplified_toCheckIfZero = pop();\n\n          if (DEBUG) {\n            console.log(\"S \" + R_S_simplified_toCheckIfZero.toString());\n          }\n\n          if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" *********************************** S IS ZERO chosing another cubic root\");\n            }\n\n            choiceOfRadicalInQSoSIsNotZero++;\n          } else {\n            S_CHECKED_AS_NOT_ZERO = true;\n          }\n\n          if (DEBUG) {\n            console.log(\"tos: \" + tos);\n          }\n        }\n\n        if (DEBUG) {\n          console.log(\"tos: \" + tos);\n        }\n\n        push(p4);\n        negate();\n        push(p3);\n        push_integer(4);\n        multiply();\n        divide();\n        R_minus_b_over_4a = pop();\n        push_integer(-4);\n        push(R_S);\n        push_integer(2);\n        power();\n        multiply();\n        push_integer(2);\n        push(R_p);\n        multiply();\n        subtract();\n        R_minus_4S2_minus_2p = pop();\n        push(R_q);\n        push(R_S);\n        divide();\n        R_q_over_S = pop();\n\n        if (DEBUG) {\n          console.log(\"tos before putting together the 4 solutions: \" + tos);\n        }\n\n        push(R_minus_b_over_4a);\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        push(R_minus_b_over_4a);\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        push(R_minus_b_over_4a);\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        push(R_minus_b_over_4a);\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        restore();\n        return;\n      }\n    }\n\n    moveTos(tos - n);\n    return restore();\n  };\n\n  Eval_round = function Eval_round() {\n    push(cadr(p1));\n    Eval();\n    return yround();\n  };\n\n  yround = function yround() {\n    save();\n    yyround();\n    return restore();\n  };\n\n  yyround = function yyround() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (!isNumericAtom(p1)) {\n      push_symbol(ROUND);\n      push(p1);\n      list(2);\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.round(p1.d);\n      push_double(d);\n      return;\n    }\n\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n\n    push(p1);\n\n    _yyfloat();\n\n    p1 = pop();\n    return push_integer(Math.round(p1.d));\n  };\n\n  T_INTEGER = 1001;\n  T_DOUBLE = 1002;\n  T_SYMBOL = 1003;\n  T_FUNCTION = 1004;\n  T_NEWLINE = 1006;\n  T_STRING = 1007;\n  T_GTEQ = 1008;\n  T_LTEQ = 1009;\n  T_EQ = 1010;\n  T_NEQ = 1011;\n  T_QUOTASSIGN = 1012;\n  token = \"\";\n  newline_flag = 0;\n  meta_mode = 0;\n  input_str = 0;\n  scan_str = 0;\n  token_str = 0;\n  token_buf = 0;\n  lastFoundSymbol = null;\n  symbolsRightOfAssignment = null;\n  symbolsLeftOfAssignment = null;\n  isSymbolLeftOfAssignment = null;\n  scanningParameters = null;\n  functionInvokationsScanningStack = null;\n  skipRootVariableToBeSolved = false;\n  assignmentFound = null;\n  scanned = \"\";\n\n  scan = function scan(s) {\n    if (DEBUG) {\n      console.log(\"#### scanning \" + s);\n    }\n\n    lastFoundSymbol = null;\n    symbolsRightOfAssignment = [];\n    symbolsLeftOfAssignment = [];\n    isSymbolLeftOfAssignment = true;\n    scanningParameters = [];\n    functionInvokationsScanningStack = [\"\"];\n    assignmentFound = false;\n    scanned = s;\n    meta_mode = 0;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n\n    scan_stmt();\n    expanding--;\n\n    if (!assignmentFound) {\n      symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);\n    }\n\n    return token_str - input_str;\n  };\n\n  scan_meta = function scan_meta(s) {\n    scanned = s;\n    meta_mode = 1;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n\n    scan_stmt();\n    expanding--;\n    return token_str - input_str;\n  };\n\n  scan_stmt = function scan_stmt() {\n    var assignmentIsOfQuotedType, existingDependencies, i, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;\n    scan_relation();\n    assignmentIsOfQuotedType = false;\n\n    if (token === T_QUOTASSIGN) {\n      assignmentIsOfQuotedType = true;\n    }\n\n    if (token === T_QUOTASSIGN || token === '=') {\n      symbolLeftOfAssignment = lastFoundSymbol;\n\n      if (DEBUG) {\n        console.log(\"assignment!\");\n      }\n\n      assignmentFound = true;\n      isSymbolLeftOfAssignment = false;\n      get_next_token();\n      push_symbol(SETQ);\n      swap();\n\n      if (assignmentIsOfQuotedType) {\n        push_symbol(QUOTE);\n      }\n\n      scan_relation();\n\n      if (assignmentIsOfQuotedType) {\n        list(2);\n      }\n\n      list(3);\n      isSymbolLeftOfAssignment = true;\n\n      if (codeGen) {\n        indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);\n\n        if (indexOfSymbolLeftOfAssignment !== -1) {\n          symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);\n          symbolsHavingReassignments.push(symbolLeftOfAssignment);\n        }\n\n        if (DEBUG) {\n          console.log(\"locally, \" + symbolLeftOfAssignment + \" depends on: \");\n\n          for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {\n            i = symbolsRightOfAssignment[l1];\n            console.log(\"  \" + i);\n          }\n        }\n\n        if (symbolsDependencies[symbolLeftOfAssignment] == null) {\n          symbolsDependencies[symbolLeftOfAssignment] = [];\n        }\n\n        existingDependencies = symbolsDependencies[symbolLeftOfAssignment];\n\n        for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {\n          i = symbolsRightOfAssignment[m1];\n\n          if (existingDependencies.indexOf(i) === -1) {\n            existingDependencies.push(i);\n          }\n        }\n\n        return symbolsRightOfAssignment = [];\n      }\n    }\n  };\n\n  scan_relation = function scan_relation() {\n    scan_expression();\n\n    switch (token) {\n      case T_EQ:\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case T_NEQ:\n        push_symbol(NOT);\n        swap();\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        list(3);\n        return list(2);\n\n      case T_LTEQ:\n        push_symbol(TESTLE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case T_GTEQ:\n        push_symbol(TESTGE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case '<':\n        push_symbol(TESTLT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n\n      case '>':\n        push_symbol(TESTGT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n    }\n  };\n\n  scan_expression = function scan_expression() {\n    var h;\n    h = tos;\n\n    switch (token) {\n      case '+':\n        get_next_token();\n        scan_term();\n        break;\n\n      case '-':\n        get_next_token();\n        scan_term();\n        negate();\n        break;\n\n      default:\n        scan_term();\n    }\n\n    while (newline_flag === 0 && (token === '+' || token === '-')) {\n      if (token === '+') {\n        get_next_token();\n        scan_term();\n      } else {\n        get_next_token();\n        scan_term();\n        negate();\n      }\n    }\n\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(ADD);\n      swap();\n      return cons();\n    }\n  };\n\n  is_factor = function is_factor() {\n    if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n      return 1;\n    }\n\n    switch (token) {\n      case '*':\n      case '/':\n        return 1;\n\n      case '(':\n      case T_SYMBOL:\n      case T_FUNCTION:\n      case T_INTEGER:\n      case T_DOUBLE:\n      case T_STRING:\n        if (newline_flag) {\n          scan_str = token_str;\n          return 0;\n        } else {\n          return 1;\n        }\n\n    }\n\n    return 0;\n  };\n\n  simplify_1_in_products = function simplify_1_in_products(tos, h) {\n    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {\n      return pop();\n    }\n  };\n\n  multiply_consecutive_constants = function multiply_consecutive_constants(tos, h) {\n    if (tos > h + 1 && isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply();\n    }\n  };\n\n  scan_term = function scan_term() {\n    var h;\n    h = tos;\n    scan_factor();\n\n    if (parse_time_simplifications) {\n      simplify_1_in_products(tos, h);\n    }\n\n    while (is_factor()) {\n      if (token === '*') {\n        get_next_token();\n        scan_factor();\n      } else if (token === '/') {\n        simplify_1_in_products(tos, h);\n        get_next_token();\n        scan_factor();\n        inverse();\n      } else if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n        get_next_token();\n        push_symbol(INNER);\n        swap();\n        scan_factor();\n        list(3);\n      } else {\n        scan_factor();\n      }\n\n      if (parse_time_simplifications) {\n        multiply_consecutive_constants(tos, h);\n        simplify_1_in_products(tos, h);\n      }\n    }\n\n    if (h === tos) {\n      return push_integer(1);\n    } else if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      return cons();\n    }\n  };\n\n  scan_power = function scan_power() {\n    if (token === '^') {\n      get_next_token();\n      push_symbol(POWER);\n      swap();\n      scan_factor();\n      return list(3);\n    }\n  };\n\n  scan_index = function scan_index(h) {\n    get_next_token();\n    push_symbol(INDEX);\n    swap();\n    scan_expression();\n\n    while (token === ',') {\n      get_next_token();\n      scan_expression();\n    }\n\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n\n    get_next_token();\n    return list(tos - h);\n  };\n\n  scan_factor = function scan_factor() {\n    var firstFactorIsNumber, h;\n    h = tos;\n    firstFactorIsNumber = false;\n\n    if (token === '(') {\n      scan_subexpr();\n    } else if (token === T_SYMBOL) {\n      scan_symbol();\n    } else if (token === T_FUNCTION) {\n      scan_function_call_with_function_name();\n    } else if (token === '[') {\n      scan_tensor();\n    } else if (token === T_INTEGER) {\n      firstFactorIsNumber = true;\n      bignum_scan_integer(token_buf);\n      get_next_token();\n    } else if (token === T_DOUBLE) {\n      firstFactorIsNumber = true;\n      bignum_scan_float(token_buf);\n      get_next_token();\n    } else if (token === T_STRING) {\n      scan_string();\n    } else {\n      scan_error(\"syntax error\");\n    }\n\n    while (token === '[' || token === '(' && newline_flag === 0 && !firstFactorIsNumber) {\n      if (token === '[') {\n        scan_index(h);\n      } else if (token === '(') {\n        scan_function_call_without_function_name();\n      }\n    }\n\n    while (token === '!') {\n      get_next_token();\n      push_symbol(FACTORIAL);\n      swap();\n      list(2);\n    }\n\n    while ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === transpose_unicode) {\n      get_next_token();\n      push_symbol(TRANSPOSE);\n      swap();\n      list(2);\n    }\n\n    return scan_power();\n  };\n\n  addSymbolRightOfAssignment = function addSymbolRightOfAssignment(theSymbol) {\n    var i, l1, prefixVar, ref2;\n\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols right of assignment\");\n      }\n\n      prefixVar = \"\";\n\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n\n      theSymbol = prefixVar + theSymbol;\n      return symbolsRightOfAssignment.push(theSymbol);\n    }\n  };\n\n  addSymbolLeftOfAssignment = function addSymbolLeftOfAssignment(theSymbol) {\n    var i, l1, prefixVar, ref2;\n\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols left of assignment\");\n      }\n\n      prefixVar = \"\";\n\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n\n      theSymbol = prefixVar + theSymbol;\n      return symbolsLeftOfAssignment.push(theSymbol);\n    }\n  };\n\n  scan_symbol = function scan_symbol() {\n    if (token !== T_SYMBOL) {\n      scan_error(\"symbol expected\");\n    }\n\n    if (meta_mode && token_buf.length === 1) {\n      switch (token_buf[0]) {\n        case 'a':\n          push(symbol(METAA));\n          break;\n\n        case 'b':\n          push(symbol(METAB));\n          break;\n\n        case 'x':\n          push(symbol(METAX));\n          break;\n\n        default:\n          push(usr_symbol(token_buf));\n      }\n    } else {\n      push(usr_symbol(token_buf));\n    }\n\n    if (scanningParameters.length === 0) {\n      if (DEBUG) {\n        console.log(\"out of scanning parameters, processing \" + token_buf);\n      }\n\n      lastFoundSymbol = token_buf;\n\n      if (isSymbolLeftOfAssignment) {\n        addSymbolLeftOfAssignment(token_buf);\n      }\n    } else {\n      if (DEBUG) {\n        console.log(\"still scanning parameters, skipping \" + token_buf);\n      }\n\n      if (isSymbolLeftOfAssignment) {\n        addSymbolRightOfAssignment(\"'\" + token_buf);\n      }\n    }\n\n    if (DEBUG) {\n      console.log(\"found symbol: \" + token_buf + \" left of assignment: \" + isSymbolLeftOfAssignment);\n    }\n\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n\n    return get_next_token();\n  };\n\n  scan_string = function scan_string() {\n    new_string(token_buf);\n    return get_next_token();\n  };\n\n  scan_function_call_with_function_name = function scan_function_call_with_function_name() {\n    var functionName, i, l1, n, p, ref2;\n\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_with_function_name start\");\n    }\n\n    n = 1;\n    p = new U();\n    p = usr_symbol(token_buf);\n    push(p);\n    functionName = token_buf;\n\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.push(token_buf);\n    }\n\n    lastFoundSymbol = token_buf;\n\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n\n    get_next_token();\n    get_next_token();\n    scanningParameters.push(true);\n\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n\n      while (token === ',') {\n        get_next_token();\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"sum\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"product\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"for\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"defint\") !== -1 && (n === 2 || n > 2 && (n - 2) % 3 === 0)) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n            return !new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n\n        scan_stmt();\n        skipRootVariableToBeSolved = false;\n        n++;\n      }\n\n      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function (x) {\n          return !new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + \"x\").test(x);\n        });\n      }\n    }\n\n    scanningParameters.pop();\n\n    for (i = l1 = 0, ref2 = symbolsRightOfAssignment.length; 0 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (symbolsRightOfAssignment[i] != null) {\n        if (functionName === \"roots\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"defint\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"sum\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"product\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n\n        if (functionName === \"for\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n      }\n    }\n\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n\n    get_next_token();\n    list(n);\n\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.pop();\n    }\n\n    if (functionName === symbol(PATTERN).printname) {\n      patternHasBeenFound = true;\n    }\n\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_with_function_name end\");\n    }\n  };\n\n  scan_function_call_without_function_name = function scan_function_call_without_function_name() {\n    var n;\n\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_without_function_name start\");\n    }\n\n    push_symbol(EVAL);\n    swap();\n    list(2);\n    n = 1;\n    get_next_token();\n    scanningParameters.push(true);\n\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n\n      while (token === ',') {\n        get_next_token();\n        scan_stmt();\n        n++;\n      }\n    }\n\n    scanningParameters.pop();\n\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n\n    get_next_token();\n    list(n);\n\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_without_function_name end: \" + stack[tos - 1]);\n    }\n  };\n\n  scan_subexpr = function scan_subexpr() {\n    var n;\n    n = 0;\n\n    if (token !== '(') {\n      scan_error(\"( expected\");\n    }\n\n    get_next_token();\n    scan_stmt();\n\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n\n    return get_next_token();\n  };\n\n  scan_tensor = function scan_tensor() {\n    var n;\n    n = 0;\n\n    if (token !== '[') {\n      scan_error(\"[ expected\");\n    }\n\n    get_next_token();\n    scan_stmt();\n    n = 1;\n\n    while (token === ',') {\n      get_next_token();\n      scan_stmt();\n      n++;\n    }\n\n    build_tensor(n);\n\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n\n    return get_next_token();\n  };\n\n  scan_error = function scan_error(errmsg) {\n    errorMessage = \"\";\n\n    while (input_str !== scan_str) {\n      if ((scanned[input_str] === '\\n' || scanned[input_str] === '\\r') && input_str + 1 === scan_str) {\n        break;\n      }\n\n      errorMessage += scanned[input_str++];\n    }\n\n    errorMessage += \" ? \";\n\n    while (scanned[input_str] && scanned[input_str] !== '\\n' && scanned[input_str] !== '\\r') {\n      errorMessage += scanned[input_str++];\n    }\n\n    errorMessage += '\\n';\n    return stop(errmsg);\n  };\n\n  build_tensor = function build_tensor(n) {\n    var i, l1, ref2;\n    i = 0;\n    save();\n    p2 = alloc_tensor(n);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = n;\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.elem[i] = stack[tos - n + i];\n    }\n\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  get_next_token = function get_next_token() {\n    newline_flag = 0;\n\n    while (1) {\n      get_token();\n\n      if (token !== T_NEWLINE) {\n        break;\n      }\n\n      newline_flag = 1;\n    }\n\n    if (DEBUG) {\n      return console.log(\"get_next_token token: \" + token);\n    }\n  };\n\n  get_token = function get_token() {\n    while (isspace(scanned[scan_str])) {\n      if (scanned[scan_str] === '\\n' || scanned[scan_str] === '\\r') {\n        token = T_NEWLINE;\n        scan_str++;\n        return;\n      }\n\n      scan_str++;\n    }\n\n    token_str = scan_str;\n\n    if (scan_str === scanned.length) {\n      token = \"\";\n      return;\n    }\n\n    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {\n      while (isdigit(scanned[scan_str])) {\n        scan_str++;\n      }\n\n      if (scanned[scan_str] === '.') {\n        scan_str++;\n\n        while (isdigit(scanned[scan_str])) {\n          scan_str++;\n        }\n\n        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {\n          scan_str += 2;\n\n          while (isdigit(scanned[scan_str])) {\n            scan_str++;\n          }\n        }\n\n        token = T_DOUBLE;\n      } else {\n        token = T_INTEGER;\n      }\n\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n\n    if (isalpha(scanned[scan_str])) {\n      while (isalnumorunderscore(scanned[scan_str])) {\n        scan_str++;\n      }\n\n      if (scanned[scan_str] === '(') {\n        token = T_FUNCTION;\n      } else {\n        token = T_SYMBOL;\n      }\n\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n\n    if (scanned[scan_str] === '\"') {\n      scan_str++;\n\n      while (scanned[scan_str] !== '\"') {\n        if (scan_str === scanned.length - 1) {\n          scan_str++;\n          scan_error(\"runaway string\");\n          scan_str--;\n        }\n\n        scan_str++;\n      }\n\n      scan_str++;\n      token = T_STRING;\n      update_token_buf(token_str + 1, scan_str - 1);\n      return;\n    }\n\n    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {\n      while (scanned[scan_str] && scanned[scan_str] !== '\\n' && scanned[scan_str] !== '\\r') {\n        scan_str++;\n      }\n\n      if (scanned[scan_str]) {\n        scan_str++;\n      }\n\n      token = T_NEWLINE;\n      return;\n    }\n\n    if (scanned[scan_str] === ':' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_QUOTASSIGN;\n      return;\n    }\n\n    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_EQ;\n      return;\n    }\n\n    if (scanned[scan_str] === '!' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_NEQ;\n      return;\n    }\n\n    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_LTEQ;\n      return;\n    }\n\n    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_GTEQ;\n      return;\n    }\n\n    return token = scanned[scan_str++];\n  };\n\n  update_token_buf = function update_token_buf(a, b) {\n    return token_buf = scanned.substring(a, b);\n  };\n\n  $.scan = scan;\n\n  Eval_sgn = function Eval_sgn() {\n    push(cadr(p1));\n    Eval();\n    return sgn();\n  };\n\n  sgn = function sgn() {\n    save();\n    yysgn();\n    return restore();\n  };\n\n  yysgn = function yysgn() {\n    p1 = pop();\n\n    if (isdouble(p1)) {\n      if (p1.d > 0) {\n        push_integer(1);\n        return;\n      } else {\n        if (p1.d === 0) {\n          push_integer(1);\n          return;\n        } else {\n          push_integer(-1);\n          return;\n        }\n      }\n    }\n\n    if (isrational(p1)) {\n      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {\n        push_integer(-1);\n        return;\n      } else {\n        if (MZERO(mmul(p1.q.a, p1.q.b))) {\n          push_integer(0);\n          return;\n        } else {\n          push_integer(1);\n          return;\n        }\n      }\n    }\n\n    if (iscomplexnumber(p1)) {\n      push_integer(-1);\n      push(p1);\n\n      _absval();\n\n      power();\n      push(p1);\n      multiply();\n      return;\n    }\n\n    if (isnegativeterm(p1)) {\n      push_symbol(SGN);\n      push(p1);\n      negate();\n      list(2);\n      push_integer(-1);\n      multiply();\n      return;\n    }\n    /*\n    push_integer(2)\n    push(p1)\n    heaviside()\n    multiply()\n    push_integer(-1)\n    add()\n     */\n\n\n    push_symbol(SGN);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_shape = function Eval_shape() {\n    push(cadr(p1));\n    Eval();\n    return shape();\n  };\n\n  shape = function shape() {\n    var ai, an, i, l1, m1, ndim, ref2, ref3, t;\n    i = 0;\n    ndim = 0;\n    t = 0;\n    ai = [];\n    an = [];\n\n    for (i = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n\n    save();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"transpose: tensor expected, 1st arg is not a tensor\");\n      }\n\n      push(zero);\n      restore();\n      return;\n    }\n\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(ndim);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = ndim;\n\n    for (i = m1 = 0, ref3 = ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push_integer(p1.tensor.dim[i]);\n      p2.tensor.elem[i] = pop();\n    }\n\n    push(p2);\n    return restore();\n  };\n  /*\n   Simplify factorials\n  \n  The following script\n  \n    F(n,k) = k binomial(n,k)\n    (F(n,k) + F(n,k-1)) / F(n+1,k)\n  \n  generates\n  \n         k! n!             n! (1 - k + n)!              k! n!\n   -------------------- + -------------------- - ----------------------\n   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!\n  \n  Simplify each term to get\n  \n      k       1 - k + n       1\n   ------- + ----------- - -------\n    1 + n       1 + n       1 + n\n  \n  Then simplify the sum to get\n  \n      n\n   -------\n    1 + n\n   */\n\n\n  Eval_simfac = function Eval_simfac() {\n    push(cadr(p1));\n    Eval();\n    return simfac();\n  };\n\n  simfac = function simfac() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      h = tos;\n      p1 = cdr(p1);\n\n      while (p1 !== symbol(NIL)) {\n        push(car(p1));\n        simfac_term();\n        p1 = cdr(p1);\n      }\n\n      add_all(tos - h);\n    } else {\n      push(p1);\n      simfac_term();\n    }\n\n    return restore();\n  };\n  /*\n  void\n  simfac(void)\n  {\n    int h\n    save()\n    p1 = pop()\n    if (car(p1) == symbol(ADD)) {\n      h = tos\n      p1 = cdr(p1)\n      while (p1 != symbol(NIL)) {\n        push(car(p1))\n        simfac_term()\n        p1 = cdr(p1)\n      }\n      addk(tos - h)\n      p1 = pop()\n      if (find(p1, symbol(FACTORIAL))) {\n        push(p1)\n        if (car(p1) == symbol(ADD)) {\n          Condense()\n          simfac_term()\n        }\n      }\n    } else {\n      push(p1)\n      simfac_term()\n    }\n    restore()\n  }\n  \n  #endif\n   */\n\n\n  simfac_term = function simfac_term() {\n    var doNothing, h;\n    h = 0;\n    save();\n    p1 = pop();\n\n    if (car(p1) !== symbol(MULTIPLY)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    h = tos;\n    p1 = cdr(p1);\n\n    while (p1 !== symbol(NIL)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n\n    while (yysimfac(h)) {\n      doNothing = 1;\n    }\n\n    multiply_all_noexpand(tos - h);\n    return restore();\n  };\n\n  yysimfac = function yysimfac(h) {\n    var i, j, l1, m1, ref2, ref3, ref4, ref5;\n    i = 0;\n    j = 0;\n\n    for (i = l1 = ref2 = h, ref3 = tos; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      p1 = stack[i];\n\n      for (j = m1 = ref4 = h, ref5 = tos; ref4 <= ref5 ? m1 < ref5 : m1 > ref5; j = ref4 <= ref5 ? ++m1 : --m1) {\n        if (i === j) {\n          continue;\n        }\n\n        p2 = stack[j];\n\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {\n          push(cadr(p1));\n          push(one);\n          subtract();\n          factorial();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n\n        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {\n          push(p1);\n          push_integer(-1);\n          add();\n          factorial();\n          reciprocate();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n\n        if (car(p2) === symbol(FACTORIAL)) {\n          push(p1);\n          push(cadr(p2));\n          subtract();\n          p3 = pop();\n\n          if (isplusone(p3)) {\n            push(p1);\n            factorial();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n\n        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n\n          if (isplusone(p3)) {\n            push(cadr(p1));\n            factorial();\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n\n          if (isplusone(p3)) {\n            stack[i] = cadr(p1);\n            stack[j] = one;\n            return 1;\n          }\n\n          if (isminusone(p3)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n\n          if (equaln(p3, 2)) {\n            stack[i] = cadr(p1);\n            push(cadr(p1));\n            push_integer(-1);\n            add();\n            stack[j] = pop();\n            return 1;\n          }\n\n          if (equaln(p3, -2)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            push(cadr(cadr(p2)));\n            push_integer(-1);\n            add();\n            reciprocate();\n            stack[j] = pop();\n            return 1;\n          }\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  Eval_simplify = function Eval_simplify() {\n    push(cadr(p1));\n    runUserDefinedSimplifications();\n    Eval();\n    return simplify();\n  };\n\n  runUserDefinedSimplifications = function runUserDefinedSimplifications() {\n    var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;\n\n    if (userSimplificationsInListForm.length !== 0 && !_Find(cadr(p1), symbol(INTEGRAL))) {\n      originalexpanding = expanding;\n      expanding = false;\n\n      if (DEBUG) {\n        console.log(\"runUserDefinedSimplifications passed: \" + stack[tos - 1].toString());\n      }\n\n      Eval();\n\n      if (DEBUG) {\n        console.log(\"runUserDefinedSimplifications after eval no expanding: \" + stack[tos - 1].toString());\n      }\n\n      expanding = originalexpanding;\n      p1 = stack[tos - 1];\n\n      if (DEBUG) {\n        console.log(\"patterns to be checked: \");\n      }\n\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        eachSimplification = userSimplificationsInListForm[l1];\n\n        if (DEBUG) {\n          console.log(\"...\" + eachSimplification);\n        }\n      }\n\n      atLeastOneSuccessInRouldOfRulesApplications = true;\n      numberOfRulesApplications = 0;\n\n      while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        atLeastOneSuccessInRouldOfRulesApplications = false;\n        numberOfRulesApplications++;\n\n        for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n          eachSimplification = userSimplificationsInListForm[m1];\n          success = true;\n          eachConsecutiveRuleApplication = 0;\n\n          while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            eachConsecutiveRuleApplication++;\n\n            if (DEBUG) {\n              console.log(\"simplify - tos: \" + tos + \" checking pattern: \" + eachSimplification + \" on: \" + p1);\n            }\n\n            push_symbol(NIL);\n            success = _transform(eachSimplification, true);\n\n            if (success) {\n              atLeastOneSuccessInRouldOfRulesApplications = true;\n            }\n\n            p1 = stack[tos - 1];\n\n            if (DEBUG) {\n              console.log(\"p1 at this stage of simplification: \" + p1);\n            }\n          }\n\n          if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            stop(\"maximum application of single transformation rule exceeded: \" + eachSimplification);\n          }\n        }\n      }\n\n      if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        stop(\"maximum application of all transformation rules exceeded \");\n      }\n\n      if (DEBUG) {\n        console.log(\"METAX = \" + get_binding(symbol(METAX)));\n        console.log(\"METAA = \" + get_binding(symbol(METAA)));\n        return console.log(\"METAB = \" + get_binding(symbol(METAB)));\n      }\n    }\n  };\n\n  simplifyForCodeGeneration = function simplifyForCodeGeneration() {\n    save();\n    runUserDefinedSimplifications();\n    codeGen = true;\n    simplify_main();\n    codeGen = false;\n    return restore();\n  };\n\n  simplify = function simplify() {\n    save();\n    simplify_main();\n    return restore();\n  };\n\n  simplify_main = function simplify_main() {\n    var args, fbody;\n    p1 = pop();\n\n    if (codeGen && car(p1) === symbol(FUNCTION)) {\n      fbody = cadr(p1);\n      push(fbody);\n      eval();\n      simplify();\n      p3 = pop();\n      args = caddr(p1);\n      push_symbol(FUNCTION);\n      push(p3);\n      push(args);\n      list(3);\n      p1 = pop();\n    }\n\n    if (istensor(p1)) {\n      simplify_tensor();\n      return;\n    }\n\n    if (_Find(p1, symbol(FACTORIAL))) {\n      push(p1);\n      simfac();\n      p2 = pop();\n      push(p1);\n      rationalize();\n      simfac();\n      p3 = pop();\n\n      if (_count(p2) < _count(p3)) {\n        p1 = p2;\n      } else {\n        p1 = p3;\n      }\n    }\n\n    f10();\n    f1();\n    f2();\n    f3();\n    f4();\n    f5();\n    f9();\n    simplify_polarRect();\n\n    if (do_simplify_nested_radicals) {\n      if (simplify_nested_radicals()) {\n        if (DEBUG) {\n          console.log(\"de-nesting successful into: \" + p1.toString());\n        }\n\n        push(p1);\n        simplify();\n        return;\n      }\n    }\n\n    simplify_rectToClock();\n    simplify_rational_expressions();\n    return push(p1);\n  };\n\n  simplify_tensor = function simplify_tensor() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1.tensor.elem[i]);\n      simplify();\n      p2.tensor.elem[i] = pop();\n    }\n\n    check_tensor_dimensions(p2);\n\n    if (isZeroAtomOrTensor(p2)) {\n      p2 = zero;\n    }\n\n    return push(p2);\n  };\n\n  f1 = function f1() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n\n    push(p1);\n    rationalize();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f2 = function f2() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n\n    push(p1);\n    Condense();\n    p2 = pop();\n\n    if (_count(p2) <= _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f3 = function f3() {\n    push(p1);\n    rationalize();\n    negate();\n    rationalize();\n    negate();\n    rationalize();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f10 = function f10() {\n    var a, b, carp1, miao, originalexpanding;\n    carp1 = car(p1);\n    miao = cdr(p1);\n\n    if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {\n      if (car(car(cdr(p1))) === symbol(TRANSPOSE) && car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE)) {\n        if (DEBUG) {\n          console.log(\"maybe collecting a transpose \" + p1);\n        }\n\n        a = cadr(car(cdr(p1)));\n        b = cadr(car(cdr(cdr(p1))));\n\n        if (carp1 === symbol(MULTIPLY)) {\n          push(a);\n          push(b);\n          multiply();\n        } else if (isinnerordot(p1)) {\n          push(b);\n          push(a);\n\n          _inner();\n        }\n\n        push_integer(1);\n        push_integer(2);\n        originalexpanding = expanding;\n        expanding = false;\n\n        _transpose();\n\n        expanding = originalexpanding;\n        p2 = pop();\n\n        if (_count(p2) < _count(p1)) {\n          p1 = p2;\n        }\n\n        if (DEBUG) {\n          return console.log(\"collecting a transpose \" + p2);\n        }\n      }\n    }\n  };\n\n  f4 = function f4() {\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n\n    push(p1);\n    rationalize();\n    inverse();\n    rationalize();\n    inverse();\n    rationalize();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_trig = function simplify_trig() {\n    save();\n    p1 = pop();\n    f5();\n    push(p1);\n    return restore();\n  };\n\n  f5 = function f5() {\n    if (_Find(p1, symbol(SIN)) === 0 && _Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n\n    p2 = p1;\n    trigmode = 1;\n    push(p2);\n    Eval();\n    p3 = pop();\n    trigmode = 2;\n    push(p2);\n    Eval();\n    p4 = pop();\n    trigmode = 0;\n\n    if (_count(p4) < _count(p3) || nterms(p4) < nterms(p3)) {\n      p3 = p4;\n    }\n\n    if (_count(p3) < _count(p1) || nterms(p3) < nterms(p1)) {\n      return p1 = p3;\n    }\n  };\n\n  f9 = function f9() {\n    var oldp1, oldp2;\n\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n\n    push_integer(0);\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      push(car(p2));\n      simplify();\n      add();\n      oldp1 = p1;\n      oldp2 = p2;\n      p1 = pop();\n      simplify_rational_expressions();\n      push(p1);\n      p1 = oldp1;\n      p2 = oldp2;\n      p2 = cdr(p2);\n    }\n\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rational_expressions = function simplify_rational_expressions() {\n    var denom, num, polyVar, sasa, theGCD;\n    push(p1);\n\n    _denominator();\n\n    denom = pop();\n\n    if (isone(denom)) {\n      return;\n    }\n\n    push(p1);\n\n    _numerator();\n\n    num = pop();\n\n    if (isone(num)) {\n      return;\n    }\n\n    if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {\n      return;\n    }\n\n    push(num);\n    push(denom);\n    gcd();\n    push(polyVar);\n    factor();\n    theGCD = pop();\n\n    if (isone(theGCD)) {\n      return;\n    }\n\n    push(num);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    push(denom);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    divide();\n    Condense();\n    sasa = stack[tos - 1].toString();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rectToClock = function simplify_rectToClock() {\n    if (_Find(p1, symbol(SIN)) === 0 && _Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n\n    push(p1);\n    Eval();\n    clockform();\n    p2 = pop();\n\n    if (DEBUG) {\n      console.log(\"before simplification clockform: \" + p1 + \" after: \" + p2);\n    }\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_polarRect = function simplify_polarRect() {\n    push(p1);\n\n    _polarRectAMinusOneBase();\n\n    Eval();\n    p2 = pop();\n\n    if (_count(p2) < _count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  _polarRectAMinusOneBase = function polarRectAMinusOneBase() {\n    var h;\n    save();\n    p1 = pop();\n\n    if (isimaginaryunit(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {\n      push(one);\n      negate();\n      push(caddr(p1));\n\n      _polarRectAMinusOneBase();\n\n      power();\n      polar();\n\n      _rect();\n    } else if (iscons(p1)) {\n      h = tos;\n\n      while (iscons(p1)) {\n        push(car(p1));\n\n        _polarRectAMinusOneBase();\n\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n\n    restore();\n  };\n\n  nterms = function nterms(p) {\n    if (car(p) !== symbol(ADD)) {\n      return 1;\n    } else {\n      return length(p) - 1;\n    }\n  };\n\n  simplify_nested_radicals = function simplify_nested_radicals() {\n    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;\n\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n\n      return false;\n    }\n\n    push(p1);\n    somethingSimplified = _take_care_of_nested_radicals();\n    simplificationWithoutCondense = stack[tos - 1];\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    simplificationWithCondense = pop();\n\n    if (_countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < _countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {\n      push(simplificationWithoutCondense);\n    } else {\n      push(simplificationWithCondense);\n    }\n\n    p1 = pop();\n    return somethingSimplified;\n  };\n\n  _take_care_of_nested_radicals = function take_care_of_nested_radicals() {\n    var A, B, C, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;\n\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n\n      return false;\n    }\n\n    save();\n    p1 = pop();\n\n    if (equal(car(p1), symbol(POWER))) {\n      base = cadr(p1);\n      exponent = caddr(p1);\n\n      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {\n        firstTerm = cadr(base);\n        push(firstTerm);\n\n        _take_care_of_nested_radicals();\n\n        pop();\n        secondTerm = caddr(base);\n        push(secondTerm);\n\n        _take_care_of_nested_radicals();\n\n        pop();\n        numberOfTerms = 0;\n        countingTerms = base;\n\n        while (cdr(countingTerms) !== symbol(NIL)) {\n          numberOfTerms++;\n          countingTerms = cdr(countingTerms);\n        }\n\n        if (numberOfTerms > 2) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        commonInnerExponent = null;\n        commonBases = [];\n        termsThatAreNotPowers = [];\n\n        if (car(secondTerm) === symbol(MULTIPLY)) {\n          secondTermFactor = cdr(secondTerm);\n\n          if (iscons(secondTermFactor)) {\n            while (iscons(secondTermFactor)) {\n              potentialPower = car(secondTermFactor);\n\n              if (car(potentialPower) === symbol(POWER)) {\n                innerbase = cadr(potentialPower);\n                innerexponent = caddr(potentialPower);\n\n                if (equalq(innerexponent, 1, 2)) {\n                  if (commonInnerExponent == null) {\n                    commonInnerExponent = innerexponent;\n                    commonBases.push(innerbase);\n                  } else {\n                    if (equal(innerexponent, commonInnerExponent)) {\n                      commonBases.push(innerbase);\n                    } else {}\n                  }\n                }\n              } else {\n                termsThatAreNotPowers.push(potentialPower);\n              }\n\n              secondTermFactor = cdr(secondTermFactor);\n            }\n          }\n        } else if (car(secondTerm) === symbol(POWER)) {\n          innerbase = cadr(secondTerm);\n          innerexponent = caddr(secondTerm);\n\n          if (commonInnerExponent == null && equalq(innerexponent, 1, 2)) {\n            commonInnerExponent = innerexponent;\n            commonBases.push(innerbase);\n          }\n        }\n\n        if (commonBases.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        A = firstTerm;\n        push_integer(1);\n\n        for (l1 = 0, len = commonBases.length; l1 < len; l1++) {\n          i = commonBases[l1];\n          push(i);\n          multiply();\n        }\n\n        C = pop();\n        push_integer(1);\n\n        for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {\n          i = termsThatAreNotPowers[m1];\n          push(i);\n          multiply();\n        }\n\n        B = pop();\n\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          negate();\n          push(C);\n          multiply();\n          push(B);\n          divide();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push_integer(3);\n          push(C);\n          multiply();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(-3);\n          push(A);\n          multiply();\n          push(B);\n          divide();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push_integer(1);\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          multiply();\n          add();\n          add();\n          add();\n        } else if (equalq(exponent, 1, 2)) {\n          push(C);\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push_integer(-2);\n          push(A);\n          multiply();\n          push(B);\n          divide();\n          checkSize = pop();\n          push(checkSize);\n          real();\n\n          _yyfloat();\n\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(1);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n        }\n\n        push(symbol(SECRETX));\n        recursionLevelNestedRadicalsRemoval++;\n        roots();\n        recursionLevelNestedRadicalsRemoval--;\n\n        if (equal(stack[tos - 1], symbol(NIL))) {\n          if (DEBUG) {\n            console.log(\"roots bailed out because of too much recursion\");\n          }\n\n          pop();\n          push(p1);\n          restore();\n          return false;\n        }\n\n        possibleSolutions = [];\n        ref2 = stack[tos - 1].tensor.elem;\n\n        for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {\n          eachSolution = ref2[n1];\n\n          if (!_Find(eachSolution, symbol(POWER))) {\n            possibleSolutions.push(eachSolution);\n          }\n        }\n\n        pop();\n\n        if (possibleSolutions.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        possibleRationalSolutions = [];\n        realOfpossibleRationalSolutions = [];\n\n        for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {\n          i = possibleSolutions[o1];\n          push(i);\n          real();\n\n          _yyfloat();\n\n          possibleRationalSolutions.push(i);\n          realOfpossibleRationalSolutions.push(pop().d);\n        }\n\n        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));\n        SOLUTION = possibleRationalSolutions[whichRationalSolution];\n        /*\n        #possibleNewExpressions = []\n        #realOfPossibleNewExpressions = []\n         * pick the solution which cubic root has no radicals\n        lowercase_b = null\n        for SOLUTION in possibleSolutions\n          console.log(\"testing solution: \" + SOLUTION.toString())\n        \n          debugger\n          if equalq(exponent,1,3)\n            push(A)\n            push(SOLUTION)\n            push_integer(3)\n            power()\n            push_integer(3)\n            push(C)\n            multiply()\n            push(SOLUTION)\n            multiply()\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,3)\n            power()\n          else if equalq(exponent,1,2)\n            push(A)\n            push(SOLUTION)\n            push_integer(2)\n            power()\n            push(C)\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,2)\n            power()\n          console.log(\"b is: \" + stack[tos-1].toString())\n        \n          lowercase_b = pop()\n        \n          if !Find(lowercase_b, symbol(POWER))\n            break\n         */\n\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(3);\n          power();\n          push_integer(3);\n          push(C);\n          multiply();\n          push(SOLUTION);\n          multiply();\n          add();\n          divide();\n          push_rational(1, 3);\n          power();\n        } else if (equalq(exponent, 1, 2)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(2);\n          power();\n          push(C);\n          add();\n          divide();\n          push_rational(1, 2);\n          power();\n        }\n\n        lowercase_b = pop();\n\n        if (lowercase_b == null) {\n          push(p1);\n          restore();\n          return false;\n        }\n\n        push(lowercase_b);\n        push(SOLUTION);\n        multiply();\n\n        if (equalq(exponent, 1, 3)) {\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n        } else if (equalq(exponent, 1, 2)) {\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n          possibleNewExpression = pop();\n          push(possibleNewExpression);\n          real();\n\n          _yyfloat();\n\n          possibleNewExpressionValue = pop();\n\n          if (!isnegativenumber(possibleNewExpressionValue)) {\n            push(possibleNewExpression);\n          } else {\n            push(lowercase_b);\n            negate();\n            lowercase_b = pop();\n            push(lowercase_a);\n            negate();\n            lowercase_a = pop();\n            push(lowercase_b);\n            push(C);\n            push_rational(1, 2);\n            power();\n            multiply();\n            push(lowercase_a);\n            add();\n            simplify();\n          }\n        }\n\n        p1 = pop();\n        push(p1);\n        restore();\n        return true;\n      } else {\n        push(p1);\n        restore();\n        return false;\n      }\n    } else if (iscons(p1)) {\n      h = tos;\n      anyRadicalSimplificationWorked = false;\n\n      while (iscons(p1)) {\n        push(car(p1));\n        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || _take_care_of_nested_radicals();\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      restore();\n      return anyRadicalSimplificationWorked;\n    } else {\n      push(p1);\n      restore();\n      return false;\n    }\n\n    throw new Error(\"control flow should never reach here\");\n  };\n\n  Eval_sin = function Eval_sin() {\n    push(cadr(p1));\n    Eval();\n    return sine();\n  };\n\n  sine = function sine() {\n    save();\n    p1 = pop();\n\n    if (car(p1) === symbol(ADD)) {\n      sine_of_angle_sum();\n    } else {\n      sine_of_angle();\n    }\n\n    return restore();\n  };\n\n  sine_of_angle_sum = function sine_of_angle_sum() {\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      p4 = car(p2);\n\n      if (isnpi(p4)) {\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        sine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        cosine();\n        push(p4);\n        sine();\n        multiply();\n        add();\n        return;\n      }\n\n      p2 = cdr(p2);\n    }\n\n    return sine_of_angle();\n  };\n\n  sine_of_angle = function sine_of_angle() {\n    var d, n;\n\n    if (car(p1) === symbol(ARCSIN)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.sin(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      sine();\n      negate();\n      return;\n    }\n\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      multiply();\n      return;\n    }\n\n    push(p1);\n    push_integer(180);\n    multiply();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    divide();\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push(symbol(SIN));\n      push(p1);\n      list(2);\n      return;\n    }\n\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n\n      case 30:\n      case 150:\n        return push_rational(1, 2);\n\n      case 210:\n      case 330:\n        return push_rational(-1, 2);\n\n      case 45:\n      case 135:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 225:\n      case 315:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 60:\n      case 120:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 240:\n      case 300:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 90:\n        return push_integer(1);\n\n      case 270:\n        return push_integer(-1);\n\n      default:\n        push(symbol(SIN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_sinh = function Eval_sinh() {\n    push(cadr(p1));\n    Eval();\n    return ysinh();\n  };\n\n  ysinh = function ysinh() {\n    save();\n    yysinh();\n    return restore();\n  };\n\n  yysinh = function yysinh() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCSINH)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.sinh(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n\n    push_symbol(SINH);\n    push(p1);\n    return list(2);\n  };\n  /*\n    Substitute new expr for old expr in expr.\n  \n    Input:  push  expr\n  \n      push  old expr\n  \n      push  new expr\n  \n    Output:  Result on stack\n   */\n\n\n  _subst = function subst() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n\n    if (p2 === symbol(NIL) || p3 === symbol(NIL)) {\n      restore();\n      return;\n    }\n\n    p1 = pop();\n\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n\n      for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n\n      for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2);\n        push(p3);\n\n        _subst();\n\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n\n      push(p4);\n    } else if (equal(p1, p2)) {\n      push(p3);\n    } else if (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      push(p3);\n\n      _subst();\n\n      push(cdr(p1));\n      push(p2);\n      push(p3);\n\n      _subst();\n\n      cons();\n    } else {\n      push(p1);\n    }\n\n    return restore();\n  };\n\n  Eval_sum = function Eval_sum() {\n    var body, i, indexVariable, j, k, l1, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    body = cadr(p1);\n    indexVariable = caddr(p1);\n\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n\n    p4 = get_binding(indexVariable);\n    push_integer(0);\n\n    for (i = l1 = ref2 = j, ref3 = k; ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      add();\n    }\n\n    return set_binding(indexVariable, p4);\n  };\n\n  Eval_tan = function Eval_tan() {\n    push(cadr(p1));\n    Eval();\n    return tangent();\n  };\n\n  tangent = function tangent() {\n    save();\n    yytangent();\n    return restore();\n  };\n\n  yytangent = function yytangent() {\n    var d, n;\n    n = 0;\n    d = 0.0;\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.tan(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      tangent();\n      negate();\n      return;\n    }\n\n    push(p1);\n    push_integer(180);\n    multiply();\n\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n\n    divide();\n    n = pop_integer();\n\n    if (n < 0 || isNaN(n)) {\n      push(symbol(TAN));\n      push(p1);\n      list(2);\n      return;\n    }\n\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n\n      case 30:\n      case 210:\n        push_rational(1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 150:\n      case 330:\n        push_rational(-1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n\n      case 45:\n      case 225:\n        return push_integer(1);\n\n      case 135:\n      case 315:\n        return push_integer(-1);\n\n      case 60:\n      case 240:\n        push_integer(3);\n        push_rational(1, 2);\n        return power();\n\n      case 120:\n      case 300:\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return negate();\n\n      default:\n        push(symbol(TAN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_tanh = function Eval_tanh() {\n    var d;\n    d = 0.0;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n\n    if (car(p1) === symbol(ARCTANH)) {\n      push(cadr(p1));\n      return;\n    }\n\n    if (isdouble(p1)) {\n      d = Math.tanh(p1.d);\n\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n\n      push_double(d);\n      return;\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n\n    push_symbol(TANH);\n    push(p1);\n    return list(2);\n  };\n  /*\n  Taylor expansion of a function\n  \n    push(F)\n    push(X)\n    push(N)\n    push(A)\n    taylor()\n   */\n\n\n  Eval_taylor = function Eval_taylor() {\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(24);\n    } else {\n      push(p2);\n    }\n\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n\n    return taylor();\n  };\n\n  taylor = function taylor() {\n    var i, k, l1, ref2;\n    i = 0;\n    k = 0;\n    save();\n    p4 = pop();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p3);\n    k = pop_integer();\n\n    if (isNaN(k)) {\n      push_symbol(TAYLOR);\n      push(p1);\n      push(p2);\n      push(p3);\n      push(p4);\n      list(5);\n      restore();\n      return;\n    }\n\n    push(p1);\n    push(p2);\n    push(p4);\n\n    _subst();\n\n    Eval();\n    push_integer(1);\n    p5 = pop();\n\n    for (i = l1 = 1, ref2 = k; 1 <= ref2 ? l1 <= ref2 : l1 >= ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(p2);\n      derivative();\n      p1 = pop();\n\n      if (isZeroAtomOrTensor(p1)) {\n        break;\n      }\n\n      push(p5);\n      push(p2);\n      push(p4);\n      subtract();\n      multiply();\n      p5 = pop();\n      push(p1);\n      push(p2);\n      push(p4);\n\n      _subst();\n\n      Eval();\n      push(p5);\n      multiply();\n      push_integer(i);\n      factorial();\n      divide();\n      add();\n    }\n\n    return restore();\n  };\n  /* tensor =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  General description\n  -------------------\n  Tensors are a strange in-between of matrices and \"computer\"\n  rectangular data structures.\n  \n  Tensors, unlike matrices, and like rectangular data structures,\n  can have an arbitrary number of dimensions (rank), although a tensor with\n  rank zero is just a scalar.\n  \n  Tensors, like matrices and unlike many computer rectangular data structures,\n  must be \"contiguous\" i.e. have no empty spaces within its size, and \"uniform\",\n  i.e. each element must have the same shape and hence the same rank.\n  \n  Also tensors have necessarily to make a distinction between row vectors,\n  column vectors (which have a rank of 2) and uni-dimensional vectors (rank 1).\n  They look very similar but they are fundamentally different.\n  \n  Tensors are 1-indexed, as per general math notation, and like Fortran,\n  Lua, Mathematica, SASL, MATLAB, Julia, Erlang and APL.\n  \n  Tensors with elements that are also tensors get promoted to a higher rank\n  , this is so we can represent and get the rank of a matrix correctly.\n  Example:\n  Start with a tensor of rank 1 with 2 elements (i.e. shape: 2)\n  if you put in both its elements another 2 tensors\n  of rank 1 with 2 elements (i.e. shape: 2)\n  then the result is a tensor of rank 2 with shape 2,2\n  i.e. the dimension of a tensor at all times must be\n  the number of nested tensors in it.\n  Also, all tensors must be \"uniform\" i.e. they must be accessed\n  uniformly, which means that all existing elements of a tensor\n  must be contiguous and have the same shape.\n  Implication of it all is that you can't put arbitrary\n  tensors inside tensors (like you would do to represent block matrices)\n  Rather, all tensors inside tensors must have same shape (and hence, rank)\n  \n  Limitations\n  -----------\n  n.a.\n  \n  Implementation info\n  -------------------\n  Tensors are implemented...\n   */\n\n\n  Eval_tensor = function Eval_tensor() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    check_tensor_dimensions(p1);\n    nelem = p1.tensor.nelem;\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    check_tensor_dimensions(p2);\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      Eval();\n      b[i] = pop();\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return promote_tensor();\n  };\n\n  tensor_plus_tensor = function tensor_plus_tensor() {\n    var a, b, c, i, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n\n    if (ndim !== p2.tensor.ndim) {\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {\n        push(symbol(NIL));\n        restore();\n        return;\n      }\n    }\n\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = m1 = 0, ref3 = ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n\n    for (i = n1 = 0, ref4 = nelem; 0 <= ref4 ? n1 < ref4 : n1 > ref4; i = 0 <= ref4 ? ++n1 : --n1) {\n      push(a[i]);\n      push(b[i]);\n      add();\n      c[i] = pop();\n    }\n\n    push(p3);\n    return restore();\n  };\n\n  tensor_times_scalar = function tensor_times_scalar() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      multiply();\n      b[i] = pop();\n    }\n\n    push(p3);\n    return restore();\n  };\n\n  scalar_times_tensor = function scalar_times_tensor() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p2.tensor.ndim;\n    nelem = p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p2.tensor.dim[i];\n    }\n\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      push(a[i]);\n      multiply();\n      b[i] = pop();\n    }\n\n    push(p3);\n    return restore();\n  };\n\n  check_tensor_dimensions = function check_tensor_dimensions(p) {\n    if (p.tensor.nelem !== p.tensor.elem.length) {\n      console.log(\"something wrong in tensor dimensions\");\n      debugger;\n    }\n  };\n\n  is_square_matrix = function is_square_matrix(p) {\n    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  d_tensor_tensor = function d_tensor_tensor() {\n    var a, b, c, i, j, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n\n    if (ndim + 1 >= MAXDIM) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    p3 = alloc_tensor(nelem * p2.tensor.nelem);\n    p3.tensor.ndim = ndim + 1;\n\n    for (i = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    p3.tensor.dim[ndim] = p2.tensor.dim[0];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      for (j = n1 = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? n1 < ref4 : n1 > ref4; j = 0 <= ref4 ? ++n1 : --n1) {\n        push(a[i]);\n        push(b[j]);\n        derivative();\n        c[i * p2.tensor.nelem + j] = pop();\n      }\n    }\n\n    return push(p3);\n  };\n\n  d_scalar_tensor = function d_scalar_tensor() {\n    var a, b, i, l1, ref2;\n    p3 = alloc_tensor(p2.tensor.nelem);\n    p3.tensor.ndim = 1;\n    p3.tensor.dim[0] = p2.tensor.dim[0];\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = l1 = 0, ref2 = p2.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(a[i]);\n      derivative();\n      b[i] = pop();\n    }\n\n    return push(p3);\n  };\n\n  d_tensor_scalar = function d_tensor_scalar() {\n    var a, b, i, l1, m1, ref2, ref3;\n    i = 0;\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      derivative();\n      b[i] = pop();\n    }\n\n    return push(p3);\n  };\n\n  compare_tensors = function compare_tensors(p1, p2) {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n\n    if (p1.tensor.ndim < p2.tensor.ndim) {\n      return -1;\n    }\n\n    if (p1.tensor.ndim > p2.tensor.ndim) {\n      return 1;\n    }\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n        return -1;\n      }\n\n      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n        return 1;\n      }\n    }\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        continue;\n      }\n\n      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n\n  power_tensor = function power_tensor() {\n    var i, k, l1, m1, n, ref2, ref3, results;\n    i = 0;\n    k = 0;\n    n = 0;\n    k = p1.tensor.ndim - 1;\n\n    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    push(p2);\n    n = pop_integer();\n\n    if (isNaN(n)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n\n    if (n === 0) {\n      if (p1.tensor.ndim !== 2) {\n        stop(\"power(tensor,0) with tensor rank not equal to 2\");\n      }\n\n      n = p1.tensor.dim[0];\n      p1 = alloc_tensor(n * n);\n      p1.tensor.ndim = 2;\n      p1.tensor.dim[0] = n;\n      p1.tensor.dim[1] = n;\n\n      for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        p1.tensor.elem[n * i + i] = one;\n      }\n\n      check_tensor_dimensions(p1);\n      push(p1);\n      return;\n    }\n\n    if (n < 0) {\n      n = -n;\n      push(p1);\n\n      _inv();\n\n      p1 = pop();\n    }\n\n    push(p1);\n    results = [];\n\n    for (i = m1 = 1, ref3 = n; 1 <= ref3 ? m1 < ref3 : m1 > ref3; i = 1 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n\n      _inner();\n\n      if (isZeroAtomOrTensor(stack[tos - 1])) {\n        break;\n      } else {\n        results.push(void 0);\n      }\n    }\n\n    return results;\n  };\n\n  copy_tensor = function copy_tensor() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p1 = pop();\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[i];\n    }\n\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return restore();\n  };\n\n  promote_tensor = function promote_tensor() {\n    var i, j, k, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    j = 0;\n    k = 0;\n    nelem = 0;\n    ndim = 0;\n    save();\n    p1 = pop();\n\n    if (!istensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    p2 = p1.tensor.elem[0];\n\n    for (i = l1 = 1, ref2 = p1.tensor.nelem; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i = 1 <= ref2 ? ++l1 : --l1) {\n      if (!compatible(p2, p1.tensor.elem[i])) {\n        stop(\"Cannot promote tensor due to inconsistent tensor components.\");\n      }\n    }\n\n    if (!istensor(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n\n    if (ndim > MAXDIM) {\n      stop(\"tensor rank > \" + MAXDIM);\n    }\n\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n\n    for (i = m1 = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    for (j = n1 = 0, ref4 = p2.tensor.ndim; 0 <= ref4 ? n1 < ref4 : n1 > ref4; j = 0 <= ref4 ? ++n1 : --n1) {\n      p3.tensor.dim[i + j] = p2.tensor.dim[j];\n    }\n\n    k = 0;\n\n    for (i = o1 = 0, ref5 = p1.tensor.nelem; 0 <= ref5 ? o1 < ref5 : o1 > ref5; i = 0 <= ref5 ? ++o1 : --o1) {\n      p2 = p1.tensor.elem[i];\n\n      for (j = q1 = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? q1 < ref6 : q1 > ref6; j = 0 <= ref6 ? ++q1 : --q1) {\n        p3.tensor.elem[k++] = p2.tensor.elem[j];\n      }\n    }\n\n    check_tensor_dimensions(p2);\n    check_tensor_dimensions(p3);\n    push(p3);\n    return restore();\n  };\n\n  compatible = function compatible(p, q) {\n    var i, l1, ref2;\n\n    if (!istensor(p) && !istensor(q)) {\n      return 1;\n    }\n\n    if (!istensor(p) || !istensor(q)) {\n      return 0;\n    }\n\n    if (p.tensor.ndim !== q.tensor.ndim) {\n      return 0;\n    }\n\n    for (i = l1 = 0, ref2 = p.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p.tensor.dim[i] !== q.tensor.dim[i]) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  Eval_test = function Eval_test() {\n    var checkResult, orig;\n    orig = p1;\n    p1 = cdr(p1);\n\n    while (iscons(p1)) {\n      if (cdr(p1) === symbol(NIL)) {\n        push(car(p1));\n        Eval();\n        return;\n      }\n\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));\n\n      if (checkResult == null) {\n        push(orig);\n        return;\n      } else if (checkResult) {\n        push(cadr(p1));\n        Eval();\n        return;\n      } else {\n        p1 = cddr(p1);\n      }\n    }\n\n    return push_integer(0);\n  };\n\n  Eval_testeq = function Eval_testeq() {\n    var checkResult, orig, subtractionResult;\n    orig = p1;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if (checkResult != null && !checkResult) {\n      push_integer(1);\n      return;\n    }\n\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if (checkResult != null && !checkResult) {\n      push_integer(1);\n      return;\n    }\n\n    return push(orig);\n  };\n\n  Eval_testge = function Eval_testge() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison >= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testgt = function Eval_testgt() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison > 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testle = function Eval_testle() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison <= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testlt = function Eval_testlt() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n\n    if (comparison < 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_not = function Eval_not() {\n    var checkResult, wholeAndExpression;\n    wholeAndExpression = p1;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n\n    if (checkResult == null) {\n      return push(wholeAndExpression);\n    } else if (checkResult) {\n      return push_integer(0);\n    } else {\n      return push_integer(1);\n    }\n  };\n  /* and =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  a,b,...\n  \n  General description\n  -------------------\n  Logical-and of predicate expressions.\n   */\n\n\n  Eval_and = function Eval_and() {\n    var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;\n    wholeAndExpression = p1;\n    andPredicates = cdr(wholeAndExpression);\n    somePredicateUnknown = false;\n\n    while (iscons(andPredicates)) {\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));\n\n      if (checkResult == null) {\n        somePredicateUnknown = true;\n        andPredicates = cdr(andPredicates);\n      } else if (checkResult) {\n        andPredicates = cdr(andPredicates);\n      } else if (!checkResult) {\n        push_integer(0);\n        return;\n      }\n    }\n\n    if (somePredicateUnknown) {\n      return push(wholeAndExpression);\n    } else {\n      return push_integer(1);\n    }\n  };\n\n  Eval_or = function Eval_or() {\n    var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;\n    wholeOrExpression = p1;\n    orPredicates = cdr(wholeOrExpression);\n    somePredicateUnknown = false;\n\n    while (iscons(orPredicates)) {\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));\n\n      if (checkResult == null) {\n        somePredicateUnknown = true;\n        orPredicates = cdr(orPredicates);\n      } else if (checkResult) {\n        push_integer(1);\n        return;\n      } else if (!checkResult) {\n        orPredicates = cdr(orPredicates);\n      }\n    }\n\n    if (somePredicateUnknown) {\n      return push(wholeOrExpression);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  cmp_args = function cmp_args() {\n    var t;\n    t = 0;\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    p1 = pop();\n\n    if (p1.k !== NUM && p1.k !== DOUBLE) {\n      push(p1);\n\n      _yyfloat();\n\n      Eval();\n      p1 = pop();\n    }\n\n    if (isZeroAtomOrTensor(p1)) {\n      return 0;\n    }\n\n    switch (p1.k) {\n      case NUM:\n        if (MSIGN(p1.q.a) === -1) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n\n        break;\n\n      case DOUBLE:\n        if (p1.d < 0.0) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n\n        break;\n\n      default:\n        t = null;\n    }\n\n    return t;\n  };\n  /*\n  Transform an expression using a pattern. The\n  pattern can come from the integrals table or\n  the user-defined patterns.\n  \n  The expression and free variable are on the stack.\n  \n  The argument s is a null terminated list of transform rules.\n  \n  For example, see the itab (integrals table)\n  \n  Internally, the following symbols are used:\n  \n    F  input expression\n  \n    X  free variable, i.e. F of X\n  \n    A  template expression\n  \n    B  result expression\n  \n    C  list of conditional expressions\n  \n  Puts the final expression on top of stack\n  (whether it's transformed or not) and returns\n  true is successful, false if not.\n   */\n\n\n  _transform = function transform(s, generalTransform) {\n    var bookmarkTosToPrintDecomps, eachTransformEntry, i, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;\n    transform_h = 0;\n    save();\n    p1 = null;\n    p4 = pop();\n    p3 = pop();\n\n    if (DEBUG) {\n      console.log(\"         !!!!!!!!!   transform on: \" + p3);\n    }\n\n    saveMetaBindings();\n    set_binding(symbol(METAX), p4);\n    transform_h = tos;\n    push_integer(1);\n    push(p3);\n    push(p4);\n\n    _polyform();\n\n    push(p4);\n    bookmarkTosToPrintDecomps = tos - 2;\n\n    _decomp(generalTransform);\n\n    numberOfDecomps = tos - bookmarkTosToPrintDecomps;\n\n    if (DEBUG) {\n      console.log(\"  \" + numberOfDecomps + \" decomposed elements ====== \");\n\n      for (i = l1 = 0, ref2 = numberOfDecomps; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        console.log(\"  decomposition element \" + i + \": \" + stack[tos - 1 - i]);\n      }\n    }\n\n    transformationSuccessful = false;\n\n    if (generalTransform) {\n      if (!isNumericAtom(p3)) {\n        theTransform = s;\n\n        if (DEBUG) {\n          console.log(\"applying transform: \" + theTransform);\n        }\n\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + theTransform);\n        }\n\n        push(theTransform);\n        push(symbol(SYMBOL_A_UNDERSCORE));\n        push(symbol(METAA));\n\n        _subst();\n\n        push(symbol(SYMBOL_B_UNDERSCORE));\n        push(symbol(METAB));\n\n        _subst();\n\n        push(symbol(SYMBOL_X_UNDERSCORE));\n        push(symbol(METAX));\n\n        _subst();\n\n        p1 = pop();\n        p5 = car(p1);\n\n        if (DEBUG) {\n          console.log(\"template expression: \" + p5);\n        }\n\n        p6 = cadr(p1);\n        p7 = cddr(p1);\n        /*\n        p5 = p1.tensor.elem[0]\n        p6 = p1.tensor.elem[1]\n        for i in [2..(p1.tensor.elem.length-1)]\n          push p1.tensor.elem[i]\n        list(p1.tensor.elem.length - 2)\n        p7 = pop()\n         */\n\n        if (f_equals_a(transform_h, generalTransform)) {\n          transformationSuccessful = true;\n        } else {\n          if (DEBUG) {\n            console.log(\"p3 at this point: \" + p3);\n          }\n\n          transformedTerms = [];\n\n          if (DEBUG) {\n            console.log(\"car(p3): \" + car(p3));\n          }\n\n          restTerm = p3;\n\n          if (iscons(restTerm)) {\n            transformedTerms.push(car(p3));\n            restTerm = cdr(p3);\n          }\n\n          while (iscons(restTerm)) {\n            secondTerm = car(restTerm);\n            restTerm = cdr(restTerm);\n\n            if (DEBUG) {\n              console.log(\"tos before recursive transform: \" + tos);\n            }\n\n            push(secondTerm);\n            push_symbol(NIL);\n\n            if (DEBUG) {\n              console.log(\"testing: \" + secondTerm);\n            }\n\n            if (DEBUG) {\n              console.log(\"about to try to simplify other term: \" + secondTerm);\n            }\n\n            success = _transform(s, generalTransform);\n            transformationSuccessful = transformationSuccessful || success;\n            transformedTerms.push(pop());\n\n            if (DEBUG) {\n              console.log(\"tried to simplify other term: \" + secondTerm + \" ...successful?: \" + success + \" ...transformed: \" + transformedTerms[transformedTerms.length - 1]);\n            }\n          }\n\n          if (transformedTerms.length !== 0) {\n            for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {\n              i = transformedTerms[m1];\n              push(i);\n            }\n\n            list(transformedTerms.length);\n            p6 = pop();\n          }\n        }\n      }\n    } else {\n      for (n1 = 0, len1 = s.length; n1 < len1; n1++) {\n        eachTransformEntry = s[n1];\n\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + eachTransformEntry);\n\n          if ((eachTransformEntry + \"\").indexOf(\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\") !== -1) {\n            debugger;\n          }\n        }\n\n        if (eachTransformEntry) {\n          scan_meta(eachTransformEntry);\n          p1 = pop();\n          p5 = cadr(p1);\n          p6 = caddr(p1);\n          p7 = cdddr(p1);\n          /*\n          p5 = p1.tensor.elem[0]\n          p6 = p1.tensor.elem[1]\n          for i in [2..(p1.tensor.elem.length-1)]\n            push p1.tensor.elem[i]\n          list(p1.tensor.elem.length - 2)\n          p7 = pop()\n           */\n\n          if (f_equals_a(transform_h, generalTransform)) {\n            transformationSuccessful = true;\n            break;\n          }\n        }\n      }\n    }\n\n    moveTos(transform_h);\n\n    if (transformationSuccessful) {\n      push(p6);\n      Eval();\n      p1 = pop();\n      transformationSuccessful = true;\n    } else {\n      if (generalTransform) {\n        p1 = p3;\n      } else {\n        p1 = symbol(NIL);\n      }\n    }\n\n    restoreMetaBindings();\n    push(p1);\n    restore();\n    return transformationSuccessful;\n  };\n\n  saveMetaBindings = function saveMetaBindings() {\n    push(get_binding(symbol(METAA)));\n    push(get_binding(symbol(METAB)));\n    return push(get_binding(symbol(METAX)));\n  };\n\n  restoreMetaBindings = function restoreMetaBindings() {\n    set_binding(symbol(METAX), pop());\n    set_binding(symbol(METAB), pop());\n    return set_binding(symbol(METAA), pop());\n  };\n\n  f_equals_a = function f_equals_a(h, generalTransform) {\n    var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;\n    fea_i = 0;\n    fea_j = 0;\n\n    for (fea_i = l1 = ref2 = h, ref3 = tos; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; fea_i = ref2 <= ref3 ? ++l1 : --l1) {\n      set_binding(symbol(METAA), stack[fea_i]);\n\n      if (DEBUG) {\n        console.log(\"  binding METAA to \" + get_binding(symbol(METAA)));\n      }\n\n      for (fea_j = m1 = ref4 = h, ref5 = tos; ref4 <= ref5 ? m1 < ref5 : m1 > ref5; fea_j = ref4 <= ref5 ? ++m1 : --m1) {\n        set_binding(symbol(METAB), stack[fea_j]);\n\n        if (DEBUG) {\n          console.log(\"  binding METAB to \" + get_binding(symbol(METAB)));\n        }\n\n        p1 = p7;\n\n        while (iscons(p1)) {\n          push(car(p1));\n          Eval();\n          p2 = pop();\n\n          if (isZeroAtomOrTensor(p2)) {\n            break;\n          }\n\n          p1 = cdr(p1);\n        }\n\n        if (iscons(p1)) {\n          continue;\n        }\n\n        push(p3);\n\n        if (DEBUG) {\n          console.log(\"about to evaluate template expression: \" + p5 + \" binding METAA to \" + get_binding(symbol(METAA)) + \" and binding METAB to \" + get_binding(symbol(METAB)) + \" and binding METAX to \" + get_binding(symbol(METAX)));\n        }\n\n        push(p5);\n\n        if (generalTransform) {\n          originalexpanding = expanding;\n          expanding = false;\n        }\n\n        Eval();\n\n        if (generalTransform) {\n          expanding = originalexpanding;\n        }\n\n        if (DEBUG) {\n          console.log(\"  comparing \" + stack[tos - 1] + \" to: \" + stack[tos - 2]);\n        }\n\n        subtract();\n        p1 = pop();\n\n        if (isZeroAtomOrTensor(p1)) {\n          if (DEBUG) {\n            console.log(\"binding METAA to \" + get_binding(symbol(METAA)));\n            console.log(\"binding METAB to \" + get_binding(symbol(METAB)));\n            console.log(\"binding METAX to \" + get_binding(symbol(METAX)));\n            console.log(\"comparing \" + p3 + \" to: \" + p5);\n          }\n\n          return 1;\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  Eval_transpose = function Eval_transpose() {\n    push(cadr(p1));\n    Eval();\n\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n\n    return _transpose();\n  };\n\n  _transpose = function transpose() {\n    var a, accumulator, ai, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, l1, m, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    ai = [];\n    an = [];\n\n    for (i = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n\n    if (isNumericAtom(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    if (isplusone(p2) && isplustwo(p3) || isplusone(p3) && isplustwo(p2)) {\n      if (isidentitymatrix(p1)) {\n        push(p1);\n        restore();\n        return;\n      }\n    }\n\n    if (istranspose(p1)) {\n      innerTranspSwitch1 = car(cdr(cdr(p1)));\n      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));\n\n      if (equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2) || equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2) || equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL)) && (isplusone(p3) && isplustwo(p2) || isplusone(p2) && isplustwo(p3))) {\n        push(car(cdr(p1)));\n        restore();\n        return;\n      }\n    }\n\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      push(zero);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        push(p3);\n\n        _transpose();\n\n        add();\n        p1 = cdr(p1);\n      }\n\n      restore();\n      return;\n    }\n\n    if (expanding && ismultiply(p1)) {\n      p1 = cdr(p1);\n      push(one);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        push(p3);\n\n        _transpose();\n\n        multiply();\n        p1 = cdr(p1);\n      }\n\n      restore();\n      return;\n    }\n\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n\n      while (iscons(p1)) {\n        accumulator.push([car(p1), p2, p3]);\n        p1 = cdr(p1);\n      }\n\n      for (eachEntry = m1 = ref3 = accumulator.length - 1; ref3 <= 0 ? m1 <= 0 : m1 >= 0; eachEntry = ref3 <= 0 ? ++m1 : --m1) {\n        push(accumulator[eachEntry][0]);\n        push(accumulator[eachEntry][1]);\n        push(accumulator[eachEntry][2]);\n\n        _transpose();\n\n        if (eachEntry !== accumulator.length - 1) {\n          _inner();\n        }\n      }\n\n      restore();\n      return;\n    }\n\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        push_symbol(TRANSPOSE);\n        push(p1);\n\n        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {\n          push(p2);\n          push(p3);\n          list(4);\n        } else {\n          list(2);\n        }\n\n        restore();\n        return;\n      }\n\n      push(zero);\n      restore();\n      return;\n    }\n\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n\n    if (ndim === 1) {\n      push(p1);\n      restore();\n      return;\n    }\n\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n\n    if (l < 1 || l > ndim || m < 1 || m > ndim) {\n      stop(\"transpose: index out of range\");\n    }\n\n    l--;\n    m--;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n\n    for (i = n1 = 0, ref4 = ndim; 0 <= ref4 ? n1 < ref4 : n1 > ref4; i = 0 <= ref4 ? ++n1 : --n1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n\n    p2.tensor.dim[l] = p1.tensor.dim[m];\n    p2.tensor.dim[m] = p1.tensor.dim[l];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n\n    for (i = o1 = 0, ref5 = ndim; 0 <= ref5 ? o1 < ref5 : o1 > ref5; i = 0 <= ref5 ? ++o1 : --o1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n\n    for (i = q1 = 0, ref6 = nelem; 0 <= ref6 ? q1 < ref6 : q1 > ref6; i = 0 <= ref6 ? ++q1 : --q1) {\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      k = 0;\n\n      for (j = r1 = 0, ref7 = ndim; 0 <= ref7 ? r1 < ref7 : r1 > ref7; j = 0 <= ref7 ? ++r1 : --r1) {\n        k = k * an[j] + ai[j];\n      }\n\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      b[k] = a[i];\n\n      for (j = s1 = ref8 = ndim - 1; ref8 <= 0 ? s1 <= 0 : s1 >= 0; j = ref8 <= 0 ? ++s1 : --s1) {\n        if (++ai[j] < an[j]) {\n          break;\n        }\n\n        ai[j] = 0;\n      }\n    }\n\n    push(p2);\n    return restore();\n  };\n  /* d =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n  \n  Parameters\n  ----------\n  f,x\n  \n  General description\n  -------------------\n  Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].\n   */\n\n\n  Eval_user_function = function Eval_user_function() {\n    var bodyAndFormalArguments, h;\n\n    if (DEBUG) {\n      console.log(\"Eval_user_function evaluating: \" + car(p1));\n    }\n\n    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {\n      Eval_derivative();\n      return;\n    }\n\n    push(car(p1));\n    Eval();\n    bodyAndFormalArguments = pop();\n\n    if (isNumericAtom(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.\");\n    } else if (istensor(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.\");\n    } else if (isstr(bodyAndFormalArguments)) {\n      stop(\"expected function, found string instead.\");\n    }\n\n    p3 = car(cdr(bodyAndFormalArguments));\n    p4 = car(cdr(cdr(bodyAndFormalArguments)));\n    p5 = cdr(p1);\n\n    if (car(bodyAndFormalArguments) !== symbol(FUNCTION) || bodyAndFormalArguments === car(p1)) {\n      h = tos;\n      push(bodyAndFormalArguments);\n      p1 = p5;\n\n      while (iscons(p1)) {\n        push(car(p1));\n        Eval();\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      return;\n    }\n\n    p1 = p4;\n    p2 = p5;\n    h = tos;\n\n    while (iscons(p1) && iscons(p2)) {\n      push(car(p1));\n      push(car(p2));\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n\n    list(tos - h);\n    p6 = pop();\n    push(p3);\n\n    if (iscons(p6)) {\n      push(p6);\n\n      _rewrite_args();\n    }\n\n    return Eval();\n  };\n\n  _rewrite_args = function rewrite_args() {\n    var h, n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n\n    if (istensor(p1)) {\n      n = rewrite_args_tensor();\n      restore();\n      return n;\n    }\n\n    if (iscons(p1)) {\n      h = tos;\n\n      if (car(p1) === car(p2)) {\n        push_symbol(EVAL);\n        push(car(cdr(p2)));\n        list(2);\n      } else {\n        push(car(p1));\n      }\n\n      p1 = cdr(p1);\n\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        n += _rewrite_args();\n        p1 = cdr(p1);\n      }\n\n      list(tos - h);\n      restore();\n      return n;\n    }\n\n    if (!issymbol(p1)) {\n      push(p1);\n      restore();\n      return 0;\n    }\n\n    p3 = p2;\n\n    while (iscons(p3)) {\n      if (p1 === car(p3)) {\n        push(cadr(p3));\n        restore();\n        return 1;\n      }\n\n      p3 = cddr(p3);\n    }\n\n    p3 = get_binding(p1);\n    push(p3);\n\n    if (p1 !== p3) {\n      push(p2);\n      n = _rewrite_args();\n\n      if (n === 0) {\n        pop();\n        push(p1);\n      }\n    }\n\n    restore();\n    return n;\n  };\n\n  rewrite_args_tensor = function rewrite_args_tensor() {\n    var i, l1, n, ref2;\n    n = 0;\n    i = 0;\n    push(p1);\n    copy_tensor();\n    p1 = pop();\n\n    for (i = l1 = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      n += _rewrite_args();\n      p1.tensor.elem[i] = pop();\n    }\n\n    check_tensor_dimensions(p1);\n    push(p1);\n    return n;\n  };\n\n  Eval_zero = function Eval_zero() {\n    var i, k, l1, m, m1, n, ref2, ref3;\n    i = 0;\n    k = [];\n    m = 0;\n    n = 0;\n\n    for (i = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      k[i] = 0;\n    }\n\n    m = 1;\n    n = 0;\n    p2 = cdr(p1);\n\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      i = pop_integer();\n\n      if (i < 1 || isNaN(i)) {\n        push(zero);\n        return;\n      }\n\n      m *= i;\n      k[n++] = i;\n      p2 = cdr(p2);\n    }\n\n    if (n === 0) {\n      push(zero);\n      return;\n    }\n\n    p1 = alloc_tensor(m);\n    p1.tensor.ndim = n;\n\n    for (i = m1 = 0, ref3 = n; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i = 0 <= ref3 ? ++m1 : --m1) {\n      p1.tensor.dim[i] = k[i];\n    }\n\n    return push(p1);\n  };\n  /*\n  // up to 100 blocks of 100,000 atoms\n  \n  #define M 100\n  #define N 100000\n  \n  U *mem[M]\n  int mcount\n  \n  U *free_list\n  int free_count\n  \n  U *\n  alloc(void)\n  {\n    U *p\n    if (free_count == 0) {\n      if (mcount == 0)\n        alloc_mem()\n      else {\n        gc()\n        if (free_count < N * mcount / 2)\n          alloc_mem()\n      }\n      if (free_count == 0)\n        stop(\"atom space exhausted\")\n    }\n    p = free_list\n    free_list = free_list->u.cons.cdr\n    free_count--\n    return p\n  }\n   */\n\n\n  allocatedId = 0;\n\n  alloc_tensor = function alloc_tensor(nelem) {\n    var i, l1, p, ref2;\n    i = 0;\n    p = new U();\n    p.k = TENSOR;\n    p.tensor = new tensor();\n    p.tensor.nelem = nelem;\n\n    for (i = l1 = 0, ref2 = nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      p.tensor.elem[i] = zero;\n    }\n\n    p.tensor.allocatedId = allocatedId;\n    allocatedId++;\n    check_tensor_dimensions(p);\n    return p;\n  };\n  /*\n  // garbage collector\n  \n  void\n  gc(void)\n  {\n    int i, j\n    U *p\n  \n    // tag everything\n  \n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++)\n        p[j].tag = 1\n    }\n  \n    // untag what's used\n  \n    untag(p0)\n    untag(p1)\n    untag(p2)\n    untag(p3)\n    untag(p4)\n    untag(p5)\n    untag(p6)\n    untag(p7)\n    untag(p8)\n    untag(p9)\n  \n    untag(one)\n    untag(zero)\n    untag(imaginaryunit)\n  \n    for (i = 0; i < NSYM; i++) {\n      untag(binding[i])\n      untag(arglist[i])\n    }\n  \n    for (i = 0; i < tos; i++)\n      untag(stack[i])\n  \n    for (i = (int) (frame - stack); i < TOS; i++)\n      untag(stack[i])\n  \n    // collect everything that's still tagged\n  \n    free_count = 0\n  \n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++) {\n        if (p[j].tag == 0)\n          continue\n        // still tagged so it's unused, put on free list\n        switch (p[j].k) {\n        case TENSOR:\n          free(p[j].u.tensor)\n          break\n        case STR:\n          free(p[j].u.str)\n          break\n        case NUM:\n          mfree(p[j].u.q.a)\n          mfree(p[j].u.q.b)\n          break\n        }\n        p[j].k = CONS; // so no double free occurs above\n        p[j].u.cons.cdr = free_list\n        free_list = p + j\n        free_count++\n      }\n    }\n  }\n  \n  void\n  untag(U *p)\n  {\n    int i\n  \n    if (iscons(p)) {\n      do {\n        if (p->tag == 0)\n          return\n        p->tag = 0\n        untag(p->u.cons.car)\n        p = p->u.cons.cdr\n      } while (iscons(p))\n      untag(p)\n      return\n    }\n  \n    if (p->tag) {\n      p->tag = 0\n       if (istensor(p)) {\n        for (i = 0; i < p->u.tensor->nelem; i++)\n          untag(p->u.tensor->elem[i])\n      }\n    }\n  }\n  \n  // get memory for 100,000 atoms\n  \n  void\n  alloc_mem(void)\n  {\n    int i\n    U *p\n    if (mcount == M)\n      return\n    p = (U *) malloc(N * sizeof (struct U))\n    if (p == NULL)\n      return\n    mem[mcount++] = p\n    for (i = 0; i < N; i++) {\n      p[i].k = CONS; // so no free in gc\n      p[i].u.cons.cdr = p + i + 1\n    }\n    p[N - 1].u.cons.cdr = free_list\n    free_list = p\n    free_count += N\n  }\n  \n  void\n  print_mem_info(void)\n  {\n    char buf[100]\n  \n    sprintf(buf, \"%d blocks (%d bytes/block)\\n\", N * mcount, (int) sizeof (U))\n    printstr(buf)\n  \n    sprintf(buf, \"%d free\\n\", free_count)\n    printstr(buf)\n  \n    sprintf(buf, \"%d used\\n\", N * mcount - free_count)\n    printstr(buf)\n  }\n   */\n\n\n  _Find = function Find(p, q) {\n    var i, l1, ref2;\n    i = 0;\n\n    if (equal(p, q)) {\n      return 1;\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        if (_Find(p.tensor.elem[i], q)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    }\n\n    while (iscons(p)) {\n      if (_Find(car(p), q)) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  _findPossibleClockForm = function findPossibleClockForm(p) {\n    var i, l1, ref2;\n    i = 0;\n\n    if (isimaginaryunit(p)) {\n      return 0;\n    }\n\n    if (car(p) === symbol(POWER) && !isinteger(caddr(p1))) {\n      if (_Find(cadr(p), imaginaryunit)) {\n        return 1;\n      }\n    }\n\n    if (car(p) === symbol(POWER) && equaln(cadr(p), -1) && !isinteger(caddr(p1))) {\n      return 1;\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        if (_findPossibleClockForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n\n      return 0;\n    }\n\n    while (iscons(p)) {\n      if (_findPossibleClockForm(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  _findPossibleExponentialForm = function findPossibleExponentialForm(p) {\n    var i, l1, ref2;\n    i = 0;\n\n    if (car(p) === symbol(POWER) && cadr(p) === symbol(E)) {\n      return _Find(caddr(p), imaginaryunit);\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        if (_findPossibleExponentialForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n\n      return 0;\n    }\n\n    while (iscons(p)) {\n      if (_findPossibleExponentialForm(car(p))) {\n        return 1;\n      }\n\n      p = cdr(p);\n    }\n\n    return 0;\n  };\n\n  $.Find = _Find;\n\n  init = function init() {\n    var i, l1, ref2;\n    i = 0;\n    flag = 0;\n    reset_after_error();\n    chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n\n    if (flag) {\n      return;\n    }\n\n    flag = 1;\n\n    for (i = l1 = 0, ref2 = NSYM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      isSymbolReclaimable[i] = false;\n    }\n\n    return defn();\n  };\n  /* cross =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n  \n  Parameters\n  ----------\n  u,v\n  \n  General description\n  -------------------\n  Returns the cross product of vectors u and v.\n   */\n\n  /* curl =====================================================================\n  \n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n  \n  Parameters\n  ----------\n  u\n  \n  General description\n  -------------------\n  Returns the curl of vector u.\n   */\n\n\n  defn_str = [\"version=\\\"\" + version + \"\\\"\", \"e=exp(1)\", \"i=sqrt(-1)\", \"autoexpand=1\", \"assumeRealVariables=1\", \"trange=[-pi,pi]\", \"xrange=[-10,10]\", \"yrange=[-10,10]\", \"last=0\", \"trace=0\", \"forceFixedPrintout=1\", \"maxFixedPrintoutDigits=6\", \"printLeaveEAlone=1\", \"printLeaveXAlone=0\", \"cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]\", \"curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]\", \"div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)\", \"ln(x)=log(x)\"];\n\n  defn = function defn() {\n    var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;\n    p0 = symbol(NIL);\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    p3 = symbol(NIL);\n    p4 = symbol(NIL);\n    p5 = symbol(NIL);\n    p6 = symbol(NIL);\n    p7 = symbol(NIL);\n    p8 = symbol(NIL);\n    p9 = symbol(NIL);\n    std_symbol(\"abs\", ABS);\n    std_symbol(\"add\", ADD);\n    std_symbol(\"adj\", ADJ);\n    std_symbol(\"and\", AND);\n    std_symbol(\"approxratio\", APPROXRATIO);\n    std_symbol(\"arccos\", ARCCOS);\n    std_symbol(\"arccosh\", ARCCOSH);\n    std_symbol(\"arcsin\", ARCSIN);\n    std_symbol(\"arcsinh\", ARCSINH);\n    std_symbol(\"arctan\", ARCTAN);\n    std_symbol(\"arctanh\", ARCTANH);\n    std_symbol(\"arg\", ARG);\n    std_symbol(\"atomize\", ATOMIZE);\n    std_symbol(\"besselj\", BESSELJ);\n    std_symbol(\"bessely\", BESSELY);\n    std_symbol(\"binding\", BINDING);\n    std_symbol(\"binomial\", BINOMIAL);\n    std_symbol(\"ceiling\", CEILING);\n    std_symbol(\"check\", CHECK);\n    std_symbol(\"choose\", CHOOSE);\n    std_symbol(\"circexp\", CIRCEXP);\n    std_symbol(\"clear\", CLEAR);\n    std_symbol(\"clearall\", CLEARALL);\n    std_symbol(\"clearpatterns\", CLEARPATTERNS);\n    std_symbol(\"clock\", CLOCK);\n    std_symbol(\"coeff\", COEFF);\n    std_symbol(\"cofactor\", COFACTOR);\n    std_symbol(\"condense\", CONDENSE);\n    std_symbol(\"conj\", CONJ);\n    std_symbol(\"contract\", CONTRACT);\n    std_symbol(\"cos\", COS);\n    std_symbol(\"cosh\", COSH);\n    std_symbol(\"decomp\", DECOMP);\n    std_symbol(\"defint\", DEFINT);\n    std_symbol(\"deg\", DEGREE);\n    std_symbol(\"denominator\", DENOMINATOR);\n    std_symbol(\"det\", DET);\n    std_symbol(\"derivative\", DERIVATIVE);\n    std_symbol(\"dim\", DIM);\n    std_symbol(\"dirac\", DIRAC);\n    std_symbol(\"divisors\", DIVISORS);\n    std_symbol(\"do\", DO);\n    std_symbol(\"dot\", DOT);\n    std_symbol(\"draw\", DRAW);\n    std_symbol(\"dsolve\", DSOLVE);\n    std_symbol(\"erf\", ERF);\n    std_symbol(\"erfc\", ERFC);\n    std_symbol(\"eigen\", EIGEN);\n    std_symbol(\"eigenval\", EIGENVAL);\n    std_symbol(\"eigenvec\", EIGENVEC);\n    std_symbol(\"eval\", EVAL);\n    std_symbol(\"exp\", EXP);\n    std_symbol(\"expand\", EXPAND);\n    std_symbol(\"expcos\", EXPCOS);\n    std_symbol(\"expsin\", EXPSIN);\n    std_symbol(\"factor\", FACTOR);\n    std_symbol(\"factorial\", FACTORIAL);\n    std_symbol(\"factorpoly\", FACTORPOLY);\n    std_symbol(\"filter\", FILTER);\n    std_symbol(\"float\", FLOATF);\n    std_symbol(\"floor\", FLOOR);\n    std_symbol(\"for\", FOR);\n    std_symbol(\"function\", FUNCTION);\n    std_symbol(\"Gamma\", GAMMA);\n    std_symbol(\"gcd\", GCD);\n    std_symbol(\"hermite\", HERMITE);\n    std_symbol(\"hilbert\", HILBERT);\n    std_symbol(\"imag\", IMAG);\n    std_symbol(\"component\", INDEX);\n    std_symbol(\"inner\", INNER);\n    std_symbol(\"integral\", INTEGRAL);\n    std_symbol(\"inv\", INV);\n    std_symbol(\"invg\", INVG);\n    std_symbol(\"isinteger\", ISINTEGER);\n    std_symbol(\"isprime\", ISPRIME);\n    std_symbol(\"laguerre\", LAGUERRE);\n    std_symbol(\"lcm\", LCM);\n    std_symbol(\"leading\", LEADING);\n    std_symbol(\"legendre\", LEGENDRE);\n    std_symbol(\"log\", LOG);\n    std_symbol(\"lookup\", LOOKUP);\n    std_symbol(\"mod\", MOD);\n    std_symbol(\"multiply\", MULTIPLY);\n    std_symbol(\"not\", NOT);\n    std_symbol(\"nroots\", NROOTS);\n    std_symbol(\"number\", NUMBER);\n    std_symbol(\"numerator\", NUMERATOR);\n    std_symbol(\"operator\", OPERATOR);\n    std_symbol(\"or\", OR);\n    std_symbol(\"outer\", OUTER);\n    std_symbol(\"pattern\", PATTERN);\n    std_symbol(\"patternsinfo\", PATTERNSINFO);\n    std_symbol(\"polar\", POLAR);\n    std_symbol(\"power\", POWER);\n    std_symbol(\"prime\", PRIME);\n    std_symbol(\"print\", PRINT);\n    std_symbol(\"print2dascii\", PRINT2DASCII);\n    std_symbol(\"printcomputer\", PRINTFULL);\n    std_symbol(\"printlatex\", PRINTLATEX);\n    std_symbol(\"printlist\", PRINTLIST);\n    std_symbol(\"printhuman\", PRINTPLAIN);\n    std_symbol(\"printLeaveEAlone\", PRINT_LEAVE_E_ALONE);\n    std_symbol(\"printLeaveXAlone\", PRINT_LEAVE_X_ALONE);\n    std_symbol(\"product\", PRODUCT);\n    std_symbol(\"quote\", QUOTE);\n    std_symbol(\"quotient\", QUOTIENT);\n    std_symbol(\"rank\", RANK);\n    std_symbol(\"rationalize\", RATIONALIZE);\n    std_symbol(\"real\", REAL);\n    std_symbol(\"rect\", YYRECT);\n    std_symbol(\"roots\", ROOTS);\n    std_symbol(\"round\", ROUND);\n    std_symbol(\"equals\", SETQ);\n    std_symbol(\"sgn\", SGN);\n    std_symbol(\"silentpattern\", SILENTPATTERN);\n    std_symbol(\"simplify\", SIMPLIFY);\n    std_symbol(\"sin\", SIN);\n    std_symbol(\"sinh\", SINH);\n    std_symbol(\"shape\", SHAPE);\n    std_symbol(\"sqrt\", SQRT);\n    std_symbol(\"stop\", STOP);\n    std_symbol(\"subst\", SUBST);\n    std_symbol(\"sum\", SUM);\n    std_symbol(\"symbolsinfo\", SYMBOLSINFO);\n    std_symbol(\"tan\", TAN);\n    std_symbol(\"tanh\", TANH);\n    std_symbol(\"taylor\", TAYLOR);\n    std_symbol(\"test\", TEST);\n    std_symbol(\"testeq\", TESTEQ);\n    std_symbol(\"testge\", TESTGE);\n    std_symbol(\"testgt\", TESTGT);\n    std_symbol(\"testle\", TESTLE);\n    std_symbol(\"testlt\", TESTLT);\n    std_symbol(\"transpose\", TRANSPOSE);\n    std_symbol(\"unit\", UNIT);\n    std_symbol(\"zero\", ZERO);\n    std_symbol(\"nil\", NIL);\n    std_symbol(\"autoexpand\", AUTOEXPAND);\n    std_symbol(\"bake\", BAKE);\n    std_symbol(\"assumeRealVariables\", ASSUME_REAL_VARIABLES);\n    std_symbol(\"last\", LAST);\n    std_symbol(\"lastprint\", LAST_PRINT);\n    std_symbol(\"last2dasciiprint\", LAST_2DASCII_PRINT);\n    std_symbol(\"lastfullprint\", LAST_FULL_PRINT);\n    std_symbol(\"lastlatexprint\", LAST_LATEX_PRINT);\n    std_symbol(\"lastlistprint\", LAST_LIST_PRINT);\n    std_symbol(\"lastplainprint\", LAST_PLAIN_PRINT);\n    std_symbol(\"trace\", TRACE);\n    std_symbol(\"forceFixedPrintout\", FORCE_FIXED_PRINTOUT);\n    std_symbol(\"maxFixedPrintoutDigits\", MAX_FIXED_PRINTOUT_DIGITS);\n    std_symbol(\"~\", YYE);\n    std_symbol(\"$DRAWX\", DRAWX);\n    std_symbol(\"$METAA\", METAA);\n    std_symbol(\"$METAB\", METAB);\n    std_symbol(\"$METAX\", METAX);\n    std_symbol(\"$SECRETX\", SECRETX);\n    std_symbol(\"version\", VERSION);\n    std_symbol(\"pi\", PI);\n    std_symbol(\"a\", SYMBOL_A);\n    std_symbol(\"b\", SYMBOL_B);\n    std_symbol(\"c\", SYMBOL_C);\n    std_symbol(\"d\", SYMBOL_D);\n    std_symbol(\"i\", SYMBOL_I);\n    std_symbol(\"j\", SYMBOL_J);\n    std_symbol(\"n\", SYMBOL_N);\n    std_symbol(\"r\", SYMBOL_R);\n    std_symbol(\"s\", SYMBOL_S);\n    std_symbol(\"t\", SYMBOL_T);\n    std_symbol(\"x\", SYMBOL_X);\n    std_symbol(\"y\", SYMBOL_Y);\n    std_symbol(\"z\", SYMBOL_Z);\n    std_symbol(\"I\", SYMBOL_IDENTITY_MATRIX);\n    std_symbol(\"a_\", SYMBOL_A_UNDERSCORE);\n    std_symbol(\"b_\", SYMBOL_B_UNDERSCORE);\n    std_symbol(\"x_\", SYMBOL_X_UNDERSCORE);\n    std_symbol(\"$C1\", C1);\n    std_symbol(\"$C2\", C2);\n    std_symbol(\"$C3\", C3);\n    std_symbol(\"$C4\", C4);\n    std_symbol(\"$C5\", C5);\n    std_symbol(\"$C6\", C6);\n    defineSomeHandyConstants();\n    originalCodeGen = codeGen;\n    codeGen = false;\n\n    for (defn_i = l1 = 0, ref2 = defn_str.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; defn_i = 0 <= ref2 ? ++l1 : --l1) {\n      definitionOfInterest = defn_str[defn_i];\n      scan(definitionOfInterest);\n\n      if (DEBUG) {\n        console.log(\"... evaling \" + definitionOfInterest);\n        console.log(\"top of stack:\");\n        console.log(_print_list(stack[tos - 1]));\n      }\n\n      Eval();\n      pop();\n    }\n\n    return codeGen = originalCodeGen;\n  };\n\n  defineSomeHandyConstants = function defineSomeHandyConstants() {\n    push_integer(0);\n    zero = pop();\n    push_integer(1);\n    one = pop();\n    push_double(1.0);\n    one_as_double = pop();\n    push_symbol(POWER);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    push_integer(-1);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    push_rational(1, 2);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    list(3);\n\n    if (DEBUG) {\n      console.log(_print_list(stack[tos - 1]));\n    }\n\n    return imaginaryunit = pop();\n  };\n\n  mcmp = function mcmp(a, b) {\n    return a.compare(b);\n  };\n\n  mcmpint = function mcmpint(a, n) {\n    var b, t;\n    b = bigInt(n);\n    t = mcmp(a, b);\n    return t;\n  };\n\n  strcmp = function strcmp(str1, str2) {\n    if (str1 === str2) {\n      return 0;\n    } else if (str1 > str2) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  doubleToReasonableString = function doubleToReasonableString(d) {\n    var maxFixedPrintoutDigits, stringRepresentation;\n\n    if (codeGen) {\n      return \"\" + d;\n    }\n\n    if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {\n      stringRepresentation = \"\" + d;\n\n      if (printMode === PRINTMODE_LATEX) {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"\\\\mathrm{e}{$1}\");\n        } else {\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0\\\\mathrm{e}{$2}\");\n        }\n      } else {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"*10^($1)\");\n        } else {\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0*10^($2)\");\n        }\n      }\n    } else {\n      push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));\n      maxFixedPrintoutDigits = pop_integer();\n      stringRepresentation = \"\" + d.toFixed(maxFixedPrintoutDigits);\n      stringRepresentation = stringRepresentation.replace(/(\\.\\d*?[1-9])0+$/gm, \"$1\");\n      stringRepresentation = stringRepresentation.replace(/\\.0+$/gm, \"\");\n\n      if (stringRepresentation.indexOf(\".\") === -1) {\n        stringRepresentation += \".0\";\n      }\n\n      if (parseFloat(stringRepresentation) !== d) {\n        stringRepresentation = d.toFixed(maxFixedPrintoutDigits) + \"...\";\n      }\n    }\n\n    return stringRepresentation;\n  };\n\n  clear_term = function clear_term() {};\n\n  isspace = function isspace(s) {\n    if (s == null) {\n      return false;\n    }\n\n    return s === ' ' || s === '\\t' || s === '\\n' || s === '\\v' || s === '\\f' || s === '\\r';\n  };\n\n  isdigit = function isdigit(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return /^\\d+$/.test(str);\n  };\n\n  isalpha = function isalpha(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return str.search(/[^A-Za-z]/) === -1;\n  };\n\n  isalphaOrUnderscore = function isalphaOrUnderscore(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return str.search(/[^A-Za-z_]/) === -1;\n  };\n\n  isunderscore = function isunderscore(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return str.search(/_/) === -1;\n  };\n\n  isalnumorunderscore = function isalnumorunderscore(str) {\n    if (str == null) {\n      return false;\n    }\n\n    return isalphaOrUnderscore(str) || isdigit(str);\n  };\n\n  _count = function count(p) {\n    var n;\n\n    if (iscons(p)) {\n      n = 0;\n\n      while (iscons(p)) {\n        n += _count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n\n    return n;\n  };\n\n  _countOccurrencesOfSymbol = function countOccurrencesOfSymbol(needle, p) {\n    var n;\n    n = 0;\n\n    if (iscons(p)) {\n      while (iscons(p)) {\n        n += _countOccurrencesOfSymbol(needle, car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (equal(needle, p)) {\n        n = 1;\n      }\n    }\n\n    return n;\n  };\n\n  countsize = function countsize(p) {\n    var i, l1, n, ref2;\n    n = 0;\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        n += p.tensor.elem[i];\n      }\n    } else if (iscons(p)) {\n      while (iscons(p)) {\n        n += _count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n\n    return n;\n  };\n\n  stop = function stop(s) {\n    var message;\n    errorMessage += \"Stop: \";\n    errorMessage += s;\n    message = errorMessage;\n    errorMessage = '';\n    moveTos(0);\n    throw new Error(message);\n  };\n\n  findDependenciesInScript = function findDependenciesInScript(stringToBeParsed, dontGenerateCode) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t1, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;\n\n    if (DEBUG) {\n      console.log(\"stringToBeParsed: \" + stringToBeParsed);\n    }\n\n    timeStartFromAlgebra = new Date().getTime();\n    inited = true;\n    codeGen = true;\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    symbolsInExpressionsWithoutAssignments = [];\n    patternHasBeenFound = false;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    n = 0;\n    dependencyInfo = {\n      affectsVariables: [],\n      affectedBy: []\n    };\n    stringToBeRun = stringToBeParsed;\n\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n\n        if (DEBUG) {\n          console.log(\"findDependenciesInScript: scanning\");\n        }\n\n        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));\n\n        if (DEBUG) {\n          console.log(\"scanned\");\n        }\n\n        pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n\n        errorMessage = error + \"\";\n        reset_after_error();\n        break;\n      }\n\n      if (n === 0) {\n        break;\n      }\n\n      indexOfPartRemainingToBeParsed += n;\n    }\n\n    testableString = \"\";\n\n    if (DEBUG) {\n      console.log(\"all local dependencies ----------------\");\n    }\n\n    testableString += \"All local dependencies: \";\n\n    for (key in symbolsDependencies) {\n      value = symbolsDependencies[key];\n\n      if (DEBUG) {\n        console.log(\"variable \" + key + \" depends on: \");\n      }\n\n      dependencyInfo.affectsVariables.push(key);\n      testableString += \" variable \" + key + \" depends on: \";\n\n      for (l1 = 0, len = value.length; l1 < len; l1++) {\n        i = value[l1];\n\n        if (DEBUG) {\n          console.log(\"    \" + i);\n        }\n\n        if (i[0] !== \"'\") {\n          dependencyInfo.affectedBy.push(i);\n        }\n\n        testableString += i + \", \";\n      }\n\n      testableString += \"; \";\n    }\n\n    testableString += \". \";\n\n    if (DEBUG) {\n      console.log(\"Symbols with reassignments ----------------\");\n    }\n\n    testableString += \"Symbols with reassignments: \";\n\n    for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {\n      key = symbolsHavingReassignments[m1];\n\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n\n    testableString += \". \";\n\n    if (DEBUG) {\n      console.log(\"Symbols in expressions without assignments ----------------\");\n    }\n\n    testableString += \"Symbols in expressions without assignments: \";\n\n    for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {\n      key = symbolsInExpressionsWithoutAssignments[n1];\n\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n\n    testableString += \". \";\n    dependencyInfo.affectedBy.push(\"PATTERN_DEPENDENCY\");\n\n    if (patternHasBeenFound) {\n      dependencyInfo.affectsVariables.push(\"PATTERN_DEPENDENCY\");\n      testableString += \" - PATTERN_DEPENDENCY inserted - \";\n    }\n\n    if (DEBUG) {\n      console.log(\"All dependencies recursively ----------------\");\n    }\n\n    testableString += \"All dependencies recursively: \";\n    scriptEvaluation = [\"\", \"\"];\n    generatedCode = \"\";\n    readableSummaryOfGeneratedCode = \"\";\n\n    if (errorMessage === \"\" && !dontGenerateCode) {\n      try {\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n        scriptEvaluation = run(stringToBeParsed, true);\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n      } catch (error1) {\n        error = error1;\n\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n\n        errorMessage = error + \"\";\n        init();\n      }\n\n      if (errorMessage === \"\") {\n        for (key in symbolsDependencies) {\n          codeGen = true;\n\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n\n          codeGen = false;\n\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" depends on: \");\n          }\n\n          testableString += \" variable \" + key + \" depends on: \";\n          recursedDependencies = [];\n          variablesWithCycles = [];\n          cyclesDescriptions = [];\n\n          _recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);\n\n          for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {\n            i = variablesWithCycles[o1];\n\n            if (DEBUG) {\n              console.log(\"    --> cycle through \" + i);\n            }\n          }\n\n          for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {\n            i = recursedDependencies[q1];\n\n            if (DEBUG) {\n              console.log(\"    \" + i);\n            }\n\n            testableString += i + \", \";\n          }\n\n          testableString += \"; \";\n\n          for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {\n            i = cyclesDescriptions[r1];\n            testableString += \" \" + i + \", \";\n          }\n\n          if (DEBUG) {\n            console.log(\"  code generation:\" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n\n          push(get_binding(usr_symbol(key)));\n          replacementsFrom = [];\n          replacementsTo = [];\n\n          for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {\n            eachDependency = recursedDependencies[s1];\n\n            if (eachDependency[0] === \"'\") {\n              deQuotedDep = eachDependency.substring(1);\n              originalUserSymbol = usr_symbol(deQuotedDep);\n              newUserSymbol = usr_symbol(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\" + deQuotedDep);\n              replacementsFrom.push(originalUserSymbol);\n              replacementsTo.push(newUserSymbol);\n              push(originalUserSymbol);\n              push(newUserSymbol);\n\n              _subst();\n\n              if (DEBUG) {\n                console.log(\"after substitution: \" + stack[tos - 1]);\n              }\n            }\n          }\n\n          try {\n            simplifyForCodeGeneration();\n          } catch (error1) {\n            error = error1;\n\n            if (PRINTOUTRESULT) {\n              console.log(error);\n            }\n\n            errorMessage = error + \"\";\n            init();\n          }\n\n          for (indexOfEachReplacement = t1 = 0, ref2 = replacementsFrom.length; 0 <= ref2 ? t1 < ref2 : t1 > ref2; indexOfEachReplacement = 0 <= ref2 ? ++t1 : --t1) {\n            push(replacementsTo[indexOfEachReplacement]);\n            push(replacementsFrom[indexOfEachReplacement]);\n\n            _subst();\n          }\n\n          clearRenamedVariablesToAvoidBindingToExternalScope();\n\n          if (errorMessage === \"\") {\n            toBePrinted = pop();\n            userVariablesMentioned = [];\n\n            _collectUserSymbols(toBePrinted, userVariablesMentioned);\n\n            allReturnedPlainStrings = \"\";\n            allReturnedLatexStrings = \"\";\n            codeGen = true;\n            generatedBody = toBePrinted.toString();\n            codeGen = false;\n            origPrintMode = printMode;\n            printMode = PRINTMODE_LATEX;\n            bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();\n            printMode = origPrintMode;\n\n            if (variablesWithCycles.indexOf(key) !== -1) {\n              generatedCode += \"// \" + key + \" is part of a cyclic dependency, no code generated.\";\n              readableSummaryOfGeneratedCode += \"#\" + key + \" is part of a cyclic dependency, no code generated.\";\n            } else {\n              /*\n               * using this paragraph instead of the following one\n               * creates methods signatures that\n               * are slightly less efficient\n               * i.e. variables compare even if they are\n               * simplified away.\n               * In theory these signatures are more stable, but\n               * in practice signatures vary quite a bit anyways\n               * depending on previous assignments for example,\n               * so it's unclear whether going for stability\n               * is sensible at all..\n              if recursedDependencies.length != 0\n                parameters = \"(\"\n                for i in recursedDependencies\n                  if i.indexOf(\"'\") != 0\n                    parameters += i + \", \"\n                  else\n                    if recursedDependencies.indexOf(i.substring(1)) == -1\n                      parameters += i.substring(1) + \", \"\n               */\n              userVariablesMentioned = userVariablesMentioned.filter(function (x) {\n                return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x + \"\") === -1;\n              });\n              userVariablesMentioned = userVariablesMentioned.filter(function (x) {\n                return recursedDependencies.indexOf(x + \"\") !== -1 || recursedDependencies.indexOf(\"\\'\" + x + \"\") !== -1;\n              });\n\n              if (userVariablesMentioned.length !== 0) {\n                parameters = \"(\";\n\n                for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {\n                  i = userVariablesMentioned[u1];\n\n                  if (i.printname !== key) {\n                    parameters += i.printname + \", \";\n                  }\n                }\n\n                parameters = parameters.replace(/, $/gm, \"\");\n                parameters += \")\";\n                generatedCode += key + \" = function \" + parameters + \" { return ( \" + generatedBody + \" ); }\";\n                readableSummaryOfGeneratedCode += key + parameters + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              } else {\n                generatedCode += key + \" = \" + generatedBody + \";\";\n                readableSummaryOfGeneratedCode += key + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              }\n            }\n\n            generatedCode += \"\\n\";\n            readableSummaryOfGeneratedCode += \"\\n\";\n\n            if (DEBUG) {\n              console.log(\"    \" + generatedCode);\n            }\n          }\n        }\n      }\n    }\n\n    generatedCode = generatedCode.replace(/\\n$/gm, \"\");\n    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\\n$/gm, \"\");\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    patternHasBeenFound = false;\n    symbolsInExpressionsWithoutAssignments = [];\n\n    if (DEBUG) {\n      console.log(\"testable string: \" + testableString);\n    }\n\n    if (TIMING_DEBUGS) {\n      console.log(\"findDependenciesInScript time for: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStartFromAlgebra) + \"ms\");\n    }\n\n    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];\n  };\n\n  _recursiveDependencies = function recursiveDependencies(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {\n    var cyclesDescription, i, k, l1, len, len1, m1, ref2;\n    variablesAlreadyFleshedOut.push(variableToBeChecked);\n\n    if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {\n      if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf(\"'\" + variableToBeChecked) !== -1) {\n        if (DEBUG) {\n          console.log(\"can't keep following the chain of \" + variableToBeChecked + \" because it's actually a variable bound to a parameter\");\n        }\n\n        if (arrayWhereDependenciesWillBeAdded.indexOf(\"'\" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n          arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n        }\n\n        return arrayWhereDependenciesWillBeAdded;\n      }\n    }\n\n    chainBeingChecked.push(variableToBeChecked);\n\n    if (symbolsDependencies[variableToBeChecked] == null) {\n      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n      }\n\n      return arrayWhereDependenciesWillBeAdded;\n    } else {\n      ref2 = symbolsDependencies[variableToBeChecked];\n\n      for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n        i = ref2[l1];\n\n        if (chainBeingChecked.indexOf(i) !== -1) {\n          if (DEBUG) {\n            console.log(\"  found cycle:\");\n          }\n\n          cyclesDescription = \"\";\n\n          for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {\n            k = chainBeingChecked[m1];\n\n            if (variablesWithCycles.indexOf(k) === -1) {\n              variablesWithCycles.push(k);\n            }\n\n            if (DEBUG) {\n              console.log(k + \" --> \");\n            }\n\n            cyclesDescription += k + \" --> \";\n          }\n\n          if (DEBUG) {\n            console.log(\" ... then \" + i + \" again\");\n          }\n\n          cyclesDescription += \" ... then \" + i + \" again\";\n          cyclesDescriptions.push(cyclesDescription);\n\n          if (variablesWithCycles.indexOf(i) === -1) {\n            variablesWithCycles.push(i);\n          }\n        } else {\n          _recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);\n\n          chainBeingChecked.pop();\n        }\n      }\n\n      return arrayWhereDependenciesWillBeAdded;\n    }\n  };\n\n  inited = false;\n  latexErrorSign = \"\\\\rlap{\\\\large\\\\color{red}\\\\bigtriangleup}{\\\\ \\\\ \\\\tiny\\\\color{red}!}\";\n\n  turnErrorMessageToLatex = function turnErrorMessageToLatex(theErrorMessage) {\n    theErrorMessage = theErrorMessage.replace(/\\n/g, \"\");\n    theErrorMessage = theErrorMessage.replace(/_/g, \"} \\\\_ \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), 'g'), \"}{}^{T}\\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), 'g'), \"}\\\\cdot \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"Stop:\", \"}  \\\\quad \\\\text{Stop:\");\n    theErrorMessage = theErrorMessage.replace(\"->\", \"}  \\\\rightarrow \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"?\", \"}\\\\enspace \" + latexErrorSign + \" \\\\enspace  \\\\text{\");\n    theErrorMessage = \"$$\\\\text{\" + theErrorMessage.replace(/\\n/g, \"\") + \"}$$\";\n    return theErrorMessage;\n  };\n\n  normaliseDots = function normaliseDots(stringToNormalise) {\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), 'g'), String.fromCharCode(dotprod_unicode));\n    return stringToNormalise;\n  };\n\n  TIMING_DEBUGS = false;\n\n  run = function run(stringToBeRun, generateLatex) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i, indexOfPartRemainingToBeParsed, n, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;\n\n    if (generateLatex == null) {\n      generateLatex = false;\n    }\n\n    timeStart = new Date().getTime();\n    stringToBeRun = normaliseDots(stringToBeRun);\n\n    if (stringToBeRun === \"selftest\") {\n      selftest();\n      return;\n    }\n\n    if (!inited) {\n      inited = true;\n      init();\n    }\n\n    i = 0;\n    n = 0;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));\n        p1 = pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n\n        allReturnedPlainStrings += error.message;\n\n        if (generateLatex) {\n          theErrorMessage = turnErrorMessageToLatex(error.message);\n          allReturnedLatexStrings += theErrorMessage;\n        }\n\n        reset_after_error();\n        break;\n      }\n\n      if (n === 0) {\n        break;\n      }\n\n      indexOfPartRemainingToBeParsed += n;\n      push(p1);\n      errorWhileExecution = false;\n\n      try {\n        stringsEmittedByUserPrintouts = \"\";\n        top_level_eval();\n        p2 = pop();\n        check_stack();\n\n        if (isstr(p2)) {\n          if (DEBUG) {\n            console.log(p2.str);\n          }\n\n          if (DEBUG) {\n            console.log(\"\\n\");\n          }\n        }\n\n        if (p2 === symbol(NIL)) {\n          collectedPlainResult = stringsEmittedByUserPrintouts;\n\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + stringsEmittedByUserPrintouts + \"$$\";\n          }\n        } else {\n          collectedPlainResult = print_expr(p2);\n          collectedPlainResult += \"\\n\";\n\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + collectLatexStringFromReturnValue(p2) + \"$$\";\n\n            if (DEBUG) {\n              console.log(\"collectedLatexResult: \" + collectedLatexResult);\n            }\n          }\n        }\n\n        allReturnedPlainStrings += collectedPlainResult;\n\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n        }\n\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"printline\");\n          }\n\n          if (DEBUG) {\n            console.log(collectedPlainResult);\n          }\n        }\n\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"display:\");\n          }\n\n          print2dascii(p2);\n        }\n\n        if (generateLatex) {\n          allReturnedLatexStrings += \"\\n\";\n        }\n      } catch (error1) {\n        error = error1;\n        errorWhileExecution = true;\n        collectedPlainResult = error.message;\n\n        if (generateLatex) {\n          collectedLatexResult = turnErrorMessageToLatex(error.message);\n        }\n\n        if (PRINTOUTRESULT) {\n          console.log(collectedPlainResult);\n        }\n\n        allReturnedPlainStrings += collectedPlainResult;\n\n        if (collectedPlainResult !== \"\") {\n          allReturnedPlainStrings += \"\\n\";\n        }\n\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n          allReturnedLatexStrings += \"\\n\";\n        }\n\n        init();\n      }\n    }\n\n    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === \"\\n\") {\n      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);\n    }\n\n    if (generateLatex) {\n      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === \"\\n\") {\n        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);\n      }\n    }\n\n    if (generateLatex) {\n      if (DEBUG) {\n        console.log(\"allReturnedLatexStrings: \" + allReturnedLatexStrings);\n      }\n\n      stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];\n    } else {\n      stringToBeReturned = allReturnedPlainStrings;\n    }\n\n    if (TIMING_DEBUGS) {\n      timingDebugWrite = \"run time on: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStart) + \"ms\";\n      console.log(timingDebugWrite);\n    }\n\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    return stringToBeReturned;\n  };\n\n  check_stack = function check_stack() {\n    if (tos !== 0) {\n      debugger;\n      stop(\"stack error\");\n    }\n\n    if (frame !== TOS) {\n      debugger;\n      stop(\"frame error\");\n    }\n\n    if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {\n      debugger;\n      stop(\"symbols evaluation still ongoing?\");\n    }\n\n    if (evaluatingAsFloats !== 0) {\n      debugger;\n      stop(\"numeric evaluation still ongoing?\");\n    }\n\n    if (evaluatingPolar !== 0) {\n      debugger;\n      return stop(\"evaluation of polar still ongoing?\");\n    }\n  };\n\n  top_level_eval = function top_level_eval() {\n    var evalledArgument, originalArgument, shouldAutoexpand;\n\n    if (DEBUG) {\n      console.log(\"#### top level eval\");\n    }\n\n    trigmode = 0;\n    shouldAutoexpand = symbol(AUTOEXPAND);\n\n    if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {\n      expanding = 0;\n    } else {\n      expanding = 1;\n    }\n\n    originalArgument = top();\n    Eval();\n    evalledArgument = top();\n\n    if (evalledArgument === symbol(NIL)) {\n      return;\n    }\n\n    set_binding(symbol(LAST), evalledArgument);\n\n    if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {\n      _bake();\n\n      evalledArgument = top();\n    }\n\n    if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {} else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_J);\n      return _subst();\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_I);\n      return _subst();\n    }\n  };\n\n  check_esc_flag = function check_esc_flag() {\n    if (esc_flag) {\n      return stop(\"esc key\");\n    }\n  };\n\n  clearAlgebraEnvironment = function clearAlgebraEnvironment() {\n    return do_clearall();\n  };\n\n  computeDependenciesFromAlgebra = function computeDependenciesFromAlgebra(codeFromAlgebraBlock) {\n    var i, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;\n\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra!!!\");\n    }\n\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra: patterns in the list --------------- \");\n\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n\n      console.log(\"...end of list --------------- \");\n    }\n\n    called_from_Algebra_block = false;\n    return findDependenciesInScript(codeFromAlgebraBlock, true)[6];\n  };\n\n  computeResultsAndJavaScriptFromAlgebra = function computeResultsAndJavaScriptFromAlgebra(codeFromAlgebraBlock) {\n    var code, dependencyInfo, i, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, ref2, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    timeStartFromAlgebra = new Date().getTime();\n\n    if (TIMING_DEBUGS) {\n      console.log(\" --------- computeResultsAndJavaScriptFromAlgebra input: \" + codeFromAlgebraBlock + \" at: \" + new Date());\n    }\n\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    stringToBeRun = codeFromAlgebraBlock;\n\n    if (DEBUG) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- \");\n\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n\n      console.log(\"...end of list --------------- \");\n    }\n\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n\n    ref2 = findDependenciesInScript(codeFromAlgebraBlock), testableStringIsIgnoredHere = ref2[0], result = ref2[1], code = ref2[2], readableSummaryOfCode = ref2[3], latexResult = ref2[4], errorMessage = ref2[5], dependencyInfo = ref2[6];\n    called_from_Algebra_block = false;\n\n    if (readableSummaryOfCode !== \"\" || errorMessage !== \"\") {\n      result += \"\\n\" + readableSummaryOfCode;\n\n      if (errorMessage !== \"\") {\n        result += \"\\n\" + errorMessage;\n      }\n\n      result = result.replace(/\\n/g, \"\\n\\n\");\n      latexResult += \"\\n\" + \"$$\" + readableSummaryOfCode + \"$$\";\n\n      if (errorMessage !== \"\") {\n        latexResult += turnErrorMessageToLatex(errorMessage);\n      }\n\n      latexResult = latexResult.replace(/\\n/g, \"\\n\\n\");\n    }\n\n    latexResult = latexResult.replace(/\\n*/, \"\");\n    latexResult = latexResult.replace(/\\$\\$\\$\\$\\n*/g, \"\");\n    code = code.replace(/Math\\./g, \"\");\n    code = code.replace(/\\n/g, \"\\n\\n\");\n\n    if (TIMING_DEBUGS) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStartFromAlgebra) + \"ms\");\n    }\n\n    return {\n      code: code,\n      result: latexResult,\n      latexResult: latexResult,\n      dependencyInfo: dependencyInfo\n    };\n  };\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).run = run;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;\n  tos = 0;\n  nil_symbols = 0;\n\n  push = function push(p) {\n    if (p == null) {\n      debugger;\n    }\n\n    if (p.isZero != null) {\n      debugger;\n    }\n\n    if (p === symbol(NIL)) {\n      nil_symbols++;\n\n      if (DEBUG) {\n        console.log(\"pushing symbol(NIL) #\" + nil_symbols);\n      }\n    }\n\n    if (tos >= frame) {\n      stop(\"stack overflow\");\n    }\n\n    return stack[tos++] = p;\n  };\n\n  moveTos = function moveTos(stackPos) {\n    if (tos <= stackPos) {\n      tos = stackPos;\n      return;\n    }\n\n    while (tos > stackPos) {\n      stack[tos] = null;\n      tos--;\n    }\n  };\n\n  top = function top() {\n    return stack[tos - 1];\n  };\n\n  pop = function pop() {\n    var elementToBeReturned;\n\n    if (tos === 0) {\n      debugger;\n      stop(\"stack underflow\");\n    }\n\n    if (stack[tos - 1] == null) {\n      debugger;\n    }\n\n    elementToBeReturned = stack[--tos];\n    stack[tos] = null;\n    return elementToBeReturned;\n  };\n\n  push_frame = function push_frame(n) {\n    var i, l1, ref2, results;\n    i = 0;\n    frame -= n;\n\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n\n    results = [];\n\n    for (i = l1 = 0, ref2 = n; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      results.push(stack[frame + i] = symbol(NIL));\n    }\n\n    return results;\n  };\n\n  pop_frame = function pop_frame(n) {\n    frame += n;\n\n    if (frame > TOS) {\n      return stop(\"frame underflow\");\n    }\n  };\n\n  save = function save() {\n    frame -= 10;\n\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n\n    stack[frame + 0] = p0;\n    stack[frame + 1] = p1;\n    stack[frame + 2] = p2;\n    stack[frame + 3] = p3;\n    stack[frame + 4] = p4;\n    stack[frame + 5] = p5;\n    stack[frame + 6] = p6;\n    stack[frame + 7] = p7;\n    stack[frame + 8] = p8;\n    return stack[frame + 9] = p9;\n  };\n\n  restore = function restore() {\n    if (frame > TOS - 10) {\n      stop(\"frame underflow\");\n    }\n\n    p0 = stack[frame + 0];\n    p1 = stack[frame + 1];\n    p2 = stack[frame + 2];\n    p3 = stack[frame + 3];\n    p4 = stack[frame + 4];\n    p5 = stack[frame + 5];\n    p6 = stack[frame + 6];\n    p7 = stack[frame + 7];\n    p8 = stack[frame + 8];\n    p9 = stack[frame + 9];\n    return frame += 10;\n  };\n\n  swap = function swap() {\n    var p, q;\n    p = pop();\n    q = pop();\n    push(p);\n    return push(q);\n  };\n\n  dupl = function dupl() {\n    var p;\n    p = pop();\n    push(p);\n    return push(p);\n  };\n\n  $.dupl = dupl;\n  $.swap = swap;\n  $.restore = restore;\n  $.save = save;\n  $.push = push;\n  $.pop = pop;\n\n  Eval_symbolsinfo = function Eval_symbolsinfo() {\n    var symbolsinfoToBePrinted;\n    symbolsinfoToBePrinted = symbolsinfo();\n\n    if (symbolsinfoToBePrinted !== \"\") {\n      return new_string(symbolsinfoToBePrinted);\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  symbolsinfo = function symbolsinfo() {\n    var bindingi, i, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;\n    symbolsinfoToBePrinted = \"\";\n\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      symtabi = symtab[i] + \"\";\n      bindingi = (binding[i] + \"\").substring(0, 4);\n      symbolsinfoToBePrinted += \"symbol: \" + symtabi + \" size: \" + countsize(binding[i]) + \" value: \" + bindingi + \"...\\n\";\n    }\n\n    return symbolsinfoToBePrinted;\n  };\n\n  std_symbol = function std_symbol(s, n, latexPrint) {\n    var p;\n    p = symtab[n];\n\n    if (p == null) {\n      debugger;\n    }\n\n    p.printname = s;\n\n    if (latexPrint != null) {\n      return p.latexPrint = latexPrint;\n    } else {\n      return p.latexPrint = s;\n    }\n  };\n\n  usr_symbol = function usr_symbol(s) {\n    var i, l1, ref2;\n    i = 0;\n\n    for (i = l1 = 0, ref2 = NSYM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (s === symtab[i].printname) {\n        return symtab[i];\n      }\n\n      if (symtab[i].printname === \"\") {\n        break;\n      }\n    }\n\n    if (i === NSYM) {\n      stop(\"symbol table overflow\");\n    }\n\n    symtab[i] = new U();\n    symtab[i].k = SYM;\n    symtab[i].printname = s;\n    binding[i] = symtab[i];\n    isSymbolReclaimable[i] = false;\n    return symtab[i];\n  };\n\n  get_printname = function get_printname(p) {\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    return p.printname;\n  };\n\n  set_binding = function set_binding(p, q) {\n    var indexFound;\n\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n     */\n\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n\n    if (DEBUG) {\n      console.log(\"lookup >> set_binding lookup \" + indexFound);\n    }\n\n    isSymbolReclaimable[indexFound] = false;\n    return binding[indexFound] = q;\n  };\n\n  get_binding = function get_binding(p) {\n    var indexFound;\n\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n     */\n\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n\n    if (DEBUG) {\n      console.log(\"lookup >> get_binding lookup \" + indexFound);\n    }\n\n    return binding[indexFound];\n  };\n\n  is_usr_symbol = function is_usr_symbol(p) {\n    var theSymnum;\n\n    if (p.k !== SYM) {\n      return false;\n    }\n\n    theSymnum = symnum(p);\n\n    if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {\n      return true;\n    }\n\n    return false;\n  };\n\n  lookupsTotal = 0;\n\n  symnum = function symnum(p) {\n    var indexFound;\n    lookupsTotal++;\n\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n\n    indexFound = symtab.indexOf(p);\n\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n\n    if (DEBUG) {\n      console.log(\"lookup >> symnum lookup \" + indexFound + \" lookup # \" + lookupsTotal);\n    }\n\n    return indexFound;\n  };\n\n  push_symbol = function push_symbol(k) {\n    return push(symtab[k]);\n  };\n\n  clear_symbols = function clear_symbols() {\n    var i, l1, ref2, ref3, results;\n    results = [];\n\n    for (i = l1 = ref2 = NIL + 1, ref3 = NSYM; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      results.push(isSymbolReclaimable[i] = false);\n    }\n\n    return results;\n  };\n\n  _collectUserSymbols = function collectUserSymbols(p, accumulator) {\n    var i, l1, ref2;\n\n    if (accumulator == null) {\n      accumulator = [];\n    }\n\n    if (is_usr_symbol(p)) {\n      if (accumulator.indexOf(p) === -1) {\n        accumulator.push(p);\n        return;\n      }\n    }\n\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n        _collectUserSymbols(p.tensor.elem[i], accumulator);\n      }\n\n      return;\n    }\n\n    while (iscons(p)) {\n      _collectUserSymbols(car(p), accumulator);\n\n      p = cdr(p);\n    }\n  };\n\n  $.get_binding = get_binding;\n  $.set_binding = set_binding;\n  $.usr_symbol = usr_symbol;\n  $.symbolsinfo = symbolsinfo;\n  $.collectUserSymbols = _collectUserSymbols;\n\n  if (!inited) {\n    inited = true;\n    init();\n  }\n\n  $.init = init;\n\n  parse_internal = function parse_internal(argu) {\n    if (typeof argu === 'string') {\n      return scan(argu);\n    } else if (typeof argu === 'number') {\n      if (argu % 1 === 0) {\n        return push_integer(argu);\n      } else {\n        return push_double(argu);\n      }\n    } else if (argu instanceof U) {\n      return push(argu);\n    } else {\n      console.warn('unknown argument type', argu);\n      return push(symbol(NIL));\n    }\n  };\n\n  parse = function parse(argu) {\n    var data, error;\n\n    try {\n      parse_internal(argu);\n      data = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n\n    return data;\n  };\n\n  exec = function exec() {\n    var argu, argus, error, fn, l1, len, name, result;\n    name = arguments[0], argus = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    fn = get_binding(usr_symbol(name));\n    check_stack();\n    push(fn);\n\n    for (l1 = 0, len = argus.length; l1 < len; l1++) {\n      argu = argus[l1];\n      parse_internal(argu);\n    }\n\n    list(1 + argus.length);\n    p1 = pop();\n    push(p1);\n\n    try {\n      top_level_eval();\n      result = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n\n    return result;\n  };\n\n  $.exec = exec;\n  $.parse = parse;\n\n  (function () {\n    var builtin_fns, fn, l1, len, results;\n    builtin_fns = [\"abs\", \"add\", \"adj\", \"and\", \"approxratio\", \"arccos\", \"arccosh\", \"arcsin\", \"arcsinh\", \"arctan\", \"arctanh\", \"arg\", \"atomize\", \"besselj\", \"bessely\", \"binding\", \"binomial\", \"ceiling\", \"check\", \"choose\", \"circexp\", \"clear\", \"clearall\", \"clearpatterns\", \"clock\", \"coeff\", \"cofactor\", \"condense\", \"conj\", \"contract\", \"cos\", \"cosh\", \"decomp\", \"defint\", \"deg\", \"denominator\", \"det\", \"derivative\", \"dim\", \"dirac\", \"divisors\", \"do\", \"dot\", \"draw\", \"dsolve\", \"eigen\", \"eigenval\", \"eigenvec\", \"erf\", \"erfc\", \"eval\", \"exp\", \"expand\", \"expcos\", \"expsin\", \"factor\", \"factorial\", \"factorpoly\", \"filter\", \"float\", \"floor\", \"for\", \"Gamma\", \"gcd\", \"hermite\", \"hilbert\", \"imag\", \"component\", \"inner\", \"integral\", \"inv\", \"invg\", \"isinteger\", \"isprime\", \"laguerre\", \"lcm\", \"leading\", \"legendre\", \"log\", \"mod\", \"multiply\", \"not\", \"nroots\", \"number\", \"numerator\", \"operator\", \"or\", \"outer\", \"pattern\", \"patternsinfo\", \"polar\", \"power\", \"prime\", \"print\", \"print2dascii\", \"printcomputer\", \"printlatex\", \"printlist\", \"printhuman\", \"product\", \"quote\", \"quotient\", \"rank\", \"rationalize\", \"real\", \"rect\", \"roots\", \"round\", \"equals\", \"shape\", \"sgn\", \"silentpattern\", \"simplify\", \"sin\", \"sinh\", \"sqrt\", \"stop\", \"subst\", \"sum\", \"symbolsinfo\", \"tan\", \"tanh\", \"taylor\", \"test\", \"testeq\", \"testge\", \"testgt\", \"testle\", \"testlt\", \"transpose\", \"unit\", \"zero\"];\n    results = [];\n\n    for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {\n      fn = builtin_fns[l1];\n      results.push($[fn] = exec.bind(this, fn));\n    }\n\n    return results;\n  })();\n\n  freeze = function freeze() {\n    var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = [];\n    frozenContents = [];\n    frozenPatterns = [];\n    frozenHash = \"\";\n\n    for (i = l1 = 0, ref2 = symtab.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      if (isSymbolReclaimable[i] === false) {\n        frozenSymbols.push(symtab[i]);\n        frozenContents.push(binding[i]);\n      }\n    }\n\n    frozenPatterns = userSimplificationsInListForm.slice(0);\n    return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];\n  };\n\n  unfreeze = function unfreeze(frozen) {\n    var frozenContents, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = frozen[0], frozenContents = frozen[1], frozenPatterns = frozen[2], zero = frozen[3], one = frozen[4], imaginaryunit = frozen[5];\n\n    for (i = l1 = 0, ref2 = frozenSymbols.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = frozenSymbols[i];\n      binding[i] = frozenContents[i];\n    }\n\n    return userSimplificationsInListForm = frozenPatterns.slice(0);\n  };\n\n  compareState = function compareState(previousHash) {\n    var frozenHash;\n    frozenHash = getStateHash();\n\n    if (frozenHash === previousHash) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getStateHash = function getStateHash() {\n    var bindingi, frozenHash, i, l1, len, m1, ref2, ref3, symtabi;\n    frozenHash = \"\";\n\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      symtabi = _print_list(symtab[i]);\n      bindingi = _print_list(binding[i]);\n      frozenHash += \" //\" + symtabi + \" : \" + bindingi;\n    }\n\n    for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {\n      i = userSimplificationsInListForm[m1];\n      frozenHash += \" pattern: \" + i;\n    }\n\n    if (DEBUG) {\n      console.log(\"frozenHash: \" + frozenHash);\n    }\n\n    return frozenHash;\n  };\n}).call(this);"],"sourceRoot":""}